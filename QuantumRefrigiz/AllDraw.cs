/**************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
*************TETRASHOP.IR**************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
**************************************/

using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Threading;
using System.Threading.Tasks;


namespace QuantumRefrigiz
{
    [Serializable]
    public class AllDraw//: IDisposable
    {
        public static bool HarasAct = false;
        public static int StoreInitMaxAStarGreedy = 0;
        public static int StoreInitMaxAStarGreedyEqual = 0;
        public static bool SStopInitMaxAStarGreedy = false;

        //justicce height
        public static int indexStep = 1;

        public int CurrentMaxLevel = 0;
        public static Timer Wtime = null;

        public static Timer Btime = null;
        public static int wtime = 4 * 60 * 1000;
        public static int btime = 4 * 60 * 1000;
        public static int winc = 1000;
        public static int binc = 1000;
        public static int TimeMax = 0;

        public static bool ChangedInTreeOccured = false;
        public static bool ThinkingRunInBothSide = false;
        public static bool IdleInWork = true;
        public const float MaxTimeInMillisseconds = 10;//Max 10 second
        public static float TimeInitiation;

        public static int CalIdle = 1;
        public static int PlatformHelperProcessorCount = 2;

        public static int CompleteNumber = 300;

        public static bool CompleteTreeDo = false;
        public static bool CompleteTreeCancel = false;

        public static int[,,] QuntumTable = {
            {{-1, -1, - 1, -1, -1, -1, -1, -1 },
             {-1, -1, - 1, -1, -1, -1, -1, -1 },
             {-1, -1, - 1, -1, -1, -1, -1, -1 },
             {-1, -1, - 1, -1, -1, -1, -1, -1 },
             {-1, -1, - 1, -1, -1, -1, -1, -1 },
             {-1, -1, - 1, -1, -1, -1, -1, -1 },
             {-1, -1, - 1, -1, -1, -1, -1, -1 },
             {-1, -1, - 1, -1, -1, -1, -1, -1 }},
             {{-1, -1, - 1, -1, -1, -1, -1, -1 },
              {-1, -1, - 1, -1, -1, -1, -1, -1 },
              {-1, -1, - 1, -1, -1, -1, -1, -1 },
              {-1, -1, - 1, -1, -1, -1, -1, -1 },
              {-1, -1, - 1, -1, -1, -1, -1, -1 },
              {-1, -1, - 1, -1, -1, -1, -1, -1 },
              {-1, -1, - 1, -1, -1, -1, -1, -1 },
              {-1, -1, - 1, -1, -1, -1, -1, -1 }}};

        public static bool AllowedSupTrue = false;
        public static int OrderPlateDraw = 1;
        public static bool UniqueLeafDetection = true;
        private int NumberOfnewMove = 0;
        private bool UsedRestrictedMoveBlitzAndFull = true;
        public List<bool> SolderesOnTableMove = new List<bool>();
        public List<bool> ElephantOnTableMove = new List<bool>();
        public List<bool> HoursesOnTableMove = new List<bool>();
        public List<bool> CastlesOnTableMove = new List<bool>();
        public List<bool> MinisterOnTableMove = new List<bool>();
        public List<bool> KingOnTableMove = new List<bool>();
        public List<bool> CastlingOnTableMove = new List<bool>();
        private bool OnlyWin = false;
        public static bool LeafSemaphoreIndex = false;

        //Initiate Variables.
        private bool[] ThinkingAllowed = { false, false, false, false, false, false, false, false, false, false, false, false, false, false };

        [field: NonSerialized] private List<Task> tH = new List<Task>();
        [field: NonSerialized] private List<Task> TH = new List<Task>();
        public static bool Deeperthandeeper = false;
        public static bool FirstTraversalTree = true;
        public static int NumberOfLeafComputation = 0;
        public bool IsCurrentDraw = false;

        public int HaveKilled = 0;

        private int[,] Tabl = new int[8, 8];
        public int OrderP = 0;
        public static int DepthIterative = 0;
        private int PerceptionCount = 0;
        public string OutPutAction = "";
        public static StringBuilder OutPut = new StringBuilder("");
        public static StringBuilder ActionString = new StringBuilder("");
        public static bool ActionStringReady = false;

        //static variable to be Initiate

        public static bool RegardOccurred = false;
        public static int SuppportCountStaticGray = 0;
        public static int SuppportCountStaticBrown = 0;
        private int CurrentAStarGredyMax = 0;
        public static int TaskBegin = 0;
        public static int TaskEnd = 0;
        public static string Root = System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]);
        public static int OrderPlate = 1;
        public static bool Blitz = false;
        public static int ConvertedKind = -2;
        public static bool ConvertWait = true;
        public static bool Stockfish = false;
        public static bool Person = true;
        public static bool THISSecradioButtonGrayOrderChecked = false;
        public static bool THISSecradioButtonBrownOrderChecked = false;
        public static string THIScomboBoxMaxLevelText = "";
        public static AllDraw THISDummy = null;
        public static bool StateCP = false;
        public static bool StateCC = false;
        public static int LastRowQ = -1;
        public static int LastColumnQ = -1;
        public static int NextRowQ = -1;
        public static int NextColumnQ = -1;
        public static int MovmentsNumber = 0;
        public static int MaxAStarGreedyHeuristicProgress = 0;
        public static bool EndOfGame = false;
        public bool SetRowColumnFinished = false;
        public static int MinThinkingTreeDepth = int.MaxValue;
        private static int MaxDuringLevelThinkingCreation = 0;
        public int MaxHeuristicxT = int.MinValue;
        public bool MovementsAStarGreedyHeuristicFoundT = false;
        public bool IgnoreSelfObjectsT = false;
        public bool UsePenaltyRegardMechnisamT = false;
        public bool BestMovmentsT = false;
        public bool PredictHeuristicT = true;
        public bool OnlySelfT = false;
        public bool AStarGreedyHeuristicT = false;
        public int[] Index = { -1, -1, -1, -1, -1, -1, -1 }, jindex = { -1, -1, -1, -1, -1, -1, -1 }, Kind = { -1, -1, -1, -1, -1, -1 };
        public bool ArrangmentsChanged = true;
        public static int AStarGreedytMaxCount = 0;
        public static bool FoundATable = false;
        public static double Less = double.MinValue;
        public bool CastlesKing = false;
        private readonly List<int[,]> MaxHeuristicAStarGreedytBackWardTable = new List<int[,]>();
        public static int increasedProgress = 0;
        public static int CurrentHeuristic = int.MinValue;
        public static int SignAttack = 1;
        public static int SignObjectDangour = 1;
        public static int SignReducedAttacked = -1;
        public static int SignSupport = 1;
        public static int SignKiller = 1;
        public static int SignMovments = 1;
        public static int SignDistance = -1;
        public static int SignKingSafe = -1;
        public static int SignKingDangour = -1;
        public static bool DrawTable = true;
        public static int[,] TableVeryfy = new int[8, 8];
        public static int MaxAStarGreedy = 0; // PlatformHelper.ProcessorCount;
        public static int[,] TableVeryfyConst = new int[8, 8];
        public static List<int[,]> TableCurrent = new List<int[,]>();
        public static bool NoTableFound = false;
        public static bool DynamicAStarGreedytPrograming = false;
        public static List<AllDraw> StoreADraw = new List<AllDraw>();
        public static List<int> StoreADrawAStarGreedy = new List<int>();
        public static bool UseDoubleTime = false;
        public static int AStarGreedyiLevelMax;
        public static bool AStarGreadyFirstSearch = true;
        public static string ImageRoot = AllDraw.Root + "\\Images";
        public static string ImagesSubRoot = AllDraw.ImageRoot + "\\Fit\\Small\\";
        public static bool RedrawTable = true;
        public static string SyntaxToWrite = "";
        public static bool SodierConversionOcuured = false;
        public static int SodierMovments = 1;
        public static int ElefantMovments = 1;
        public static int HourseMovments = 1;
        public static int CastleMovments = 1;
        public static int MinisterMovments = 1;
        public static int KingMovments = 1;

        public int SodierMidle = 0;
        public int SodierHigh = 0;
        public int ElefantMidle = 0;
        public int ElefantHigh = 0;
        public int HourseMidle = 0;
        public int HourseHight = 0;
        public int CastleMidle = 0;
        public int CastleHigh = 0;
        public int MinisterMidle = 0;
        public int MinisterHigh = 0;
        public int KingMidle = 0;
        public int KingHigh = 0;
        private int RW1 = 0;
        private int CL1 = 0;
        private int Ki1 = 0;
        private double MaxLess1 = 0;
        private int RW2 = 0;
        private int CL2 = 0;
        private int Ki2 = 0;
        private double MaxLess2 = 0;
        private int RW3 = 0;
        private int CL3 = 0;
        private int Ki3 = 0;
        private double MaxLess3 = 0;
        private int RW4 = 0;
        private int CL4 = 0;
        private int Ki4 = 0;
        private double MaxLess4 = 0;
        private int RW5 = 0;
        private int CL5 = 0;
        private int Ki5 = 0;
        private double MaxLess5 = 0;
        private int RW6 = 0;
        private int CL6 = 0;
        private int Ki6 = 0;
        private double MaxLess6 = 0;
        private int RW7 = 0;
        private int CL7 = 0;
        private double MaxLess7 = 0;
        public static int LoopHeuristicIndex = 0;
        public static List<int[,]> TableListAction = new List<int[,]>();
        public int Move = 0;
        public static int MouseClick = 0;
        public List<int[,]> TableList = new List<int[,]>();

        public DrawSoldierQ[] SolderesOnTable = new DrawSoldierQ[16];
        public DrawElefantQ[] ElephantOnTable = new DrawElefantQ[4];
        public DrawHourseQ[] HoursesOnTable = new DrawHourseQ[4];
        public DrawCastleQ[] CastlesOnTable = new DrawCastleQ[4];
        public DrawMinisterQ[] MinisterOnTable = new DrawMinisterQ[2];
        public DrawKingQ[] KingOnTable = new DrawKingQ[2];
        public DrawCastling[] CastlingOnTable = new DrawCastling[1];
        private readonly List<double[]> MaxHeuristicAStarGreedytBackWard = new List<double[]>();
        [NonSerialized()] public Task ob;

        //Making String datastructure to root variable
        public AllDraw AStarGreedyString = null;

        //Error Handling
        private static void Log(Exception ex)
        {
            try
            {
                object a = new object();
                lock (a)
                {
                    string stackTrace = ex.ToString();
                    //Write to File.
                    Helper.WaitOnUsed(AllDraw.Root + "\\ErrorProgramRun.txt"); File.AppendAllText(AllDraw.Root + "\\ErrorProgramRun.txt", stackTrace + ": On" + DateTime.Now.ToString());
                }
            }
            catch (Exception) { }
        }
        public AllDraw() { }

        //Determine and set numbers of all curent state table severasl kinds node.
        public void SetObjectNumbers(int[,] TabS)
        {
            object a = new object();
            lock (a)
            {
                //Initiate
                SodierMidle = 0;
                SodierHigh = 0;
                ElefantMidle = 0;
                ElefantHigh = 0;
                HourseMidle = 0;
                HourseHight = 0;
                CastleMidle = 0;
                CastleHigh = 0;
                MinisterMidle = 0;
                MinisterHigh = 0;
                KingMidle = 0;
                KingHigh = 0;
                for (int h = 0; h < 8; h++)
                {
                    for (int s = 0; s < 8; s++)
                    {
                        //Cal Solider Gray
                        if (TabS[h, s] == 1)
                        {
                            //Increase
                            SodierMidle++;
                            SodierHigh++;
                        }//Elephant Gray
                        else if (TabS[h, s] == 2)
                        {
                            //Increase
                            ElefantMidle++;
                            ElefantHigh++;
                        }
                        //Hoirse Gray
                        else if (TabS[h, s] == 3)
                        {
                            //Increase
                            HourseMidle++;
                            HourseHight++;
                        }
                        //Castle Gray
                        else if (TabS[h, s] == 4)
                        {
                            //Increase
                            CastleMidle++;
                            CastleHigh++;
                        }
                        //Minister Gray
                        else if (TabS[h, s] == 5)
                        {
                            //Increase
                            MinisterMidle++;
                            MinisterHigh++;
                        }
                        //King Gray
                        else if (TabS[h, s] == 6)
                        {
                            //Increase
                            KingMidle++;
                            KingHigh++;
                        }
                        else//Solder Brown
                            if (TabS[h, s] == -1)
                        {
                            //Increase
                            SodierHigh++;
                        }
                        else if (TabS[h, s] == -2)//Elepant Brown
                        {
                            //Increase
                            ElefantHigh++;
                        }
                        else if (TabS[h, s] == -3)//Hourse Brown
                        {
                            //Increase
                            HourseHight++;
                        }
                        else if (TabS[h, s] == -4)//Castle Brown
                        {
                            //Increase
                            CastleHigh++;
                        }
                        else if (TabS[h, s] == -5)//Mincter Brown
                        {
                            //Increase
                            MinisterHigh++;
                        }
                        else if (TabS[h, s] == -6)//King Brown
                        {
                            //Incrrease
                            KingHigh++;
                        }
                    }
                }
            }
        }

        public void Dispose()
        {
            Dispose(true);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
            }
        }

        //Constructor
        public AllDraw(int Order, bool MovementsAStarGreedyHeuristicTFou, bool IgnoreSelfObject, bool UsePenaltyRegardMechnisa, bool BestMovment, bool PredictHurist, bool OnlySel, bool AStarGreedyHuris, bool Arrangments)
        {
            object a = new object();
            lock (a)
            {
                MaxHeuristicxT = int.MinValue;
                MovementsAStarGreedyHeuristicFoundT = MovementsAStarGreedyHeuristicTFou;
                IgnoreSelfObjectsT = IgnoreSelfObject;
                UsePenaltyRegardMechnisamT = UsePenaltyRegardMechnisa;
                BestMovmentsT = BestMovment;
                PredictHeuristicT = PredictHurist;
                OnlySelfT = OnlySel;
                AStarGreedyHeuristicT = AStarGreedyHuris;
                ArrangmentsChanged = Arrangments;
                object Om = new object();
                lock (Om)
                {
                    FoundATable = false;
                }
                CastlesKing = false;
                increasedProgress = 0;
                object ol = new object();
                lock (ol)
                {
                    CurrentHeuristic = int.MinValue;
                    DrawTable = false;
                    TableVeryfy = new int[8, 8];
                    TableVeryfyConst = new int[8, 8];
                    TableCurrent.Clear();
                    NoTableFound = false;
                    DynamicAStarGreedytPrograming = false;
                    UseDoubleTime = false;
                    AStarGreadyFirstSearch = true;
                    ImageRoot = AllDraw.Root + "\\Images";
                    ImagesSubRoot = AllDraw.ImageRoot + "\\Fit\\Small\\";
                }
                RedrawTable = true;
                SodierConversionOcuured = false;
                SodierMovments = 1;
                ElefantMovments = 1;
                HourseMovments = 1;
                CastleMovments = 1;
                MinisterMovments = 1;
                KingMovments = 1;

                RW1 = 0;
                CL1 = 0;
                Ki1 = 0;
                MaxLess1 = 0;
                RW2 = 0;
                CL2 = 0;
                Ki2 = 0;
                MaxLess2 = 0;
                RW3 = 0;
                CL3 = 0;
                Ki3 = 0;
                MaxLess3 = 0;
                RW4 = 0;
                CL4 = 0;
                Ki4 = 0;
                MaxLess4 = 0;
                RW5 = 0;
                CL5 = 0;
                Ki5 = 0;
                MaxLess5 = 0;
                RW6 = 0;
                CL6 = 0;
                Ki6 = 0;
                MaxLess6 = 0;
                LoopHeuristicIndex = 0;
                Move = 0;

                SolderesOnTable = null;
                ElephantOnTable = null;
                HoursesOnTable = null;
                CastlesOnTable = null;
                MinisterOnTable = null;
                KingOnTable = null;
                CastlingOnTable = null;
                MaxHeuristicAStarGreedytBackWard.Clear();
                //Initiayte Locally Variables.
                TableList = new List<int[,]>();
                //APredict = new ChessPerdict(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged//, ref th

                OrderP = Order;
            }
        }

        //Clone Copy Method
        public void Clone(AllDraw AA)
        {
            object O = new object();
            lock (O)
            {
                if (AA == null)
                {
                    AA = new AllDraw(OrderP, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    AA.TableList.Add(CloneATable(TableList[0]));
                }
                AA.Tabl = new int[8, 8];
                for (int i = 0; i < 8; i++)
                {
                    for (int j = 0; j < 8; j++)
                    {
                        AA.Tabl[i, j] = Tabl[i, j];
                    }
                }

                AA.OrderP = OrderP;
                AA.PerceptionCount = PerceptionCount;
                AA.OutPutAction = OutPutAction;
                //static variable to be Initiate

                AA.CurrentAStarGredyMax = CurrentAStarGredyMax;
                for (int i = 0; i < 6; i++)
                {
                    AA.Index[i] = Index[i];
                }

                for (int i = 0; i < 6; i++)
                {
                    AA.jindex[i] = jindex[i];
                }

                for (int i = 0; i < 6; i++)
                {
                    AA.Kind[i] = Kind[i];
                }

                if (AStarGreedyString != null)
                {
                    AStarGreedyString.Clone(AA.AStarGreedyString);
                }

                if (TableList.Count == 1)
                {
                    SetObjectNumbers(TableList[0]);
                }

                MaxHeuristicxT = int.MinValue;
                AA.MovementsAStarGreedyHeuristicFoundT = MovementsAStarGreedyHeuristicFoundT;
                AA.IgnoreSelfObjectsT = IgnoreSelfObjectsT;
                AA.UsePenaltyRegardMechnisamT = UsePenaltyRegardMechnisamT;
                AA.BestMovmentsT = BestMovmentsT;
                AA.PredictHeuristicT = PredictHeuristicT;
                AA.OnlySelfT = OnlySelfT;
                AA.AStarGreedyHeuristicT = AStarGreedyHeuristicT;
                AA.ArrangmentsChanged = ArrangmentsChanged;
                AA.CastlesKing = CastlesKing;

                AA.SodierMidle = SodierMidle;
                AA.SodierHigh = SodierHigh;
                AA.ElefantMidle = ElefantMidle;
                AA.ElefantHigh = ElefantHigh;
                AA.HourseMidle = HourseMidle;
                AA.HourseHight = HourseHight;
                AA.CastleMidle = CastleMidle;
                AA.CastleHigh = CastleHigh;
                AA.MinisterMidle = MinisterMidle;
                AA.MinisterHigh = MinisterHigh;
                AA.KingMidle = KingMidle;
                AA.KingHigh = KingHigh;
                //Initiate a new class object and clone a copy.
                AA.SolderesOnTable = new DrawSoldierQ[SodierHigh];
                AA.ArrangmentsChanged = ArrangmentsChanged;
                for (int i = 0; i < SodierHigh; i++)
                {
                    SolderesOnTable[i].Clone(ref AA.SolderesOnTable[i]);
                }
                AA.ElephantOnTable = new DrawElefantQ[ElefantHigh];
                for (int i = 0; i < ElefantHigh; i++)
                {
                    ElephantOnTable[i].Clone(ref AA.ElephantOnTable[i]);
                }
                AA.HoursesOnTable = new DrawHourseQ[HourseHight];
                for (int i = 0; i < HourseHight; i++)
                {
                    HoursesOnTable[i].Clone(ref AA.HoursesOnTable[i]);
                }
                AA.CastlesOnTable = new DrawCastleQ[CastleHigh];
                for (int i = 0; i < CastleHigh; i++)
                {
                    CastlesOnTable[i].Clone(ref AA.CastlesOnTable[i]);
                }
                AA.MinisterOnTable = new DrawMinisterQ[MinisterHigh];
                for (int i = 0; i < MinisterHigh; i++)
                {
                    MinisterOnTable[i].Clone(ref AA.MinisterOnTable[i]);
                }
                AA.KingOnTable = new DrawKingQ[KingHigh];
                for (int i = 0; i < KingHigh; i++)
                {
                    KingOnTable[i].Clone(ref AA.KingOnTable[i]);
                }
                AA.CastlingOnTable = new DrawCastling[1];
                for (int i = 0; i < 1; i++)
                {
                    CastlingOnTable[i].Clone(ref AA.CastlingOnTable[i]);
                }

                if (AA.TableList.Count > 0)
                {
                    AA.TableList.Clear();
                }

                for (int i = 0; i < TableList.Count; i++)
                {
                    AA.TableList.Add(CloneATable(TableList[i]));
                }

                if (AA.TableList.Count > 0)
                {
                    AA.SetObjectNumbers(AA.TableList[0]);
                }
            }
        }

        //Rearrange AllDraw Object Content.
        public void SetRowColumn(int index, bool Verify = false)
        {
            SolderesOnTableMove.Clear();
            ElephantOnTableMove.Clear();
            HoursesOnTableMove.Clear();
            CastlesOnTableMove.Clear();
            MinisterOnTableMove.Clear();
            KingOnTableMove.Clear();
            CastlingOnTableMove.Clear();

            if (Verify)
            {
                if (SetRowColumn())
                {
                    return;
                }

                int Dummy = OrderP;
                object a1 = new object();
                lock (a1)
                {
                    SetObjectNumbers(TableList[0]);
                    int So1 = 0;
                    int So2 = SodierMidle;
                    for (int i = 0; i < SodierHigh; i++)
                    {
                        SolderesOnTableMove.Add(false);
                    }

                    int El1 = 0;
                    int El2 = ElefantMidle;
                    for (int i = 0; i < ElefantHigh; i++)
                    {
                        ElephantOnTableMove.Add(false);
                    }

                    int Ho1 = 0;
                    int Ho2 = HourseMidle;
                    for (int i = 0; i < HourseHight; i++)
                    {
                        HoursesOnTableMove.Add(false);
                    }

                    int Br1 = 0;
                    int Br2 = CastleMidle;
                    for (int i = 0; i < CastleHigh; i++)
                    {
                        CastlesOnTableMove.Add(false);
                    }

                    int Mi1 = 0;
                    int Mi2 = MinisterMidle;
                    for (int i = 0; i < MinisterHigh; i++)
                    {
                        MinisterOnTableMove.Add(false);
                    }

                    int Ki1 = 0;
                    int Ki2 = KingMidle;
                    for (int i = 0; i < KingHigh; i++)
                    {
                        KingOnTableMove.Add(false);
                    }

                    for (int i = 0; i < 1; i++)
                    {
                        CastlingOnTableMove.Add(false);
                    }

                    SetRowColumnFinished = false;
                    Move = 0;
                    //Intiate Dummy Variables.
                    //When Conversion Occured.
                    //When Table Exist.
                    if (TableList.Count > 0)
                    {
                        //For Every Table Things.
                        for (int Column = 0; Column < 8; Column++)
                        {
                            for (int Row = 0; Row < 8; Row++)
                            {
                                if (CloneATable(TableList[index])[Row, Column] == 0)
                                {
                                    continue;
                                }
                                //When Things are Soldiers.
                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 1)
                                {
                                    //Determine int
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //When int is Gray.
                                    if (a == Color.Gray)
                                    {
                                        //Construct Soder Gray.
                                        SolderesOnTable[So1].Row = Row;
                                        SolderesOnTable[So1].Column = Column;
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(So1, OrderP, 1));
                                        ah.Wait();
                                        ah.Dispose();
                                        //Increase So1.
                                        So1++;
                                        if (So1 > SodierMidle)
                                        {
                                            SodierMidle++;
                                            SodierHigh++;
                                        }
                                    }
                                    //When int is Brown
                                    else
                                    {
                                        //Construct Soldeir Brown.
                                        SolderesOnTable[So2].Row = Row;
                                        SolderesOnTable[So2].Column = Column;
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(So2, OrderP, 1));
                                        ah.Wait();
                                        ah.Dispose();
                                        //Increase So2.
                                        So2++;
                                        if (So2 > SodierHigh)
                                        {
                                            SodierHigh++;
                                        }
                                    }
                                }
                                else //For Elephant Objects.
                                    if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 2)
                                {
                                    //Initiate Local Variables.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }    //If Gray Elepahnt
                                    if (a == Color.Gray)
                                    {
                                        //Construction of Draw Object.
                                        ElephantOnTable[El1].Row = Row;
                                        ElephantOnTable[El1].Column = Column;
                                        //satisfied of created deeper three
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(El1, OrderP, 2));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Gray Index.
                                        El1++;
                                        //If New Object Increament Gray Objects.
                                        if (El1 > ElefantMidle)
                                        {
                                            ElefantMidle++;
                                            ElefantHigh++;
                                        }
                                    }
                                    else//For Brown Elephant .Objects
                                    {
                                        //Construction of Draw Brown Elephant Object.
                                        ElephantOnTable[El2].Row = Row;
                                        ElephantOnTable[El2].Column = Column;
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(El2, OrderP, 2);
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(El2, OrderP, 2));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        El2++;
                                        //When New Brown Elephant Object Increament of Index.
                                        if (El2 > ElefantHigh)
                                        {
                                            ElefantHigh++;
                                        }
                                    }
                                }
                                else//For Hourse Objects.
                                        if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 3)
                                {
                                    //Initiate Local Varibale and int.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }                //If Gray Hourse.
                                    if (a == Color.Gray)
                                    {
                                        //Construction of Draw Brown Hourse.
                                        HoursesOnTable[Ho1].Row = Row;
                                        HoursesOnTable[Ho1].Column = Column;
                                        //satisfied of created deeper three
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Ho1, OrderP, 3));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Ho1++;
                                        //when There is New Gray Hourse Increase.
                                        if (Ho1 > HourseMidle)
                                        {
                                            HourseMidle++;
                                            HourseHight++;
                                        }
                                    }//For Brown Hourses.
                                    else
                                    {
                                        //Construction of Draw Brown Hourse.
                                        HoursesOnTable[Ho2].Row = Row;
                                        HoursesOnTable[Ho2].Column = Column;
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Ho2, OrderP, 3));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Ho2++;
                                        //When New Brown Hourse Exist Exist Index.
                                        if (Ho2 > HourseHight)
                                        {
                                            HourseHight++;
                                        }
                                    }
                                }
                                else//For Castles Objects.
                                            if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 4)
                                {
                                    //Initiate of Local Variables.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }         //For Gray int.
                                    if (a == Color.Gray)
                                    {
                                        //Construction of New Draw Gray Castles.
                                        CastlesOnTable[Br1].Row = Row;
                                        CastlesOnTable[Br1].Column = Column;
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Br1, OrderP, 4));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increamnt of Index.
                                        Br1++;
                                        //When New Gray Briges Increamnt Max Index.
                                        if (Br1 > CastleMidle)
                                        {
                                            CastleMidle++;
                                            CastleHigh++;
                                        }
                                    }//For Brown Castles.
                                    else
                                    {
                                        //Construction Draw of New Brown Castles.
                                        CastlesOnTable[Br2].Row = Row;
                                        CastlesOnTable[Br2].Column = Column;
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Br2, OrderP, 4));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Br2++;
                                        //wehn Brown New Castles Detected Increament Max Index.
                                        if (Br2 > CastleHigh)
                                        {
                                            CastleHigh++;
                                        }
                                    }
                                }
                                else//For Minister Objects.
                                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 5)
                                {
                                    //Initiate Local int Varibales.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //For Gray ints.
                                    if (a == Color.Gray)
                                    {
                                        //construction of new draw Gray Minster.
                                        MinisterOnTable[Mi1].Row = Row;
                                        MinisterOnTable[Mi1].Column = Column;
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Mi1, OrderP, 5));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Mi1++;
                                        //Wehn New Gray Minster Detected Increament Max Indexes.
                                        if (Mi1 > MinisterMidle)
                                        {
                                            MinisterMidle++;
                                            MinisterHigh++;
                                        }
                                    }//For Brown  ints.
                                    else
                                    {
                                        //Construction of New Draw Brown Minster.
                                        MinisterOnTable[Mi2].Row = Row;
                                        MinisterOnTable[Mi2].Column = Column;
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Mi2, OrderP, 5));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament Index.
                                        Mi2++;
                                        //When New Brown Minister Detected Increament Max Index.
                                        if (Mi2 > MinisterHigh)
                                        {
                                            MinisterHigh++;
                                        }
                                    }
                                }
                                else//for King Objects.
                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 6)
                                {
                                    //Initiate Of int.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //int consideration.
                                    if (a == Color.Gray)
                                    {
                                        //Construction of New Draw Gray King.
                                        KingOnTable[Ki1].Row = Row;
                                        KingOnTable[Ki1].Column = Column;
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Ki1, OrderP, 6));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Ki1++;
                                        //when New Draw  Object Detected Increament Max Index.
                                        if (Ki1 > KingMidle)
                                        {
                                            KingMidle++;
                                            KingHigh++;
                                        }
                                    }//For Brown King int
                                    else
                                    {
                                        //Construction of New Draw King Brown Object.
                                        KingOnTable[Ki2].Row = Row;
                                        KingOnTable[Ki2].Column = Column;
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Ki2, OrderP, 6));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Ki2++;
                                        //When New Object Detected Increament Of Brown King Max Index.
                                        if (Ki2 > KingHigh)
                                        {
                                            KingHigh++;
                                        }
                                    }
                                }
                            }
                        }
                        //Make Empty Remaining.
                    }
                    //Part Three For white castling
                    if (Dummy == 1)
                    {
                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(0, Dummy, 7));
                        ah.Wait();
                        ah.Dispose();
                    }
                    //Part Three for black castling
                    else
                    {
                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(0, Dummy, -7));
                        ah.Wait();
                        ah.Dispose();
                    }
                    //Object number reconstruction
                    SetObjectNumbers(TableList[0]);
                    //setting insufficet empty
                    for (int i = So1; i < SodierMidle; i++)
                    {
                        SolderesOnTable[i] = null;
                    }

                    for (int i = So2; i < SodierHigh; i++)
                    {
                        SolderesOnTable[i] = null;
                    }

                    for (int i = El1; i < ElefantMidle; i++)
                    {
                        ElephantOnTable[i] = null;
                    }

                    for (int i = El2; i < ElefantHigh; i++)
                    {
                        ElephantOnTable[i] = null;
                    }

                    for (int i = Ho1; i < HourseMidle; i++)
                    {
                        HoursesOnTable[i] = null;
                    }

                    for (int i = Ho2; i < HourseHight; i++)
                    {
                        HoursesOnTable[i] = null;
                    }

                    for (int i = Br1; i < CastleMidle; i++)
                    {
                        CastlesOnTable[i] = null;
                    }

                    for (int i = Br2; i < CastleHigh; i++)
                    {
                        CastlesOnTable[i] = null;
                    }

                    for (int i = Mi1; i < MinisterMidle; i++)
                    {
                        MinisterOnTable[i] = null;
                    }

                    for (int i = Mi2; i < MinisterHigh; i++)
                    {
                        MinisterOnTable[i] = null;
                    }

                    for (int i = Ki1; i < KingMidle; i++)
                    {
                        KingOnTable[i] = null;
                    }

                    for (int i = Ki2; i < KingHigh; i++)
                    {
                        KingOnTable[i] = null;
                    }

                    if (TableList.Count > 0)
                    {
                        for (int i = 0; i < 8; i++)
                        {
                            for (int j = 0; j < 8; j++)
                            {
                                Tabl[i, j] = TableList[0][i, j];
                            }
                        }
                    }
                    //Semaphore for concurrency
                    SetRowColumnFinished = true;
                }

                OrderP = Dummy;
            }
            else
            {
                int Dummy = OrderP;
                object a1 = new object();
                lock (a1)
                {
                    //Object number reconstruction
                    SetObjectNumbers(TableList[0]);
                    int So1 = 0;
                    int So2 = SodierMidle;
                    //setting opeatinall semaphore
                    for (int i = 0; i < SodierHigh; i++)
                    {
                        SolderesOnTableMove.Add(false);
                    }

                    int El1 = 0;
                    int El2 = ElefantMidle;
                    for (int i = 0; i < ElefantHigh; i++)
                    {
                        ElephantOnTableMove.Add(false);
                    }

                    int Ho1 = 0;
                    int Ho2 = HourseMidle;
                    for (int i = 0; i < HourseHight; i++)
                    {
                        HoursesOnTableMove.Add(false);
                    }

                    int Br1 = 0;
                    int Br2 = CastleMidle;
                    for (int i = 0; i < CastleHigh; i++)
                    {
                        CastlesOnTableMove.Add(false);
                    }

                    int Mi1 = 0;
                    int Mi2 = MinisterMidle;
                    for (int i = 0; i < MinisterHigh; i++)
                    {
                        MinisterOnTableMove.Add(false);
                    }

                    int Ki1 = 0;
                    int Ki2 = KingMidle;
                    for (int i = 0; i < KingHigh; i++)
                    {
                        KingOnTableMove.Add(false);
                    }

                    for (int i = 0; i < 1; i++)
                    {
                        CastlingOnTableMove.Add(false);
                    }

                    SetRowColumnFinished = false;
                    Move = 0;
                    //Intiate Dummy Variables.
                    //When Conversion Occured.

                    SolderesOnTable = new DrawSoldierQ[SodierHigh];
                    ElephantOnTable = new DrawElefantQ[ElefantHigh];
                    HoursesOnTable = new DrawHourseQ[HourseHight];
                    CastlesOnTable = new DrawCastleQ[CastleHigh];
                    MinisterOnTable = new DrawMinisterQ[MinisterHigh];
                    KingOnTable = new DrawKingQ[KingHigh];
                    CastlingOnTable = new DrawCastling[1];
                    AllDraw.SodierConversionOcuured = false;
                    //When Table Exist.
                    if (TableList.Count > 0)
                    {
                        //For Every Table Things.
                        for (int Column = 0; Column < 8; Column++)
                        {
                            for (int Row = 0; Row < 8; Row++)
                            {
                                if (CloneATable(TableList[index])[Row, Column] == 0)
                                {
                                    continue;
                                }
                                //When Things are Soldiers.
                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 1)
                                {
                                    //Determine int
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //When int is Gray.
                                    if (a == Color.Gray)
                                    {
                                        //Construct Soder Gray.
                                        SolderesOnTable[So1] = new DrawSoldierQ(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, So1);
                                        //satisfied of created deeper three
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(So1, OrderP, 1));
                                        ah.Wait();
                                        ah.Dispose();
                                        //Increase So1.
                                        So1++;
                                        if (So1 > SodierMidle)
                                        {
                                            SodierMidle++;
                                            SodierHigh++;
                                        }
                                    }
                                    //When int is Brown
                                    else
                                    {
                                        //Construct Soldeir Brown.
                                        SolderesOnTable[So2] = new DrawSoldierQ(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, So2);
                                        //satisfied of created deeper three
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(So2, OrderP, 1));
                                        ah.Wait();
                                        ah.Dispose();
                                        //Increase So2.
                                        So2++;
                                        if (So2 > SodierHigh)
                                        {
                                            SodierHigh++;
                                        }
                                    }
                                }
                                else //For Elephant Objects.
                                    if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 2)
                                {
                                    //Initiate Local Variables.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }    //If Gray Elepahnt
                                    if (a == Color.Gray)
                                    {
                                        //Construction of Draw Object.
                                        ElephantOnTable[El1] = new DrawElefantQ(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, El1);
                                        //satisfied of created deeper three
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(El1, OrderP, 2));
                                        ah.Wait();
                                        ah.Dispose();
                                        //Increament of Gray Index.
                                        El1++;
                                        //If New Object Increament Gray Objects.
                                        if (El1 > ElefantMidle)
                                        {
                                            ElefantMidle++;
                                            ElefantHigh++;
                                        }
                                    }
                                    else//For Brown Elephant .Objects
                                    {
                                        //Construction of Draw Brown Elephant Object.
                                        ElephantOnTable[El2] = new DrawElefantQ(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, El2);
                                        //satisfied of created deeper three
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(El2, OrderP, 2));
                                        ah.Wait();
                                        ah.Dispose();
                                        //Increament of Index.
                                        El2++;
                                        //When New Brown Elephant Object Increament of Index.
                                        if (El2 > ElefantHigh)
                                        {
                                            ElefantHigh++;
                                        }
                                    }
                                }
                                else//For Hourse Objects.
                                        if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 3)
                                {
                                    //Initiate Local Varibale and int.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }                //If Gray Hourse.
                                    if (a == Color.Gray)
                                    {
                                        //Construction of Draw Brown Hourse.
                                        HoursesOnTable[Ho1] = new DrawHourseQ(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, Ho1);
                                        //satisfied of created deeper three
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Ho1, OrderP, 3));
                                        ah.Wait();
                                        ah.Dispose();
                                        //Increament of Index.
                                        Ho1++;
                                        //when There is New Gray Hourse Increase.
                                        if (Ho1 > HourseMidle)
                                        {
                                            HourseMidle++;
                                            HourseHight++;
                                        }
                                    }//For Brown Hourses.
                                    else
                                    {
                                        //Construction of Draw Brown Hourse.
                                        HoursesOnTable[Ho2] = new DrawHourseQ(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, Ho2);
                                        //satisfied of created deeper three
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Ho2, OrderP, 3));
                                        ah.Wait();
                                        ah.Dispose();
                                        //Increament of Index.
                                        Ho2++;
                                        //When New Brown Hourse Exist Exist Index.
                                        if (Ho2 > HourseHight)
                                        {
                                            HourseHight++;
                                        }
                                    }
                                }
                                else//For Castles Objects.
                                            if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 4)
                                {
                                    //Initiate of Local Variables.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }         //For Gray int.
                                    if (a == Color.Gray)
                                    {
                                        //Construction of New Draw Gray Castles.
                                        CastlesOnTable[Br1] = new DrawCastleQ(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, Br1);
                                        //satisfied of created deeper three
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Br1, OrderP, 4));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increamnt of Index.
                                        Br1++;
                                        //When New Gray Briges Increamnt Max Index.
                                        if (Br1 > CastleMidle)
                                        {
                                            CastleMidle++;
                                            CastleHigh++;
                                        }
                                    }//For Brown Castles.
                                    else
                                    {
                                        //Construction Draw of New Brown Castles.
                                        CastlesOnTable[Br2] = new DrawCastleQ(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, Br2);
                                        //satisfied of created deeper three
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Br2, OrderP, 4));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Br2++;
                                        //wehn Brown New Castles Detected Increament Max Index.
                                        if (Br2 > CastleHigh)
                                        {
                                            CastleHigh++;
                                        }
                                    }
                                }
                                else//For Minister Objects.
                                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 5)
                                {
                                    //Initiate Local int Varibales.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //For Gray ints.
                                    if (a == Color.Gray)
                                    {
                                        //construction of new draw Gray Minster.
                                        MinisterOnTable[Mi1] = new DrawMinisterQ(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, Mi1);
                                        //satisfied of created deeper three
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Mi1, OrderP, 5));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Mi1++;
                                        //Wehn New Gray Minster Detected Increament Max Indexes.
                                        if (Mi1 > MinisterMidle)
                                        {
                                            MinisterMidle++;
                                            MinisterHigh++;
                                        }
                                    }//For Brown  ints.
                                    else
                                    {
                                        //Construction of New Draw Brown Minster.
                                        MinisterOnTable[Mi2] = new DrawMinisterQ(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, Mi2);
                                        //satisfied of created deeper three
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Mi2, OrderP, 5));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament Index.
                                        Mi2++;
                                        //When New Brown Minister Detected Increament Max Index.
                                        if (Mi2 > MinisterHigh)
                                        {
                                            MinisterHigh++;
                                        }
                                    }
                                }
                                else//for King Objects.
                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 6)
                                {
                                    //Initiate Of int.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //int consideration.
                                    if (a == Color.Gray)
                                    {
                                        //Construction of New Draw Gray King.
                                        KingOnTable[Ki1] = new DrawKingQ(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, Ki1);
                                        //satisfied of created deeper three
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Ki1, OrderP, 6));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Ki1++;
                                        //when New Draw  Object Detected Increament Max Index.
                                        if (Ki1 > KingMidle)
                                        {
                                            KingMidle++;
                                            KingHigh++;
                                        }
                                    }//For Brown King int
                                    else
                                    {
                                        //Construction of New Draw King Brown Object.
                                        KingOnTable[Ki2] = new DrawKingQ(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, Ki2);
                                        //satisfied of created deeper three
                                        Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Ki2, OrderP, 6));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Ki2++;
                                        //When New Object Detected Increament Of Brown King Max Index.
                                        if (Ki2 > KingHigh)
                                        {
                                            KingHigh++;
                                        }
                                    }
                                }
                            }
                        }
                        //Make Empty Remaining.
                    }
                    //Spesial castling condition operation
                    if (CastlingBoundryCondition())
                    {
                        if (Dummy == 1)
                        {
                            //act for white castling
                            CastlingOnTable[0] = new DrawCastling(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, KingOnTable[0].Row, KingOnTable[0].Column, Color.Gray, CloneATable(TableList[index]), 1, false, 0);

                            Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(0, Dummy, 7));
                            ah.Wait();
                            ah.Dispose();
                        }
                        else
                        {
                            //act for black castling
                            CastlingOnTable[0] = new DrawCastling(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, KingOnTable[1].Row, KingOnTable[1].Column, Color.Brown, CloneATable(TableList[index]), -1, false, 0);

                            Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(0, Dummy, -7));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                    //Object number castling
                    SetObjectNumbers(TableList[0]);
                    //setting emty reunusable to empty
                    for (int i = So1; i < SodierMidle; i++)
                    {
                        SolderesOnTable[i] = null;
                    }

                    for (int i = So2; i < SodierHigh; i++)
                    {
                        SolderesOnTable[i] = null;
                    }

                    for (int i = El1; i < ElefantMidle; i++)
                    {
                        ElephantOnTable[i] = null;
                    }

                    for (int i = El2; i < ElefantHigh; i++)
                    {
                        ElephantOnTable[i] = null;
                    }

                    for (int i = Ho1; i < HourseMidle; i++)
                    {
                        HoursesOnTable[i] = null;
                    }

                    for (int i = Ho2; i < HourseHight; i++)
                    {
                        HoursesOnTable[i] = null;
                    }

                    for (int i = Br1; i < CastleMidle; i++)
                    {
                        CastlesOnTable[i] = null;
                    }

                    for (int i = Br2; i < CastleHigh; i++)
                    {
                        CastlesOnTable[i] = null;
                    }

                    for (int i = Mi1; i < MinisterMidle; i++)
                    {
                        MinisterOnTable[i] = null;
                    }

                    for (int i = Mi2; i < MinisterHigh; i++)
                    {
                        MinisterOnTable[i] = null;
                    }

                    for (int i = Ki1; i < KingMidle; i++)
                    {
                        KingOnTable[i] = null;
                    }

                    for (int i = Ki2; i < KingHigh; i++)
                    {
                        KingOnTable[i] = null;
                    }
                    //copy
                    if (TableList.Count > 0)
                    {
                        for (int i = 0; i < 8; i++)
                        {
                            for (int j = 0; j < 8; j++)
                            {
                                Tabl[i, j] = TableList[0][i, j];
                            }
                        }
                    }
                    SetRowColumnFinished = true;
                }

                OrderP = Dummy;
                //Reconstruction of object number
                SetObjectNumbers(Tabl);
            }
        }

        private bool CastlingBoundryCondition()
        {
            if (CastlingOnTable == null)
            {
                return true;
            }

            if (CastlingOnTable[0] == null)
            {
                return true;
            }
            // if (CastlingOnTable[0].CastlingThinking == null)
            //     return true;
            //if (CastlingOnTable[0].CastlingThinking[0] == null)
            //  return true;
            //if (CastlingOnTable[0].CastlingThinking[0].AStarGreedy == null)
            //    return true;
            //if (CastlingOnTable[0].CastlingThinking[0].AStarGreedy.Count==0)
            //  return true;

            return false;
        }

        public bool SetRowColumn()
        {
            int Dummy = OrderP;

            object a1 = new object();
            lock (a1)
            {
                SetObjectNumbers(TableList[0]);
                int So1 = 0;
                int So2 = SodierMidle;
                int El1 = 0;
                int El2 = ElefantMidle;
                int Ho1 = 0;
                int Ho2 = HourseMidle;
                int Br1 = 0;
                int Br2 = CastleMidle;
                int Mi1 = 0;
                int Mi2 = MinisterMidle;
                int Ki1 = 0;
                int Ki2 = KingMidle;

                SetRowColumnFinished = false;
                Move = 0;
                //When Table Exist.
                if (TableList.Count > 0)
                {
                    //For Every Table Things.
                    for (int Column = 0; Column < 8; Column++)
                    {
                        for (int Row = 0; Row < 8; Row++)
                        {
                            if (CloneATable(TableList[0])[Row, Column] == 0)
                            {
                                continue;
                            }
                            //When Things are Soldiers.
                            if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 1)
                            {
                                //Determine int
                                Color a;
                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }     //When int is Gray.
                                if (a == Color.Gray)
                                {
                                    if (TableList[0][(int)SolderesOnTable[So1].Row, (int)SolderesOnTable[So1].Column] != 1)
                                    {
                                        return false;
                                    }
                                    //IncreASe So1.
                                    So1++;
                                    if (So1 > SodierMidle)
                                    {
                                        SodierMidle++;
                                        SodierHigh++;
                                    }
                                }
                                //When int is Brown
                                else
                                {
                                    if (TableList[0][(int)SolderesOnTable[So2].Row, (int)SolderesOnTable[So2].Column] != -1)
                                    {
                                        return false;
                                    }
                                    //IncreASe So2.
                                    So2++;
                                    if (So2 > SodierHigh)
                                    {
                                        SodierHigh++;
                                    }
                                }
                            }
                            else //For Elephant Objects.
                                if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 2)
                            {
                                //Initiate Local Variables.
                                Color a;
                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }    //If Gray Elepahnt
                                if (a == Color.Gray)
                                {
                                    if (TableList[0][(int)ElephantOnTable[El1].Row, (int)ElephantOnTable[El1].Column] != 2)
                                    {
                                        return false;
                                    }
                                    //Increament of Gray 0.
                                    El1++;
                                    //If New Object Increament Gray Objects.
                                    if (El1 > ElefantMidle)
                                    {
                                        ElefantMidle++;
                                        ElefantHigh++;
                                    }
                                }
                                else//For Brown Elephant .Objects
                                {
                                    if (TableList[0][(int)ElephantOnTable[El2].Row, (int)ElephantOnTable[El2].Column] != -2)
                                    {
                                        return false;
                                    }
                                    //Increament of 0.
                                    El2++;
                                    //When New Brown Elephant Object Increament of 0.
                                    if (El2 > ElefantHigh)
                                    {
                                        ElefantHigh++;
                                    }
                                }
                            }
                            else//For Hourse Objects.
                                    if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 3)
                            {
                                //Initiate Local Varibale and int.
                                Color a;
                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }                //If Gray Hourse.
                                if (a == Color.Gray)
                                {
                                    if (TableList[0][(int)HoursesOnTable[Ho1].Row, (int)HoursesOnTable[Ho1].Column] != 3)
                                    {
                                        return false;
                                    }
                                    //Increament of 0.
                                    Ho1++;
                                    //when There is New Gray Hourse IncreASe.
                                    if (Ho1 > HourseMidle)
                                    {
                                        HourseMidle++;
                                        HourseHight++;
                                    }
                                }//For Brown Hourses.
                                else
                                {
                                    if (TableList[0][(int)HoursesOnTable[Ho2].Row, (int)HoursesOnTable[Ho2].Column] != -3)
                                    {
                                        return false;
                                    }
                                    //Increament of 0.
                                    Ho2++;
                                    //When New Brown Hourse Exist Exist 0.
                                    if (Ho2 > HourseHight)
                                    {
                                        HourseHight++;
                                    }
                                }
                            }
                            else//For Castles Objects.
                                        if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 4)
                            {
                                //Initiate of Local Variables.
                                Color a;
                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }         //For Gray int.
                                if (a == Color.Gray)
                                {
                                    if (TableList[0][(int)CastlesOnTable[Br1].Row, (int)CastlesOnTable[Br1].Column] != 4)
                                    {
                                        return false;
                                    }
                                    //Increamnt of 0.
                                    Br1++;
                                    //When New Gray Briges Increamnt Max 0.
                                    if (Br1 > CastleMidle)
                                    {
                                        CastleMidle++;
                                        CastleHigh++;
                                    }
                                }//For Brown Castles.
                                else
                                {
                                    if (TableList[0][(int)CastlesOnTable[Br2].Row, (int)CastlesOnTable[Br2].Column] != -4)
                                    {
                                        return false;
                                    }
                                    //Increament of 0.
                                    Br2++;
                                    //wehn Brown New Castles Detected Increament Max 0.
                                    if (Br2 > CastleHigh)
                                    {
                                        CastleHigh++;
                                    }
                                }
                            }
                            else//For Minister Objects.
                                            if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 5)
                            {
                                //Initiate Local int Varibales.
                                Color a;
                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }     //For Gray ints.
                                if (a == Color.Gray)
                                {
                                    if (TableList[0][(int)MinisterOnTable[Mi1].Row, (int)MinisterOnTable[Mi1].Column] != 5)
                                    {
                                        return false;
                                    }
                                    //Increament of 0.
                                    Mi1++;
                                    //Wehn New Gray Minster Detected Increament Max 0es.
                                    if (Mi1 > MinisterMidle)
                                    {
                                        MinisterMidle++;
                                        MinisterHigh++;
                                    }
                                }//For Brown  ints.
                                else
                                {
                                    if (TableList[0][(int)MinisterOnTable[Mi2].Row, (int)MinisterOnTable[Mi2].Column] != -5)
                                    {
                                        return false;
                                    }
                                    //Increament 0.
                                    Mi2++;
                                    //When New Brown Minister Detected Increament Max 0.
                                    if (Mi2 > MinisterHigh)
                                    {
                                        MinisterHigh++;
                                    }
                                }
                            }
                            else//for King Objects.
                            if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 6)
                            {
                                //Initiate Of int.
                                Color a;
                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }     //int consideration.
                                if (a == Color.Gray)
                                {
                                    if (TableList[0][(int)KingOnTable[Ki1].Row, (int)KingOnTable[Ki1].Column] != 6)
                                    {
                                        return false;
                                    }
                                    //Increament of 0.
                                    Ki1++;
                                    //when New Draw  Object Detected Increament Max 0.
                                    if (Ki1 > KingMidle)
                                    {
                                        KingMidle++;
                                        KingHigh++;
                                    }
                                }//For Brown King int
                                else
                                {
                                    if (TableList[0][(int)KingOnTable[Ki2].Row, (int)KingOnTable[Ki2].Column] != -6)
                                    {
                                        return false;
                                    }
                                    //Increament of 0.
                                    Ki2++;
                                    //When New Object Detected Increament Of Brown King Max 0.
                                    if (Ki2 > KingHigh)
                                    {
                                        KingHigh++;
                                    }
                                }
                            }
                        }
                    }
                    //Make Empty Remaining.
                }
                //object number counting
                SetObjectNumbers(TableList[0]);
                //setting null
                for (int i = Ki2; i < KingHigh; i++)
                {
                    KingOnTable[i] = null;
                }
                //copy
                if (TableList.Count > 0)
                {
                    for (int i = 0; i < 8; i++)
                    {
                        for (int j = 0; j < 8; j++)
                        {
                            Tabl[i, j] = TableList[0][i, j];
                        }
                    }
                }
                SetRowColumnFinished = true;
            }

            OrderP = Dummy;
            return true;
        }

        //Max Index List Of Heuristic AStarGreedy First Method.
        public void BeginIndexFoundingMaxLessofMaxList(int ListIndex, List<int> Founded, ref double LessB)
        {
            object a = new object();
            lock (a)
            {
                //When There is Maximum Huristsic AStar Gredy Back Ward in Blitz Games.
                if (MaxHeuristicAStarGreedytBackWard.Count > 0)
                {
                    //When List Index is LessB than Founded.
                    if (ListIndex < MaxHeuristicAStarGreedytBackWard.Count)
                    {
                        return;
                    }
                    //Initiate Variable.
                    bool Added = false;
                    //Recursive Method.
                    double Le = LessB;
                    Task ah = Task.Factory.StartNew(() => BeginIndexFoundingMaxLessofMaxList(ListIndex++, Founded, ref Le));
                    ah.Wait();
                    ah.Dispose();
                    LessB = Le;

                    //When Greater LessB of First index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][1])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][1];
                        Added = true;
                        Founded.Add(2);
                    }
                    //When Greater LessB of Second index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][5])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][5];
                        if (Added)
                        {
                            Founded.RemoveAt(Founded.Count - 1);
                        }

                        Added = true;
                        Founded.Add(6);
                    }
                    //When Greater LessB of Third index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][9])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][9];
                        if (Added)
                        {
                            Founded.RemoveAt(Founded.Count - 1);
                        }

                        Added = true;
                        Founded.Add(10);
                    }
                    //When Greater LessB of Foutrh index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][13])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][13];
                        if (Added)
                        {
                            Founded.RemoveAt(Founded.Count - 1);
                        }

                        Added = true;
                        Founded.Add(14);
                    }
                    //When Greater LessB of Fifth index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][18])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][18];
                        if (Added)
                        {
                            Founded.RemoveAt(Founded.Count - 1);
                        }

                        Added = true;
                        Founded.Add(19);
                    }
                    //When Greater LessB of Sith index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][22])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][22];
                        if (Added)
                        {
                            Founded.RemoveAt(Founded.Count - 1);
                        }

                        Added = true;
                        Founded.Add(23);
                    }
                }
            }
        }

        //Method for Check of Existence of Checkmate less than for checked mate.
        private bool IsToCheckMateHasLessDeeperThanForCheckMate(AllDraw A, int Order, ref int ToCheckMate, ref int ForCheckMate, int AStarGreedy)
        {
            object a = new object();
            lock (a)
            {
                //Initiate variables.
                bool AA = false;
                int CDummy = Order;
                //For Gray One.
                if (Order == 1)
                {
                    //For Solderis.
                    for (int i = 0; i < SodierMidle; i++)
                    {
                        for (int j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinkingQuantum[0] != null && j < A.SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                        {
                            //When there is Brown checked mate.
                            if (A.SolderesOnTable[i].SoldierThinkingQuantum[0].CheckMateAStarGreedy == -1)
                            {
                                //Set.
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                {
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                    {
                                        AA = true;
                                    }
                                }
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.SolderesOnTable[i].SoldierThinkingQuantum[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                    {
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        {
                                            AA = true;
                                        }
                                    }
                                }
                            }
                            Order *= -1;
                            //recursive
                            for (int ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinkingQuantum[0] != null && ii < A.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            }

                            Order = CDummy;
                        }
                    }

                    for (int i = 0; i < ElefantMidle; i++)
                    {
                        for (int j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinkingQuantum[0] != null && j < A.ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                        {
                            //When there is Brown checked mate.
                            if (A.ElephantOnTable[i].ElefantThinkingQuantum[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                {
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                    {
                                        AA = true;
                                    }
                                }
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.ElephantOnTable[i].ElefantThinkingQuantum[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                    {
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        {
                                            AA = true;
                                        }
                                    }
                                }
                            }
                            Order *= -1;
                            //recursive
                            for (int ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ii < A.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            }

                            Order = CDummy;
                        }
                    }

                    for (int i = 0; i < HourseMidle; i++)
                    {
                        for (int j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinkingQuantum[0] != null && j < A.HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                        {
                            //When there is Brown checked mate.
                            if (A.HoursesOnTable[i].HourseThinkingQuantum[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                {
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                    {
                                        AA = true;
                                    }
                                }
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.HoursesOnTable[i].HourseThinkingQuantum[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                    {
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        {
                                            AA = true;
                                        }
                                    }
                                }
                            }
                            Order *= -1;
                            //recursive
                            for (int ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinkingQuantum[0] != null && ii < A.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            }

                            Order = CDummy;
                        }
                    }

                    for (int i = 0; i < CastleMidle; i++)
                    {
                        for (int j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinkingQuantum[0] != null && j < A.CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                        {
                            //When there is Brown checked mate.
                            if (A.CastlesOnTable[i].CastleThinkingQuantum[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                {
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                    {
                                        AA = true;
                                    }
                                }
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.CastlesOnTable[i].CastleThinkingQuantum[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                    {
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        {
                                            AA = true;
                                        }
                                    }
                                }
                            }
                            Order *= -1;
                            //recursive
                            for (int ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinkingQuantum[0] != null && ii < A.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            }

                            Order = CDummy;
                        }
                    }

                    for (int i = 0; i < MinisterMidle; i++)
                    {
                        for (int j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinkingQuantum[0] != null && j < A.MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                        {
                            //When there is Brown checked mate.
                            if (A.MinisterOnTable[i].MinisterThinkingQuantum[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                {
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                    {
                                        AA = true;
                                    }
                                }
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.MinisterOnTable[i].MinisterThinkingQuantum[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                    {
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        {
                                            AA = true;
                                        }
                                    }
                                }
                            }
                            Order *= -1;
                            //recursive
                            for (int ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinkingQuantum[0] != null && ii < A.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            }

                            Order = CDummy;
                        }
                    }

                    for (int i = 0; i < KingMidle; i++)
                    {
                        for (int j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinkingQuantum[0] != null && j < A.KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                        {
                            //When there is Brown checked mate.
                            if (A.KingOnTable[i].KingThinkingQuantum[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                {
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                    {
                                        AA = true;
                                    }
                                }
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.KingOnTable[i].KingThinkingQuantum[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                    {
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        {
                                            AA = true;
                                        }
                                    }
                                }
                            }
                            Order *= -1;
                            //recursive
                            for (int ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinkingQuantum[0] != null && ii < A.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            }

                            Order = CDummy;
                        }
                    }

                    for (int i = 0; i < 1; i++)
                    {
                        for (int j = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && j < A.CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //When there is Brown checked mate.
                            if (A.CastlingOnTable[i].CastlingThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                {
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                    {
                                        AA = true;
                                    }
                                }
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.CastlingOnTable[i].CastlingThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                    {
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        {
                                            AA = true;
                                        }
                                    }
                                }
                            }
                            Order *= -1;
                            //recursive
                            for (int ii = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && ii < A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                            {
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            }

                            Order = CDummy;
                        }
                    }
                }
                else
                {
                    for (int i = SodierMidle; i < SodierHigh; i++)
                    {
                        for (int j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinkingQuantum[0] != null && j < A.SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                        {
                            //When there is Brown checked mate.
                            if (A.SolderesOnTable[i].SoldierThinkingQuantum[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                {
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                    {
                                        AA = true;
                                    }
                                }
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.SolderesOnTable[i].SoldierThinkingQuantum[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                    {
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        {
                                            AA = true;
                                        }
                                    }
                                }
                            }
                            Order *= -1;
                            //recursive
                            for (int ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinkingQuantum[0] != null && ii < A.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            }

                            Order = CDummy;
                        }
                    }

                    for (int i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        for (int j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinkingQuantum[0] != null && j < A.ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                        {
                            //When there is Brown checked mate.
                            if (A.ElephantOnTable[i].ElefantThinkingQuantum[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                {
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                    {
                                        AA = true;
                                    }
                                }
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.ElephantOnTable[i].ElefantThinkingQuantum[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                    {
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        {
                                            AA = true;
                                        }
                                    }
                                }
                            }
                            Order *= -1;
                            //recursive
                            for (int ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ii < A.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            }

                            Order = CDummy;
                        }
                    }

                    for (int i = HourseMidle; i < HourseHight; i++)
                    {
                        for (int j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinkingQuantum[0] != null && j < A.HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                        {
                            //When there is Brown checked mate.
                            if (A.HoursesOnTable[i].HourseThinkingQuantum[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                {
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                    {
                                        AA = true;
                                    }
                                }
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.HoursesOnTable[i].HourseThinkingQuantum[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                    {
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        {
                                            AA = true;
                                        }
                                    }
                                }
                            }
                            Order *= -1;
                            //recursive
                            for (int ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinkingQuantum[0] != null && ii < A.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            }

                            Order = CDummy;
                        }
                    }

                    for (int i = CastleMidle; i < CastleHigh; i++)
                    {
                        for (int j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinkingQuantum[0] != null && j < A.CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                        {
                            //When there is Brown checked mate.
                            if (A.CastlesOnTable[i].CastleThinkingQuantum[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                {
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                    {
                                        AA = true;
                                    }
                                }
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.CastlesOnTable[i].CastleThinkingQuantum[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                    {
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        {
                                            AA = true;
                                        }
                                    }
                                }
                            }
                            Order *= -1;
                            //recursive
                            for (int ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinkingQuantum[0] != null && ii < A.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            }

                            Order = CDummy;
                        }
                    }

                    for (int i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        for (int j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinkingQuantum[0] != null && j < A.MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                        {
                            //When there is Brown checked mate.
                            if (A.MinisterOnTable[i].MinisterThinkingQuantum[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                {
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                    {
                                        AA = true;
                                    }
                                }
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.MinisterOnTable[i].MinisterThinkingQuantum[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                    {
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        {
                                            AA = true;
                                        }
                                    }
                                }
                            }

                            Order *= -1;
                            //recursive
                            for (int ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinkingQuantum[0] != null && ii < A.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            }

                            Order = CDummy;
                        }
                    }

                    for (int i = KingMidle; i < KingHigh; i++)
                    {
                        for (int j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinkingQuantum[0] != null && j < A.KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                        {
                            //When there is Brown checked mate.
                            if (A.KingOnTable[i].KingThinkingQuantum[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                {
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                    {
                                        AA = true;
                                    }
                                }
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.KingOnTable[i].KingThinkingQuantum[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                    {
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        {
                                            AA = true;
                                        }
                                    }
                                }
                            }

                            Order *= -1;
                            //recursive
                            for (int ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinkingQuantum[0] != null && ii < A.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            }

                            Order = CDummy;
                        }
                    }

                    for (int i = 0; i < 1; i++)
                    {
                        for (int j = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && j < A.CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //When there is Brown checked mate.
                            if (A.CastlingOnTable[i].CastlingThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                {
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                    {
                                        AA = true;
                                    }
                                }
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.CastlingOnTable[i].CastlingThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                    {
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        {
                                            AA = true;
                                        }
                                    }
                                }
                            }
                            Order *= -1;
                            //recursive
                            for (int ii = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && ii < A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                            {
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            }

                            Order = CDummy;
                        }
                    }
                }

                ChessRules.CurrentOrder = CDummy;
                return AA;
            }
        }

        //When Penalty Regard Branches expanded to sub branches.
        private void IsPenaltyRegardCheckMateAtBranch(int Order, ref int Do, AllDraw Base)
        {
            object a = new object();
            lock (a)
            {
                int CDummy = ChessRules.CurrentOrder;
                int COrder = Order;
                //For Gray Order.
                if (Order == 1)
                {
                    ChessRules AA = null;

                    //For  Soldeirs.
                    for (int i = 0; i < SodierMidle; i++)
                    {
                        for (int j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && j < SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                        {
                            //Create Rules Objects For Soldiers.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j])[SolderesOnTable[i].SoldierThinkingQuantum[0].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[0].RowColumnSoldier[j][1]]
                                , CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j])
                                , Order
                                );
                            //When CheckMate Occured for Current Sodiers
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = AA.CheckMate(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j], Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //When Self CheckMate
                                if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                {
                                    //Return Ignore
                                    Do = -1;
                                    //Set Superposition.
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //When Enemy CheckMate
                                    if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Regard and Set Movements.
                                        Do = 1;
                                        //Regard Subbranchs.
                                        Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                        //Set Superpostion.
                                        SolderesOnTable[i].SoldierThinkingQuantum[0].CheckMateAStarGreedy = 1;
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Subbranchs.
                                for (int ii = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && ii < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;
                                    Task ah1 = Task.Factory.StartNew(() => SolderesOnTable[ii].SoldierThinkingQuantum[0].AStarGreedy[i].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    }

                    //For Elephant.
                    for (int i = 0; i < ElefantMidle; i++)
                    {
                        for (int j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && j < ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                        {
                            //Create Elephant Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j])[ElephantOnTable[i].ElefantThinkingQuantum[0].RowColumnElefant[j][0], ElephantOnTable[i].ElefantThinkingQuantum[0].RowColumnElefant[j][1]]
                            , CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j])
                            , Order
                            );
                            //When CheckMate Occured for Current Elephant.
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //For Self Order CheckMate.
                                if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                {
                                    //Set Penalty Ignore.
                                    Do = -1;
                                    //Set Superposition.
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //For Enemy Order CheckMate.
                                    if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Regard Continue.
                                        Do = 1;
                                        //Regard Subolders.
                                        Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                        //Set Superposition.
                                        ElephantOnTable[i].ElefantThinkingQuantum[0].CheckMateAStarGreedy = 1;
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Subbranchs.
                                for (int ii = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ii < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    Task ah1 = Task.Factory.StartNew(() => ElephantOnTable[ii].ElefantThinkingQuantum[0].AStarGreedy[i].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    }
                    //For Hourse.
                    for (int i = 0; i < HourseMidle; i++)
                    {
                        for (int j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && j < HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                        {
                            //Set Hourse Rules Objects.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j])[HoursesOnTable[i].HourseThinkingQuantum[0].RowColumnHourse[j][0], HoursesOnTable[i].HourseThinkingQuantum[0].RowColumnHourse[j][1]]
                            , CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j])
                            , Order
                            );
                            //When CheckMate Occured.
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //For Self CheckMate.
                                if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                {
                                    //Set Ignore.
                                    Do = -1;
                                    //Set Superposition.
                                    HoursesOnTable[i].HourseThinkingQuantum[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //For Enemy CheckMate.
                                    if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superposition.
                                        HoursesOnTable[i].HourseThinkingQuantum[0].CheckMateAStarGreedy = 1;
                                        //Set Regard For Sub Branches.
                                        Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Sub branchs For Hourse.
                                for (int ii = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && ii < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    Task ah1 = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    }
                    //For Gray Briges.
                    for (int i = 0; i < CastleMidle; i++)
                    {
                        for (int j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && j < CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                        {
                            //Castles Gray Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j])[CastlesOnTable[i].CastleThinkingQuantum[0].RowColumnCastle[j][0], CastlesOnTable[i].CastleThinkingQuantum[0].RowColumnCastle[j][1]]
                            , CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j])
                            , Order
                            );
                            //When Current Gray Castles CheckMate.
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //For Self CheckMate
                                if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                {
                                    //Set Penalty Ignore.
                                    Do = -1;
                                    //Set Superposition.
                                    CastlesOnTable[i].CastleThinkingQuantum[0].CheckMateAStarGreedy = -1;
                                    //Penalty Sub branchs.
                                    Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //For Enemy CheckMate.
                                    if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superpoistion.
                                        CastlesOnTable[i].CastleThinkingQuantum[0].CheckMateAStarGreedy = 1;
                                        //Set Regard Subbranchs.
                                        Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Castles Gray Subbranchs.
                                for (int ii = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && ii < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    Task ah1 = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    }
                    //For Ministers Gray.
                    for (int i = 0; i < MinisterMidle; i++)
                    {
                        for (int j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && j < MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                        {
                            //Minister Gray Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j])[MinisterOnTable[i].MinisterThinkingQuantum[0].RowColumnMinister[j][0], MinisterOnTable[i].MinisterThinkingQuantum[0].RowColumnMinister[j][1]]
                            , CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j])
                            , Order
                            );
                            //When M ate Occured in Minister Gray.
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                {
                                    //Penalty Ignore.
                                    Do = -1;
                                    //Superpostion.
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //For Enemy CheckMate.
                                    if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                    {
                                        //Regard Setting.
                                        Do = 1;
                                        //Superpoistion.
                                        MinisterOnTable[i].MinisterThinkingQuantum[0].CheckMateAStarGreedy = 1;
                                        //Set Subbranchs Regard.
                                        Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Gray Ministers Subbranchs.
                                for (int ii = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && ii < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    Task ah1 = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    }
                    //For Gray King.
                    for (int i = 0; i < KingMidle; i++)
                    {
                        for (int j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum[0] != null && j < KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                        {
                            //Gray King Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j])[KingOnTable[i].KingThinkingQuantum[0].RowColumnKing[j][0], KingOnTable[i].KingThinkingQuantum[0].RowColumnKing[j][1]]
                            , CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j])
                            , Order
                            );
                            //When CheckMate Occured in King Gray.
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                {
                                    //Penalty Ignore.
                                    Do = -1;
                                    //Superposition.
                                    KingOnTable[i].KingThinkingQuantum[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                    {
                                        //Regard Setting.
                                        Do = 1;
                                        //Superpoistion.
                                        KingOnTable[i].KingThinkingQuantum[0].CheckMateAStarGreedy = 1;
                                        //Regard Subbranchs.
                                        Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For King Gray Subbranchs.
                                for (int ii = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum[0] != null && ii < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    Task ah1 = Task.Factory.StartNew(() => KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    }

                    for (int i = 0; i < 1; i++)
                    {
                        for (int j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //Gray Castling Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j])[CastlingOnTable[i].CastlingThinking[0].RowColumnCastling[j][0], CastlingOnTable[i].CastlingThinking[0].RowColumnCastling[j][1]]
                            , CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j])
                            , Order
                            );
                            //When CheckMate Occured in Castling Gray.
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                {
                                    //Penalty Ignore.
                                    Do = -1;
                                    //Superposition.
                                    CastlingOnTable[i].CastlingThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                    {
                                        //Regard Setting.
                                        Do = 1;
                                        //Superpoistion.
                                        CastlingOnTable[i].CastlingThinking[0].CheckMateAStarGreedy = 1;
                                        //Regard Subbranchs.
                                        Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Castling Gray Subbranchs.
                                for (int ii = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && ii < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    Task ah1 = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    }
                }
                //For Brown Order.
                else
                {
                    ChessRules AA = null;

                    //For Solders Brown.
                    for (int i = SodierMidle; i < SodierHigh; i++)
                    {
                        for (int j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && j < SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                        {
                            //Solders Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j])[SolderesOnTable[i].SoldierThinkingQuantum[0].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[0].RowColumnSoldier[j][1]]
                            , CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j])
                            , Order
                            );
                            //When Solders Brown CheckMate Occured.
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = AA.CheckMate(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j], Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {     //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                {
                                    //Ignore Penalty.
                                    Do = -1;
                                    //Supperpoistion.
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs Soders Brown.
                                    Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superpoition.
                                        SolderesOnTable[i].SoldierThinkingQuantum[0].CheckMateAStarGreedy = 1;
                                        //Penalty Subbranchs.
                                        Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Solders Brown Subbranchs Calling.
                                for (int ii = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && ii < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    Task ah1 = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    }
                    //Elephant Brown
                    for (int i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        for (int j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && j < ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                        {
                            //Elephant Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j])[ElephantOnTable[i].ElefantThinkingQuantum[0].RowColumnElefant[j][0], ElephantOnTable[i].ElefantThinkingQuantum[0].RowColumnElefant[j][1]]
                            , CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j])
                            , Order
                            );
                            //CheckMate Occured in Elephenat Brown.
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                {
                                    //Ignore Penalty.
                                    Do = -1;
                                    //Superpoistion.
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regrading.
                                        Do = 1;
                                        //Superposition.
                                        ElephantOnTable[i].ElefantThinkingQuantum[0].CheckMateAStarGreedy = 1;
                                        //Regrad Subbranchs.
                                        Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Subbranchs Elephenat Brown Calling.
                                for (int ii = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ii < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    Task ah1 = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    }
                    //Hourse Brown
                    for (int i = HourseMidle; i < HourseHight; i++)
                    {
                        for (int j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && j < HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                        {
                            //Hourse Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j])[HoursesOnTable[i].HourseThinkingQuantum[0].RowColumnHourse[j][0], HoursesOnTable[i].HourseThinkingQuantum[0].RowColumnHourse[j][1]]
                            , CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j])
                            , Order
                            );
                            //When Hourse Broin CheckMate Ocuucred.
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                {
                                    //Ignore Penalty.
                                    Do = -1;
                                    //Superposition.
                                    HoursesOnTable[i].HourseThinkingQuantum[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regrad.
                                        Do = 1;
                                        //Superposition.
                                        HoursesOnTable[i].HourseThinkingQuantum[0].CheckMateAStarGreedy = 1;
                                        //Regrad Subbranchs.
                                        Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Hourse Brown Calling Subbranchs.
                                for (int ii = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && ii < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    Task ah1 = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    }
                    //Castles Brown
                    for (int i = CastleMidle; i < CastleHigh; i++)
                    {
                        for (int j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && j < CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                        {
                            //Castles Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j])[CastlesOnTable[i].CastleThinkingQuantum[0].RowColumnCastle[j][0], CastlesOnTable[i].CastleThinkingQuantum[0].RowColumnCastle[j][1]]
                            , CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j])
                            , Order
                            );
                            //When Brown Castles CheckMate Occured.
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                {
                                    //Ignore CheckMate.
                                    Do = -1;
                                    //Superpoistion.
                                    CastlesOnTable[i].CastleThinkingQuantum[0].CheckMateAStarGreedy = -1;
                                    //Subbranchs Penalty.
                                    Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superpoistion.
                                        CastlesOnTable[i].CastleThinkingQuantum[0].CheckMateAStarGreedy = 1;
                                        //Regard Subbranchs.
                                        Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Brown Castles Calling Subbranches.
                                for (int ii = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && ii < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    Task ah1 = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    }
                    //Minister Brown
                    for (int i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        for (int j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && j < MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                        {
                            //Minister Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j])[MinisterOnTable[i].MinisterThinkingQuantum[0].RowColumnMinister[j][0], MinisterOnTable[i].MinisterThinkingQuantum[0].RowColumnMinister[j][1]]
                            , CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j])
                            , Order
                            );
                            //When Minister Borwn CheckMate Occcured.
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                {
                                    //Set Ignore.
                                    Do = -1;
                                    //Superpoistion.
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranches.
                                    Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superposition.
                                        MinisterOnTable[i].MinisterThinkingQuantum[0].CheckMateAStarGreedy = 1;
                                        //Regard SubBranches.
                                        Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Minister Brown SubBranches Calling.
                                for (int ii = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && ii < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    Task ah1 = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    }
                    //King Brown
                    for (int i = KingMidle; i < KingHigh; i++)
                    {
                        for (int j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum[0] != null && j < KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                        {
                            //King Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j])[KingOnTable[i].KingThinkingQuantum[0].RowColumnKing[j][0], KingOnTable[i].KingThinkingQuantum[0].RowColumnKing[j][1]]
                            , CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j])
                            , Order
                            );
                            //When King Brown Rules CheckMate Occcured.
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                {
                                    //Set Ignore.
                                    Do = -1;
                                    //Superposition.
                                    KingOnTable[i].KingThinkingQuantum[0].CheckMateAStarGreedy = -1;
                                    //Penalty SubBranches.
                                    Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superposition.
                                        KingOnTable[i].KingThinkingQuantum[0].CheckMateAStarGreedy = 1;
                                        //Regard Subbranches.
                                        Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //King Brown Subbranches Calling.
                                for (int ii = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum[0] != null && ii < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    Task ah1 = Task.Factory.StartNew(() => KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    }

                    for (int i = 0; i < 1; i++)
                    {
                        for (int j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //Gray Castling Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j])[CastlingOnTable[i].CastlingThinking[0].RowColumnCastling[j][0], CastlingOnTable[i].CastlingThinking[0].RowColumnCastling[j][1]]
                            , CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j])
                            , Order);
                            //When CheckMate Occured in Castling Gray.
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                {
                                    //Penalty Ignore.
                                    Do = -1;
                                    //Superposition.
                                    CastlingOnTable[i].CastlingThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                    {
                                        //Regard Setting.
                                        Do = 1;
                                        //Superpoistion.
                                        CastlingOnTable[i].CastlingThinking[0].CheckMateAStarGreedy = 1;
                                        //Regard Subbranchs.
                                        Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Castling Gray Subbranchs.
                                for (int ii = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && ii < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    Task ah1 = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    }
                }
                ChessRules.CurrentOrder = CDummy;
            }
        }

        //A Mechanisam for penalty all subbranches of chiled of root at contained of same childes  of making penalty by target
        public void MakePenaltyAllCheckMateBranches(AllDraw A, int Order)
        {
            object a = new object();
            lock (a)
            {
                int COrder = Order;
                int CDummy = ChessRules.CurrentOrder;
                if (Order == 1)
                {
                    //For Solider Gray
                    for (int i = 0; i < SodierMidle; i++)
                    {
                        for (int j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinkingQuantum[0] != null && j < A.SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                        {
                            //make penalty
                            A.SolderesOnTable[i].SoldierThinkingQuantum[0].PenaltyRegardListSolder[i].LearningAlgorithmPenalty();
                            //For deeper chiled.
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (int ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinkingQuantum[0] != null && ii < A.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //For Elephant Gray
                    for (int i = 0; i < ElefantMidle; i++)
                    {
                        for (int j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinkingQuantum[0] != null && j < A.ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                        {
                            //make penalty
                            A.ElephantOnTable[i].ElefantThinkingQuantum[0].PenaltyRegardListElefant[j].LearningAlgorithmPenalty();
                            //For Depper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (int ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ii < A.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //For Hourse Gray
                    for (int i = 0; i < HourseMidle; i++)
                    {
                        for (int j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinkingQuantum[0] != null && j < A.HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                        {
                            //make penalty
                            A.HoursesOnTable[i].HourseThinkingQuantum[0].PenaltyRegardListHourse[j].LearningAlgorithmPenalty();

                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (int ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinkingQuantum[0] != null && ii < A.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //for Castle Gray
                    for (int i = 0; i < CastleMidle; i++)
                    {
                        for (int j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinkingQuantum[0] != null && j < A.CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                        {
                            //make penalty
                            A.CastlesOnTable[i].CastleThinkingQuantum[0].PenaltyRegardListCastle[j].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (int ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinkingQuantum[0] != null && ii < A.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //for minister Gray
                    for (int i = 0; i < MinisterMidle; i++)
                    {
                        for (int j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinkingQuantum[0] != null && j < A.MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                        {
                            //make penalty
                            A.MinisterOnTable[i].MinisterThinkingQuantum[0].PenaltyRegardListMinister[j].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (int ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinkingQuantum[0] != null && ii < A.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //for Gray king
                    for (int i = 0; i < KingMidle; i++)
                    {
                        for (int j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinkingQuantum[0] != null && j < A.KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                        {
                            //make penalty
                            A.KingOnTable[i].KingThinkingQuantum[0].PenaltyRegardListKing[j].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (int ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinkingQuantum[0] != null && ii < A.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }

                    for (int i = 0; i < 1; i++)
                    {
                        for (int j = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && j < A.CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //make penalty
                            A.CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling[j].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (int ii = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && ii < A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                }
                else//Brown
                {
                    //for soldier Brown
                    for (int i = SodierMidle; i < SodierHigh; i++)
                    {
                        for (int j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinkingQuantum[0] != null && j < A.SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                        {
                            //make penalty
                            A.SolderesOnTable[i].SoldierThinkingQuantum[0].PenaltyRegardListSolder[i].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (int ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinkingQuantum[0] != null && ii < A.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //for elephant Brown
                    for (int i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        for (int j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinkingQuantum[0] != null && j < A.ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                        {
                            //make penalty
                            A.ElephantOnTable[i].ElefantThinkingQuantum[0].PenaltyRegardListElefant[j].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (int ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ii < A.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //for hourse Brown
                    for (int i = HourseMidle; i < HourseHight; i++)
                    {
                        for (int j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinkingQuantum[0] != null && j < A.HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                        {
                            //make penalty
                            A.HoursesOnTable[i].HourseThinkingQuantum[0].PenaltyRegardListHourse[j].LearningAlgorithmPenalty();

                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (int ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinkingQuantum[0] != null && ii < A.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //for casytle Brown
                    for (int i = CastleMidle; i < CastleHigh; i++)
                    {
                        for (int j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinkingQuantum[0] != null && j < A.CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                        {
                            //make penalty
                            A.CastlesOnTable[i].CastleThinkingQuantum[0].PenaltyRegardListCastle[j].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (int ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinkingQuantum[0] != null && ii < A.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //for minsiter Brown
                    for (int i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        for (int j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinkingQuantum[0] != null && j < A.MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                        {
                            //make penalty
                            A.MinisterOnTable[i].MinisterThinkingQuantum[0].PenaltyRegardListMinister[j].LearningAlgorithmPenalty();
                            //fopfor weeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (int ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinkingQuantum[0] != null && ii < A.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //for king Brown
                    for (int i = KingMidle; i < MinisterHigh; i++)
                    {
                        for (int j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinkingQuantum[0] != null && j < A.KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                        {
                            //make penalty
                            A.KingOnTable[i].KingThinkingQuantum[0].PenaltyRegardListKing[j].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (int ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinkingQuantum[0] != null && ii < A.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }

                    for (int i = 0; i < 1; i++)
                    {
                        for (int j = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && j < A.CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //make penalty
                            A.CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling[j].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (int ii = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && ii < A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                }
            }
        }

        //remove penalty from root current node.
        public AllDraw RemovePenalltyFromFirstBranches(int Order)
        {
            object a = new object();
            lock (a)
            {
                //Gray
                if (Order == 1)
                {
                    //for Gray solder
                    for (int i = 0; i < SodierMidle; i++)
                    {
                        for (int j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && j < SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;
                            Task ah = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinkingQuantum[0].PenaltyRegardListSolder[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; k++)
                            {
                                Task<AllDraw> ah1 = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    }
                    //for Gray elephant
                    for (int i = 0; i < ElefantMidle; i++)
                    {
                        for (int j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && j < ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            Task ah = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinkingQuantum[0].PenaltyRegardListElefant[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; k++)
                            {
                                Task<AllDraw> ah1 = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    }
                    //for Gray hourse
                    for (int i = 0; i < HourseMidle; i++)
                    {
                        for (int j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && j < HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;
                            Task ah = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinkingQuantum[0].PenaltyRegardListHourse[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; k++)
                            {
                                Task<AllDraw> ah1 = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    }
                    //for Castle Gray
                    for (int i = 0; i < CastleMidle; i++)
                    {
                        for (int j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && j < CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            Task ah = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinkingQuantum[0].PenaltyRegardListCastle[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; k++)
                            {
                                Task<AllDraw> ah1 = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    }
                    //for Gray minsiter
                    for (int i = 0; i < MinisterMidle; i++)
                    {
                        for (int j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && j < MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            Task ah = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinkingQuantum[0].PenaltyRegardListMinister[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; k++)
                            {
                                Task<AllDraw> ah1 = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    }
                    //for Gray minster
                    for (int i = 0; i < KingMidle; i++)
                    {
                        for (int j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum[0] != null && j < KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            Task ah = Task.Factory.StartNew(() => KingOnTable[i].KingThinkingQuantum[0].PenaltyRegardListKing[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; k++)
                            {
                                Task<AllDraw> ah1 = Task.Factory.StartNew(() => KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    }

                    for (int i = 0; i < 1; i++)
                    {
                        for (int j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            Task ah = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; k++)
                            {
                                Task<AllDraw> ah1 = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    }
                }
                else
                {
                    //for Brown soldeir
                    for (int i = SodierMidle; i < SodierHigh; i++)
                    {
                        for (int j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum != null && j < SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            Task ah = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinkingQuantum[0].PenaltyRegardListSolder[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; k++)
                            {
                                Task<AllDraw> ah1 = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    }
                    //for Brown elephant
                    for (int i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        for (int j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && j < ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            Task ah = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinkingQuantum[0].PenaltyRegardListElefant[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; k++)
                            {
                                Task<AllDraw> ah1 = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    }
                    //for Brown hourse
                    for (int i = HourseMidle; i < HourseHight; i++)
                    {
                        for (int j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && j < HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            Task ah = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinkingQuantum[0].PenaltyRegardListHourse[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; k++)
                            {
                                Task<AllDraw> ah1 = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    }
                    //for Brown Castle
                    for (int i = CastleMidle; i < CastleHigh; i++)
                    {
                        for (int j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && j < CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            Task ah = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinkingQuantum[0].PenaltyRegardListCastle[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; k++)
                            {
                                Task<AllDraw> ah1 = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    }
                    //for Brown ,minster
                    for (int i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        for (int j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && j < MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            Task ah = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinkingQuantum[0].PenaltyRegardListMinister[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; k++)
                            {
                                Task<AllDraw> ah1 = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    }
                    //for Brown king
                    for (int i = KingMidle; i < KingHigh; i++)
                    {
                        for (int j = 0; KingOnTable != null && KingOnTable[i] != null
                            && KingOnTable[i].KingThinkingQuantum[0] != null && j < KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;
                            Task ah = Task.Factory.StartNew(() => KingOnTable[i].KingThinkingQuantum[0].PenaltyRegardListKing[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; k++)
                            {
                                Task<AllDraw> ah1 = Task.Factory.StartNew(() => KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    }

                    for (int i = 0; i < 1; i++)
                    {
                        for (int j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            Task ah = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; k++)
                            {
                                Task<AllDraw> ah1 = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    }
                }

                return this;
            }
        }

        //when index is out of boundry return false when is valid return true
        private bool BondryObjectNumber(int i, int Kind, int Order)
        {
            bool Is = true;
            if (Order == 1)
            {
                if (Kind == 1)
                {
                    if (i >= SodierMidle)
                    {
                        Is = false;
                    }
                }
                else
                    if (Kind == 2)
                {
                    if (i >= ElefantMidle)
                    {
                        Is = false;
                    }
                }
                else
                    if (Kind == 3)
                {
                    if (i >= HourseMidle)
                    {
                        Is = false;
                    }
                }
                else
                    if (Kind == 4)
                {
                    if (i >= CastleMidle)
                    {
                        Is = false;
                    }
                }
                else
                    if (Kind == 5)
                {
                    if (i >= MinisterMidle)
                    {
                        Is = false;
                    }
                }
                else
                    if (Kind == 6)
                {
                    if (i >= KingMidle)
                    {
                        Is = false;
                    }
                }
                else
                   if (Kind == 7 || Kind == -7)
                {
                    if (i < 0 || i >= 1)
                    {
                        Is = false;
                    }
                }
            }
            else
            {
                if (Kind == 1)
                {
                    if (i < SodierMidle || i >= SodierHigh)
                    {
                        Is = false;
                    }
                }
                else
                   if (Kind == 2)
                {
                    if (i < ElefantMidle || i >= ElefantHigh)
                    {
                        Is = false;
                    }
                }
                else
                   if (Kind == 3)
                {
                    if (i < HourseMidle || i >= HourseHight)
                    {
                        Is = false;
                    }
                }
                else
                   if (Kind == 4)
                {
                    if (i < CastleMidle || i >= CastleHigh)
                    {
                        Is = false;
                    }
                }
                else
                   if (Kind == 5)
                {
                    if (i < MinisterMidle || i >= MinisterHigh)
                    {
                        Is = false;
                    }
                }
                else
                   if (Kind == 6)
                {
                    if (i < KingMidle || i >= KingHigh)
                    {
                        Is = false;
                    }
                }
                else
                   if (Kind == 7 || Kind == -7)
                {
                    if (i < 0 || i >= 1)
                    {
                        Is = false;
                    }
                }
            }
            return Is;
        }

        int MaxSevenInteger(int _1, int _2, int _3, int _4, int _5, int _6,int _7)
        {
            int[] A = { _1, _2, _3, _4, _5, _6, _7 };
            int Max = -1;
            for (int i = 0; i < 7; i++)
            {
                if (Max < A[i])
                    Max = A[i];
            }
            return Max;
        }
        //All valid call of current alldraw deeper of founding get node.
        public AllDraw FoundOfCurrentTableNodeAstardGreedy(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            FoundOfCurrentTableNodeAstardGreedyS(i, j, Tab, Order, ref THIS, ref Found);
            FoundOfCurrentTableNodeAstardGreedyE(i, j, Tab, Order, ref THIS, ref Found);
            FoundOfCurrentTableNodeAstardGreedyH(i, j, Tab, Order, ref THIS, ref Found);
            FoundOfCurrentTableNodeAstardGreedyC(i, j, Tab, Order, ref THIS, ref Found);
            FoundOfCurrentTableNodeAstardGreedyM(i, j, Tab, Order, ref THIS, ref Found);
            FoundOfCurrentTableNodeAstardGreedyK(i, j, Tab, Order, ref THIS, ref Found);
            FoundOfCurrentTableNodeAstardGreedyA(i, j, Tab, Order, ref THIS, ref Found);

            return THIS;
        }

        public AllDraw FoundOfCurrentTableNodeAstardGreedyS(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            try
            {  //soldier
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 1, Order));
                ah.Wait();
                ah.Dispose();
                if (ac && SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder != null && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null && j < SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count )
                {
                    if (SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count > j)
                    {
                        AllDraw This = THIS;
                        bool fou = Found;
                        Task<AllDraw> ah6 = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref This, ref fou));
                        ah6.Wait();
                        ah6.Dispose();
                        THIS = This;
                        Found = fou;
                    }
                }
            }
            catch (Exception t)
            {
                Log(t);
            }

            return THIS;
        }
        public AllDraw FoundOfCurrentTableNodeAstardGreedyE(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            try
            {    //elephant
                bool ac = false;
                Task<bool> ah1 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 2, Order));
                ah1.Wait();
                ah1.Dispose();
                if (ac && ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant != null && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null && j < ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count )
                {
                    if (ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count > j)
                    {
                        AllDraw This = THIS;
                        bool fou = Found;
                        Task<AllDraw> ah6 = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref This, ref fou));
                        ah6.Wait();
                        ah6.Dispose();
                        THIS = This;
                        Found = fou;
                    }
                }

            }
            catch (Exception t)
            {
                Log(t);
            }
            return THIS;
        }
        public AllDraw FoundOfCurrentTableNodeAstardGreedyH(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            try
            {   //hourse
                bool ac = false;
                Task<bool> ah2 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 3, Order));
                ah2.Wait();
                ah2.Dispose();
                if (ac && HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse != null && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null && j < HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count )
                {
                    if (HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count > j)
                    {
                        AllDraw This = THIS;
                        bool fou = Found;
                        Task<AllDraw> ah6 = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref This, ref fou));
                        ah6.Wait();
                        ah6.Dispose();
                        THIS = This;
                        Found = fou;
                    }
                }
            }
            catch (Exception t)
            {
                Log(t);
            }
            return THIS;
        }
        public AllDraw FoundOfCurrentTableNodeAstardGreedyC(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            try
            {  //Castle
                bool ac = false;
                Task<bool> ah3 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 4, Order));
                ah3.Wait();
                ah3.Dispose();
                if (ac && CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle != null && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null && j < CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count )
                {
                    if (CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count > j)
                    {
                        AllDraw This = THIS;
                        bool fou = Found;
                        Task<AllDraw> ah6 = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref This, ref fou));
                        ah6.Wait();
                        ah6.Dispose();
                        THIS = This;
                        Found = fou;
                    }
                }

            }
            catch (Exception t)
            {
                Log(t);
            }
            return THIS;
        }
        public AllDraw FoundOfCurrentTableNodeAstardGreedyM(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            try
            {  //minster
                bool ac = false;
                Task<bool> ah4 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 5, Order));
                ah4.Wait();
                ah4.Dispose();
                if (ac && MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null && j < MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count )
                {
                    if (MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count > j)
                    {
                        AllDraw This = THIS;
                        bool fou = Found;
                        Task<AllDraw> ah6 = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref This, ref fou));
                        ah6.Wait();
                        ah6.Dispose();
                        THIS = This;
                        Found = fou;
                    }
                }
            }
            catch (Exception t)
            {
                Log(t);
            }
            return THIS;
        }
        public AllDraw FoundOfCurrentTableNodeAstardGreedyK(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            try
            {   //king
                bool ac = false;
                Task<bool> ah5 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 6, Order));
                ah5.Wait();
                ah5.Dispose();
                if (ac && KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum[0] != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing != null && j < KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count > j )
                {
                    if (KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count > j)
                    {
                        AllDraw This = THIS;
                        bool fou = Found;
                        Task<AllDraw> ah6 = Task.Factory.StartNew(() => KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref This, ref fou));
                        ah6.Wait();
                        ah6.Dispose();
                        THIS = This;
                        Found = fou;
                    }
                }

            }
            catch (Exception t)
            {
                Log(t);
            }

            return THIS;
        }

        public AllDraw FoundOfCurrentTableNodeAstardGreedyA(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            try
            {
                bool ac = false;
                Task<bool> ah7 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 7, Order));
                ah7.Wait();
                ah7.Dispose();
                if (ac && CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j )
                {
                    if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j)
                    {
                        AllDraw This = THIS;
                        bool fou = Found;
                        Task<AllDraw> ah8 = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref This, ref fou));
                        ah8.Wait();
                        ah8.Dispose();
                        THIS = This;
                        Found = fou;
                    }
                }
            }
            catch (Exception t) { Log(t); }
            return THIS;
        }
        //when current alldraw is equal of table state return node and set true
        public AllDraw FoundOfCurrentTableNode(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            object a = new object();
            lock (a)
            {
                int Max = MaxSevenInteger(SodierHigh, ElefantHigh, HourseHight, CastleHigh, MinisterHigh, KingHigh, 1);
                //when current stisgied
                bool ac = false;
                AllDraw This = THIS;
                bool fou = Found;
                Task<bool> ah = Task.Factory.StartNew(() => ac = (TableList.Count > 0 && ThinkingQuantumChess.TableEqual(TableList[0], Tab)) || FoundOfCurrentTableNodeFirstLevel(CloneATable(Tab), Order, ref This, ref fou));
                ah.Wait();
                ah.Dispose();
                THIS = This;
                Found = fou;
                if (ac)
                {
                    if (!Found)
                    {
                        THIS = this;
                        Found = true;
                    }

                    return THIS;
                }
                else//else Gray
                if (Order == 1)
                {
                    //soldier
                    for (int i = 0; i < Max; i++)
                    {
                        FoundOfCurrentTableNodeS(i, Tab, Order, ref THIS, ref Found);
                    }
                    //elephant
                    for (int i = 0; i < Max; i++)
                    {
                        FoundOfCurrentTableNodeE(i, Tab, Order, ref THIS, ref Found);
                    }
                    //hourse
                    for (int i = 0; i < Max; i++)
                    {
                        FoundOfCurrentTableNodeH(i, Tab, Order, ref THIS, ref Found);
                    }
                    //Castle
                    for (int i = 0; i < Max; i++)
                    {
                        FoundOfCurrentTableNodeC(i, Tab, Order, ref THIS, ref Found);
                    }
                    //minster
                    for (int i = 0; i < Max; i++)
                    {
                        FoundOfCurrentTableNodeM(i, Tab, Order, ref THIS, ref Found);
                    }
                    //king
                    for (int i = 0; i < Max; i++)
                    {
                        FoundOfCurrentTableNodeK(i, Tab, Order, ref THIS, ref Found);
                    }
                    for (int i = 0; i < Max; i++)
                    {
                        FoundOfCurrentTableNodeA(i, Tab, Order, ref THIS, ref Found);
                    }
                }//Brown
                else
                {
                    //soldier
                    for (int i = 0; i < Max; i++)
                    {
                        FoundOfCurrentTableNodeS(i, Tab, Order, ref THIS, ref Found);
                    }
                    //elephant
                    for (int i = 0; i < Max; i++)
                    {
                        FoundOfCurrentTableNodeE(i, Tab, Order, ref THIS, ref Found);
                    }
                    //hourse
                    for (int i = 0; i < Max; i++)
                    {
                        FoundOfCurrentTableNodeH(i, Tab, Order, ref THIS, ref Found);
                    }
                    //Castle
                    for (int i = 0; i < Max; i++)
                    {
                        FoundOfCurrentTableNodeC(i, Tab, Order, ref THIS, ref Found);
                    }
                    //minster
                    for (int i = 0; i < Max; i++)
                    {
                        FoundOfCurrentTableNodeM(i, Tab, Order, ref THIS, ref Found);
                    }
                    //king
                    for (int i = 0; i < Max; i++)
                    {
                        FoundOfCurrentTableNodeK(i, Tab, Order, ref THIS, ref Found);
                    }
                    for (int i = 0; i < Max; i++)
                    {
                        FoundOfCurrentTableNodeA(i, Tab, Order, ref THIS, ref Found);
                    }
                }
                return THIS;
            }
        }

        public AllDraw FoundOfCurrentTableNodeS(int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            object a = new object();
            lock (a)
            {
                try
                {
                    bool ac = false;
                    Task<bool> ah7 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 1, Order));
                    ah7.Wait();
                    ah7.Dispose();
                    AllDraw This = null;

                    bool fou = false;

                    for (int j = 0; ac && SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder != null && j < SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                    {
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 1));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j], Tab));
                        ah2.Wait();
                        ah2.Dispose();
                        if (ac)
                        {
                            This = THIS;
                            fou = Found;
                            Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeSolderIJ(i, j, Order, ref This, ref fou));
                            ah6.Wait();
                            ah6.Dispose();
                            THIS = This;
                            Found = fou;
                            if (Found)
                            {
                                return THIS;
                            }
                        }
                        else
                        {
                            //SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[k].
                            This = THIS;
                            fou = Found;
                            Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah6.Wait();
                            ah6.Dispose();
                            THIS = This;
                            Found = fou;
                            if (Found)
                            {
                                return THIS;
                            }
                        }
                    }
                }
                catch (Exception t) { Log(t); }
                return THIS;
            }
        }
        public AllDraw FoundOfCurrentTableNodeE(int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            object a = new object();
            lock (a)
            {
                try
                {
                    bool ac = false;
                    Task<bool> ah7 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 2, Order));
                    ah7.Wait();
                    ah7.Dispose();

                    AllDraw This = null;
                    bool fou = false;


                    for (int j = 0; ac && ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant != null && j < ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                    {
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 2));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j], Tab));
                        ah2.Wait();
                        ah2.Dispose();
                        if (ac)
                        {
                            This = THIS;
                            fou = Found;
                            Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeElephantIJ(i, j, Order, ref This, ref fou));
                            ah6.Wait();
                            ah6.Dispose();
                            THIS = This;
                            Found = fou;
                            if (Found)
                            {
                                return THIS;
                            }
                        }
                        else
                        {
                            //ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[k].
                            This = THIS;
                            fou = Found;
                            Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah6.Wait();
                            ah6.Dispose();
                            THIS = This;
                            Found = fou;
                            if (Found)
                            {
                                return THIS;
                            }
                        }
                    }
                }
                catch (Exception t) { Log(t); }
                return THIS;
            }
        }
        public AllDraw FoundOfCurrentTableNodeH(int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            object a = new object();
            lock (a)
            {
                try
                {
                    bool ac = false;
                    Task<bool> ah7 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 3, Order));
                    ah7.Wait();
                    ah7.Dispose();

                    AllDraw This = null;
                    bool fou = false;

                    for (int j = 0; ac && HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse != null && j < HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                    {
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 3));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j], Tab));
                        ah2.Wait();
                        ah2.Dispose();
                        if (ac)
                        {
                            This = THIS;
                            fou = Found;
                            Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeHourseIJ(i, j, Order, ref This, ref fou));
                            ah6.Wait();
                            ah6.Dispose();
                            THIS = This;
                            Found = fou;
                            if (Found)
                            {
                                return THIS;
                            }
                        }
                        else
                        {
                            //HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[k].
                            This = THIS;
                            fou = Found;
                            Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah6.Wait();
                            ah6.Dispose();
                            THIS = This;
                            Found = fou;
                            if (Found)
                            {
                                return THIS;
                            }
                        }
                    }
                }
                catch (Exception t) { Log(t); }
                return THIS;
            }
        }
        public AllDraw FoundOfCurrentTableNodeC(int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            object a = new object();
            lock (a)
            {
                try
                {
                    bool ac = false;
                    Task<bool> ah7 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 4, Order));
                    ah7.Wait();
                    ah7.Dispose();

                    AllDraw This = null;
                    bool fou = false;


                    for (int j = 0; ac && CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle != null && j < CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                    {
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 4));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j], Tab));
                        ah2.Wait();
                        ah2.Dispose();
                        if (ac)
                        {
                            This = THIS;
                            fou = Found;
                            Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastleIJ(i, j, Order, ref This, ref fou));
                            ah6.Wait();
                            ah6.Dispose();
                            THIS = This;
                            Found = fou;
                            if (Found)
                            {
                                return THIS;
                            }
                        }
                        else
                        {
                            // CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[k].
                            This = THIS;
                            fou = Found;
                            Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah6.Wait();
                            ah6.Dispose();
                            THIS = This;
                            Found = fou;
                            if (Found)
                            {
                                return THIS;
                            }
                        }
                    }
                }
                catch (Exception t) { Log(t); }
                return THIS;
            }
        }
        public AllDraw FoundOfCurrentTableNodeM(int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            object a = new object();
            lock (a)
            {
                try
                {
                    bool ac = false;
                    Task<bool> ah7 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 5, Order));
                    ah7.Wait();
                    ah7.Dispose();

                    AllDraw This = null;
                    bool fou = false;

                    for (int j = 0; ac && MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister != null && j < MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                    {
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 5));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j], Tab));
                        ah2.Wait();
                        ah2.Dispose();
                        if (ac)
                        {
                            This = THIS;
                            fou = Found;
                            Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeMinisterIJ(i, j, Order, ref This, ref fou));
                            ah6.Wait();
                            ah6.Dispose();
                            THIS = This;
                            Found = fou;
                            if (Found)
                            {
                                return THIS;
                            }
                        }
                        else
                        {
                            //MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[k].
                            This = THIS;
                            fou = Found;
                            Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah6.Wait();
                            ah6.Dispose();
                            THIS = This;
                            Found = fou;
                            if (Found)
                            {
                                return THIS;
                            }
                        }
                    }
                }
                catch (Exception t) { Log(t); }
                return THIS;
            }
        }
        public AllDraw FoundOfCurrentTableNodeK(int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            object a = new object();
            lock (a)
            {

                try
                {
                    bool ac = false;
                    Task<bool> ah7 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 6, Order));
                    ah7.Wait();
                    ah7.Dispose();

                    AllDraw This = null;
                    bool fou = false;

                    for (int j = 0; ac && KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum[0] != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing != null && j < KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                    {
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 6));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j], Tab));
                        ah2.Wait();
                        ah2.Dispose();
                        if (ac)
                        {
                            This = THIS;
                            fou = Found;
                            Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeKingIJ(i, j, Order, ref This, ref fou));
                            ah6.Wait();
                            ah6.Dispose();
                            THIS = This;
                            Found = fou;
                            if (Found)
                            {
                                return THIS;
                            }
                        }
                        else
                        {
                            //KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[k].
                            This = THIS;
                            fou = Found;
                            Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah6.Wait();
                            ah6.Dispose();
                            THIS = This;
                            Found = fou;
                            if (Found)
                            {
                                return THIS;
                            }
                        }
                    }
                }
                catch (Exception t) { Log(t); }
                return THIS;
            }
        }
        public AllDraw FoundOfCurrentTableNodeA(int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            object a = new object();
            lock (a)
            {
                try
                {
                    bool ac = false;
                    Task<bool> ah7 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 7, Order));
                    ah7.Wait();
                    ah7.Dispose();

                    AllDraw This = null;
                    bool fou = false;


                    for (int j = 0; ac && CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                    {
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 7));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j], Tab));
                        ah2.Wait();
                        ah2.Dispose();
                        if (ac)
                        {
                            This = THIS;
                            fou = Found;
                            Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastlingIJ(i, j, Order, ref This, ref fou));
                            ah6.Wait();
                            ah6.Dispose();
                            THIS = This;
                            Found = fou;
                            if (Found)
                            {
                                return THIS;
                            }
                        }
                        else
                        {
                            //CastlingOnTable[i].CastlingThinking[0].AStarGreedy[k].
                            This = THIS;
                            fou = Found;
                            Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah6.Wait();
                            ah6.Dispose();
                            THIS = This;
                            Found = fou;
                            if (Found)
                            {
                                return THIS;
                            }
                        }
                    }
                }
                catch (Exception t) { Log(t); }
                return THIS;
            }
        }
        public AllDraw FoundOfCurrentTableNodeCreateAStarGreedy(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            object a = new object();
            lock (a)
            {
                bool ac = false;
                AllDraw This = THIS;
                bool fou = Found;
                //else Gray
                if (Order == 1)
                {
                    //soldier
                    for (int i = 0; i < SodierMidle; i++)
                    {
                        for (int j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder != null && j < SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                        {
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 1));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                continue;
                            }

                            Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeSolderIJ(i, j, Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                            else
                            {
                                //SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                        }
                    }
                    //elephant
                    for (int i = 0; i < ElefantMidle; i++)
                    {
                        for (int j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant != null && j < ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                        {
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 2));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                continue;
                            }

                            Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeElephantIJ(i, j, Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                            else
                            {
                                //ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                        }
                    }
                    //hourse
                    for (int i = 0; i < HourseMidle; i++)
                    {
                        for (int j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse != null && j < HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                        {
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 3));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                continue;
                            }

                            Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeHourseIJ(i, j, Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                            else
                            {
                                //HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                        }
                    }
                    //Castle
                    for (int i = 0; i < CastleMidle; i++)
                    {
                        for (int j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle != null && j < CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                        {
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 4));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                continue;
                            }

                            Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastleIJ(i, j, Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                            else
                            {
                                // CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                        }
                    }
                    //minster
                    for (int i = 0; i < MinisterMidle; i++)
                    {
                        for (int j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister != null && j < MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                        {
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 5));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                continue;
                            }

                            Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeMinisterIJ(i, j, Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                            else
                            {
                                //MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                        }
                    }
                    //king
                    for (int i = 0; i < KingMidle; i++)
                    {
                        for (int j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum[0] != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing != null && j < KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                        {
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 6));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                continue;
                            }

                            Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeKingIJ(i, j, Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                            else
                            {
                                //KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                        }
                    }
                    for (int i = 0; i < 1; i++)
                    {
                        for (int j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 7));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                continue;
                            }

                            Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastlingIJ(i, j, Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                            else
                            {
                                //CastlingOnTable[i].CastlingThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                        }
                    }
                }//Brown
                else
                {
                    //soldier
                    for (int i = SodierMidle; i < SodierHigh; i++)
                    {
                        for (int j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder != null && j < SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                        {
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 1));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                continue;
                            }

                            Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeSolderIJ(i, j, Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                            else
                            {
                                //SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                        }
                    }
                    //elephant
                    for (int i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        for (int j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant != null && j < ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                        {
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 2));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                continue;
                            }

                            Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeElephantIJ(i, j, Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                            else
                            {
                                //ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                        }
                    }
                    //hourse
                    for (int i = HourseMidle; i < HourseHight; i++)
                    {
                        for (int j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse != null && j < HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                        {
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 3));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                continue;
                            }

                            Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeHourseIJ(i, j, Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                            else
                            {
                                //HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                        }
                    }
                    //Castle
                    for (int i = CastleMidle; i < CastleHigh; i++)
                    {
                        for (int j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle != null && j < CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                        {
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 4));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                continue;
                            }

                            Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastleIJ(i, j, Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                            else
                            {
                                // CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                        }
                    }
                    //minster
                    for (int i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        for (int j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister != null && j < MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                        {
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 5));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                continue;
                            }

                            Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeMinisterIJ(i, j, Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                            else
                            {
                                //MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                        }
                    }
                    //king
                    for (int i = KingMidle; i < KingHigh; i++)
                    {
                        for (int j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum[0] != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing != null && j < KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                        {
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 6));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                continue;
                            }

                            Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeKingIJ(i, j, Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                            else
                            {
                                //KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                        }
                    }
                    for (int i = 0; i < 1; i++)
                    {
                        for (int j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, -7));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                continue;
                            }

                            Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                Task<bool> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastlingIJ(i, j, Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                            else
                            {
                                //CastlingOnTable[i].CastlingThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                Task<AllDraw> ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                {
                                    return THIS;
                                }
                            }
                        }
                    }
                }
                return THIS;
            }
        }

        //when current level founf of node
        public bool FoundOfCurrentTableNodeFirstLevel(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (!Found)
            {
                AllDraw This = THIS;
                bool fou = Found;
                Task<bool> ah = Task.Factory.StartNew(() => FoundOfCurrentTableNodeSoldeir(CloneATable(Tab), Order, ref This, ref fou));
                ah.Wait();
                ah.Dispose();
            }
            if (!Found)
            {
                AllDraw This = THIS;
                bool fou = Found;
                Task<bool> ah = Task.Factory.StartNew(() => FoundOfCurrentTableNodeElephant(CloneATable(Tab), Order, ref This, ref fou));
                ah.Wait();
                ah.Dispose();
            }
            if (!Found)
            {
                AllDraw This = THIS;
                bool fou = Found;
                Task<bool> ah = Task.Factory.StartNew(() => FoundOfCurrentTableNodeHourse(CloneATable(Tab), Order, ref This, ref fou));
                ah.Wait();
                ah.Dispose();
            }
            if (!Found)
            {
                AllDraw This = THIS;
                bool fou = Found;
                Task<bool> ah = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastle(CloneATable(Tab), Order, ref This, ref fou));
                ah.Wait();
                ah.Dispose();
            }
            if (!Found)
            {
                AllDraw This = THIS;
                bool fou = Found;
                Task<bool> ah = Task.Factory.StartNew(() => FoundOfCurrentTableNodeMinister(CloneATable(Tab), Order, ref This, ref fou));
                ah.Wait();
                ah.Dispose();
            }
            if (!Found)
            {
                AllDraw This = THIS;
                bool fou = Found;
                Task<bool> ah = Task.Factory.StartNew(() => FoundOfCurrentTableNodeKing(CloneATable(Tab), Order, ref This, ref fou));
                ah.Wait();
                ah.Dispose();
            }
            return Found;
        }

        public void ClearAllTablesHeuristicsAndMoreGray(int Order)
        {
            object O = new object();
            lock (O)
            {      //soldier
                for (int i = 0; SolderesOnTable != null && i < SodierMidle; i++)
                {
                    if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count > 0)
                    {
                        for (int j = 0; j < SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                        {
                            //when is not validity
                            Task ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreSoldier(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //elephant
                for (int i = 0; ElephantOnTable != null && i < ElefantMidle; i++)
                {
                    if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count > 0)
                    {
                        for (int j = 0; j < ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                        {
                            //when is not validity
                            Task ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreElephant(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //hourse
                for (int i = 0; HoursesOnTable != null && i < HourseMidle; i++)
                {
                    if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count > 0)
                    {
                        for (int j = 0; j < HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                        {
                            //when is not validity
                            Task ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreHourse(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //Castle
                for (int i = 0; CastlesOnTable != null && i < CastleMidle; i++)
                {
                    if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count > 0)
                    {
                        for (int j = 0; j < CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                        {
                            //when is not validity
                            Task ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreCastle(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //minster
                for (int i = 0; MinisterOnTable != null && i < MinisterMidle; i++)
                {
                    if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count > 0)
                    {
                        for (int j = 0; j < MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                        {
                            //when is not validity
                            Task ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreMinister(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //king
                for (int i = 0; KingOnTable != null && i < KingMidle; i++)
                {
                    if (KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum != null && KingOnTable[i].KingThinkingQuantum[0] != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count > 0)
                    {
                        for (int j = 0; j < KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                        {
                            //when is not validity
                            Task ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreKing(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                for (int i = 0; CastlingOnTable != null && i < 1; i++)
                {
                    if (CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > 0)
                    {
                        for (int j = 0; j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //when is not validity
                            Task ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreCastling(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
            }
        }

        public void ClearAllTablesHeuristicsAndMoreBrown(int Order)
        {
            object O = new object();
            lock (O)
            {          //soldier
                for (int i = SodierMidle; SolderesOnTable != null && i < SodierHigh; i++)
                {
                    if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count > 0)
                    {
                        for (int j = 0; j < SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                        {
                            //when is not validity
                            Task ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreSoldier(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //elephant
                for (int i = ElefantMidle; ElephantOnTable != null && i < ElefantHigh; i++)
                {
                    if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count > 0)
                    {
                        for (int j = 0; j < ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                        {
                            //when is not validity
                            Task ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreElephant(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //hourse
                for (int i = HourseMidle; HoursesOnTable != null && i < HourseHight; i++)
                {
                    if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count > 0)
                    {
                        for (int j = 0; j < HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                        {
                            //when is not validity
                            Task ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreHourse(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //Castle
                for (int i = CastleMidle; CastlesOnTable != null && i < CastleHigh; i++)
                {
                    if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count > 0)
                    {
                        for (int j = 0; j < CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                        {
                            //when is not validity
                            Task ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreCastle(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //minster
                for (int i = MinisterMidle; MinisterOnTable != null && i < MinisterHigh; i++)
                {
                    if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count > 0)
                    {
                        for (int j = 0; j < MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                        {
                            //when is not validity
                            Task ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreMinister(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //king
                for (int i = KingMidle; KingOnTable != null && i < KingHigh; i++)
                {
                    if (KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum != null && KingOnTable[i].KingThinkingQuantum[0] != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count > 0)
                    {
                        for (int j = 0; j < KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                        {
                            //when is not validity
                            Task ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreKing(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                for (int i = 0; CastlingOnTable != null && i < 1; i++)
                {
                    if (CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > 0)
                    {
                        for (int j = 0; j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //when is not validity
                            Task ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreCastling(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
            }
        }

        //clear all non nessaraly nodes of current
        public void ClearAllTablesHeuristicsAndMore(int Order)
        {
            object O = new object();
            lock (O)
            {
                //Gray
                if (Order == 1)
                {
                    Task ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreGray(Order));
                    ah.Wait();
                    ah.Dispose();
                }
                else//Brown
                {
                    Task ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreBrown(Order));
                    ah.Wait();
                    ah.Dispose();
                }
            }
        }
        //When list of alldraw and deeper is not valid clear all lists
        public void ClearAllTablesHeuristicsAndMoreSoldier(int Order, int i, int j)
        {
            object O = new object();
            lock (O)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = IsNonValidityAllTablesHeuristicsAndMore(1, Order, i, j));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    //clear all lists
                    SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Clear();
                    SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder.Clear();
                    SolderesOnTable[i].SoldierThinkingQuantum[0].RowColumnSoldier.Clear();
                    SolderesOnTable[i].SoldierThinkingQuantum[0].PenaltyRegardListSolder.Clear();
                    /*   if (SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count > j)
                       {
                           SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                       }
                       else
                       {
                           SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                       }*/
                    if (SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null)
                    {
                        SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Clear();
                    }
                    else
                    {
                        SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }
                }
            }
        }

        //When list of alldraw and deeper is not valid clear all lists
        public void ClearAllTablesHeuristicsAndMoreElephant(int Order, int i, int j)
        {
            object O = new object();
            lock (O)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = IsNonValidityAllTablesHeuristicsAndMore(2, Order, i, j));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    //clear all lists
                    ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Clear();
                    ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant.Clear();
                    ElephantOnTable[i].ElefantThinkingQuantum[0].RowColumnElefant.Clear();
                    ElephantOnTable[i].ElefantThinkingQuantum[0].PenaltyRegardListElefant.Clear();
                    /*if (ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count > j)
                    {
                        ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    }
                    else
                    {
                        ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }*/
                    if (ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null)
                    {
                        ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Clear();
                    }
                    else
                    {
                        ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }
                }
            }
        }

        //When list of alldraw and deeper is not valid clear all lists
        public void ClearAllTablesHeuristicsAndMoreHourse(int Order, int i, int j)
        {
            object O = new object();
            lock (O)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = IsNonValidityAllTablesHeuristicsAndMore(3, Order, i, j));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    //clear all lists
                    HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Clear();
                    HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse.Clear();
                    HoursesOnTable[i].HourseThinkingQuantum[0].RowColumnHourse.Clear();
                    HoursesOnTable[i].HourseThinkingQuantum[0].PenaltyRegardListHourse.Clear();
                    /* if (HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count > j)
                     {
                         HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                     }
                     else
                     {
                         HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                     }*/
                    if (HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null)
                    {
                        HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Clear();
                    }
                    else
                    {
                        HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }
                }
            }
        }

        //When list of alldraw and deeper is not valid clear all lists
        public void ClearAllTablesHeuristicsAndMoreCastle(int Order, int i, int j)
        {
            object O = new object();
            lock (O)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = IsNonValidityAllTablesHeuristicsAndMore(4, Order, i, j));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    //clear all lists
                    CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Clear();
                    CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle.Clear();
                    CastlesOnTable[i].CastleThinkingQuantum[0].RowColumnCastle.Clear();
                    CastlesOnTable[i].CastleThinkingQuantum[0].PenaltyRegardListCastle.Clear();
                    /*if (CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count > j)
                    {
                        CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    }
                    else
                    {
                        CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }*/
                    if (CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null)
                    {
                        CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Clear();
                    }
                    else
                    {
                        CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }
                }
            }
        }

        //When list of alldraw and deeper is not valid clear all lists
        public void ClearAllTablesHeuristicsAndMoreMinister(int Order, int i, int j)
        {
            object O = new object();
            lock (O)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = IsNonValidityAllTablesHeuristicsAndMore(5, Order, i, j));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    //clear all lists
                    MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Clear();
                    MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister.Clear();
                    MinisterOnTable[i].MinisterThinkingQuantum[0].RowColumnMinister.Clear();
                    MinisterOnTable[i].MinisterThinkingQuantum[0].PenaltyRegardListMinister.Clear();
                    /*if (MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count > j)
                    {
                        MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    }
                    else
                    {
                        MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }*/
                    if (MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null)
                    {
                        MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Clear();
                    }
                    else
                    {
                        MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }
                }
            }
        }

        //When list of alldraw and deeper is not valid clear all lists
        public void ClearAllTablesHeuristicsAndMoreKing(int Order, int i, int j)
        {
            object O = new object();
            lock (O)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = IsNonValidityAllTablesHeuristicsAndMore(6, Order, i, j));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    //clear all lists
                    KingOnTable[i].KingThinkingQuantum[0].TableListKing.Clear();
                    KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing.Clear();
                    KingOnTable[i].KingThinkingQuantum[0].RowColumnKing.Clear();
                    KingOnTable[i].KingThinkingQuantum[0].PenaltyRegardListKing.Clear();
                    /*if (KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count > j)
                    {
                        KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    }
                    else
                    {
                        KingOnTable[i].KingThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }*/
                    if (KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null)
                    {
                        KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Clear();
                    }
                    else
                    {
                        KingOnTable[i].KingThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }
                }
            }
        }

        public void ClearAllTablesHeuristicsAndMoreCastling(int Order, int i, int j)
        {
            object O = new object();
            lock (O)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = IsNonValidityAllTablesHeuristicsAndMore(7, Order, i, j));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    //clear all lists
                    CastlingOnTable[i].CastlingThinking[0].TableListCastling.Clear();
                    CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling.Clear();
                    CastlingOnTable[i].CastlingThinking[0].RowColumnCastling.Clear();
                    CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling.Clear();
                    /*if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j)
                    {
                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    }
                    else
                    {
                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy = new List<AllDraw>();
                    }*/
                    if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null)
                    {
                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Clear();
                    }
                    else
                    {
                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy = new List<AllDraw>();
                    }
                }
            }
        }


        //when there is a colision in lists of current return true and remove extra lists
        private bool A_B_C_D_E_ISNonEqual(int a, int b, int c, int d, int e, int f, int m, int n, int k, int o, int l, int p, int q, int r, int s, int i, int j, int Kind)
        {
            bool Is = false;
            //when deeper is grater and is not empty
            if (e > a && e != -1)
            {
                //soldier
                if (Kind == 1)
                {
                    //remove extra
                    for (int h = a; h < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; h++)
                    {
                        SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.RemoveAt(h);
                    }
                }
                else//elephant
                    if (Kind == 2)
                {
                    //remove extra
                    for (int h = a; h < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; h++)
                    {
                        ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.RemoveAt(h);
                    }
                }
                else//hourse
                    if (Kind == 3)
                {
                    //remove extra
                    for (int h = a; h < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; h++)
                    {
                        HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.RemoveAt(h);
                    }
                }
                else//Castle
                    if (Kind == 4)
                {
                    //remove extra
                    for (int h = a; h < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; h++)
                    {
                        CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.RemoveAt(h);
                    }
                }
                else//minster
                    if (Kind == 5)
                {
                    //remove extra
                    for (int h = a; h < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; h++)
                    {
                        MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.RemoveAt(h);
                    }
                }
                else//king
                    if (Kind == 6)
                {
                    //remove extra
                    for (int h = a; h < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; h++)
                    {
                        KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.RemoveAt(h);
                    }
                }
                else//king
                         if (Kind == 7 || Kind == -7)
                {
                    //remove extra
                    for (int h = a; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; h++)
                    {
                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy.RemoveAt(h);
                    }
                }
            }
            //when therse is collision in lists number return true
            if ((!(a == b && b == c && c == d && d == f && f == m && m == n && n == k && k == l && l == o && o == p && p == r && r == s && s == q)) || j > e || a == 0 || e == 0 || e == -1)
            {
                Is = true;
            }
            //when there is not
            if (!Is)
            {
                //soldier
                if (Kind == 1)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingQuantumChess.TableEqual(SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j]))))
                    {
                        Is = true;
                    }
                }
                else//elephant
                                    if (Kind == 2)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingQuantumChess.TableEqual(ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j]))))
                    {
                        Is = true;
                    }
                }
                else//hourse
                                    if (Kind == 3)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingQuantumChess.TableEqual(HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j]))))
                    {
                        Is = true;
                    }
                }
                else//Castle
                                    if (Kind == 4)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingQuantumChess.TableEqual(CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j]))))
                    {
                        Is = true;
                    }
                }
                else//minster
                                    if (Kind == 5)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingQuantumChess.TableEqual(MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j]))))
                    {
                        Is = true;
                    }
                }
                else//king
                                    if (Kind == 6)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingQuantumChess.TableEqual(KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j]))))
                    {
                        Is = true;
                    }
                }
                else//king
                                    if (Kind == 7 || Kind == -7)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingQuantumChess.TableEqual(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList[0], CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]))))
                    {
                        Is = true;
                    }
                }
            }
            return Is;
        }

        //calculation of lists count and call collision methods determinstics
        public bool IsNonValidityAllTablesHeuristicsAndMore(int Kind, int Order, int i, int j)
        {
            /*bool ac = false;
            Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, PlatformHelper.ProcessorCount + AllDraw.StoreInitMaxAStarGreedy - AllDraw.MaxAStarGreedy));
            ah1.Wait();
            ah1.Dispose();
            if (ac)
            {
                return false;
            }*/
            bool Is = true;
            //soldier
            if (Kind == 1)
            {
                //when there is
                if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count;
                    int b = SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder.Count;
                    int c = SolderesOnTable[i].SoldierThinkingQuantum[0].RowColumnSoldier.Count;
                    int d = SolderesOnTable[i].SoldierThinkingQuantum[0].PenaltyRegardListSolder.Count;
                    int f = SolderesOnTable[i].SoldierThinkingQuantum[0].LoseChiled.Count;
                    int h = SolderesOnTable[i].SoldierThinkingQuantum[0].HitNumberSoldier.Count;
                    int n = SolderesOnTable[i].SoldierThinkingQuantum[0].WinChiled.Count;
                    int m = SolderesOnTable[i].SoldierThinkingQuantum[0].IsSup.Count;
                    int o = SolderesOnTable[i].SoldierThinkingQuantum[0].IsSupHu.Count;
                    int l = SolderesOnTable[i].SoldierThinkingQuantum[0].IsThereCheckOfEnemy.Count;
                    int p = SolderesOnTable[i].SoldierThinkingQuantum[0].IsThereCheckOfSelf.Count;
                    int q = SolderesOnTable[i].SoldierThinkingQuantum[0].IsThereMateOfEnemy.Count;
                    int r = SolderesOnTable[i].SoldierThinkingQuantum[0].IsThereMateOfSelf.Count;
                    int s = SolderesOnTable[i].SoldierThinkingQuantum[0].KillerAtThinking.Count;
                    int e = 0;
                    if (SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy == null || SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count <= j)
                    {
                        e = -1;
                    }
                    else
                    {
                        if (SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j] == null)
                        {
                            e = -1;
                        }
                        else
                        {
                            e = SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count;
                        }
                    }

                    Task<bool> ah = Task.Factory.StartNew(() => Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, f, h, n, m, o, l, p, q, r, s, i, j, 1));
                    ah.Wait();
                    ah.Dispose();
                    /*if (!Is)
                    {
                        if (CheckeHuristci(CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j]), Order, 1))
                        {
                            SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.RemoveAt(j);
                            SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder.RemoveAt(j);
                            SolderesOnTable[i].SoldierThinkingQuantum[0].RowColumnSoldier.RemoveAt(j);
                            SolderesOnTable[i].SoldierThinkingQuantum[0].PenaltyRegardListSolder.RemoveAt(j);
                            SolderesOnTable[i].SoldierThinkingQuantum[0].LoseChiled.RemoveAt(j);
                            SolderesOnTable[i].SoldierThinkingQuantum[0].HitNumberSoldier.RemoveAt(j);
                            SolderesOnTable[i].SoldierThinkingQuantum[0].WinChiled.RemoveAt(j);
                            if (e >= j)
                            {
                                ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.RemoveAt(j);
                            }
                        }

                    }*/
                }
            }
            else if (Kind == 2)
            {
                //when there is
                if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count;
                    int b = ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant.Count;
                    int c = ElephantOnTable[i].ElefantThinkingQuantum[0].RowColumnElefant.Count;
                    int d = ElephantOnTable[i].ElefantThinkingQuantum[0].PenaltyRegardListElefant.Count;
                    int f = ElephantOnTable[i].ElefantThinkingQuantum[0].LoseChiled.Count;
                    int h = ElephantOnTable[i].ElefantThinkingQuantum[0].HitNumberElefant.Count;
                    int n = ElephantOnTable[i].ElefantThinkingQuantum[0].WinChiled.Count;
                    int m = ElephantOnTable[i].ElefantThinkingQuantum[0].IsSup.Count;
                    int o = ElephantOnTable[i].ElefantThinkingQuantum[0].IsSupHu.Count;
                    int l = ElephantOnTable[i].ElefantThinkingQuantum[0].IsThereCheckOfEnemy.Count;
                    int p = ElephantOnTable[i].ElefantThinkingQuantum[0].IsThereCheckOfSelf.Count;
                    int q = ElephantOnTable[i].ElefantThinkingQuantum[0].IsThereMateOfEnemy.Count;
                    int r = ElephantOnTable[i].ElefantThinkingQuantum[0].IsThereMateOfSelf.Count;
                    int s = ElephantOnTable[i].ElefantThinkingQuantum[0].KillerAtThinking.Count;
                    int e = 0;
                    if (ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy == null || ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count <= j)
                    {
                        e = -1;
                    }
                    else
                    {
                        if (ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j] == null)
                        {
                            e = -1;
                        }
                        else
                        {
                            e = ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count;
                        }
                    }

                    Task<bool> ah = Task.Factory.StartNew(() => Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, f, h, n, m, o, l, p, q, r, s, i, j, 2));
                    ah.Wait();
                    ah.Dispose();
                    /*if (!Is)
                    {
                        if (CheckeHuristci(CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j]), Order, 1))
                        {
                            ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.RemoveAt(j);
                            ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant.RemoveAt(j);
                            ElephantOnTable[i].ElefantThinkingQuantum[0].RowColumnElefant.RemoveAt(j);
                            ElephantOnTable[i].ElefantThinkingQuantum[0].PenaltyRegardListElefant.RemoveAt(j);
                            ElephantOnTable[i].ElefantThinkingQuantum[0].LoseChiled.RemoveAt(j);
                            ElephantOnTable[i].ElefantThinkingQuantum[0].HitNumberSoldier.RemoveAt(j);
                            ElephantOnTable[i].ElefantThinkingQuantum[0].WinChiled.RemoveAt(j);
                            if (e >= j)
                            {
                                ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.RemoveAt(j);
                            }
                        }

                    }*/
                }
            }
            else if (Kind == 3)
            {
                //when there is
                if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count;
                    int b = HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse.Count;
                    int c = HoursesOnTable[i].HourseThinkingQuantum[0].RowColumnHourse.Count;
                    int d = HoursesOnTable[i].HourseThinkingQuantum[0].PenaltyRegardListHourse.Count;
                    int f = HoursesOnTable[i].HourseThinkingQuantum[0].LoseChiled.Count;
                    int h = HoursesOnTable[i].HourseThinkingQuantum[0].HitNumberHourse.Count;
                    int n = HoursesOnTable[i].HourseThinkingQuantum[0].WinChiled.Count;
                    int m = CastlesOnTable[i].CastleThinkingQuantum[0].IsSup.Count;
                    int o = CastlesOnTable[i].CastleThinkingQuantum[0].IsSupHu.Count;
                    int l = CastlesOnTable[i].CastleThinkingQuantum[0].IsThereCheckOfEnemy.Count;
                    int p = CastlesOnTable[i].CastleThinkingQuantum[0].IsThereCheckOfSelf.Count;
                    int q = CastlesOnTable[i].CastleThinkingQuantum[0].IsThereMateOfEnemy.Count;
                    int r = CastlesOnTable[i].CastleThinkingQuantum[0].IsThereMateOfSelf.Count;
                    int s = CastlesOnTable[i].CastleThinkingQuantum[0].KillerAtThinking.Count;
                    int e = 0;
                    if (HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy == null || HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count <= j)
                    {
                        e = -1;
                    }
                    else
                    {
                        if (HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j] == null)
                        {
                            e = -1;
                        }
                        else
                        {
                            e = HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count;
                        }
                    }

                    Task<bool> ah = Task.Factory.StartNew(() => Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, f, h, n, m, o, l, p, q, r, s, i, j, 3));
                    ah.Wait();
                    ah.Dispose();
                    /*if (!Is)
                    {
                        if (CheckeHuristci(CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j]), Order, 1))
                        {
                            HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.RemoveAt(j);
                            HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse.RemoveAt(j);
                            HoursesOnTable[i].HourseThinkingQuantum[0].RowColumnHourse.RemoveAt(j);
                            HoursesOnTable[i].HourseThinkingQuantum[0].PenaltyRegardListHourse.RemoveAt(j);
                            HoursesOnTable[i].HourseThinkingQuantum[0].LoseChiled.RemoveAt(j);
                            HoursesOnTable[i].HourseThinkingQuantum[0].HitNumberHourse.RemoveAt(j);
                            HoursesOnTable[i].HourseThinkingQuantum[0].WinChiled.RemoveAt(j);
                            if (e >= j)
                            {
                                HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.RemoveAt(j);
                            }
                        }

                    }*/
                }
            }
            else if (Kind == 4)
            {
                //when there is
                if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count;
                    int b = CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle.Count;
                    int c = CastlesOnTable[i].CastleThinkingQuantum[0].RowColumnCastle.Count;
                    int d = CastlesOnTable[i].CastleThinkingQuantum[0].PenaltyRegardListCastle.Count;
                    int f = CastlesOnTable[i].CastleThinkingQuantum[0].LoseChiled.Count;
                    int h = CastlesOnTable[i].CastleThinkingQuantum[0].HitNumberCastle.Count;
                    int n = CastlesOnTable[i].CastleThinkingQuantum[0].WinChiled.Count;
                    int m = CastlesOnTable[i].CastleThinkingQuantum[0].IsSup.Count;
                    int o = CastlesOnTable[i].CastleThinkingQuantum[0].IsSupHu.Count;
                    int l = CastlesOnTable[i].CastleThinkingQuantum[0].IsThereCheckOfEnemy.Count;
                    int p = CastlesOnTable[i].CastleThinkingQuantum[0].IsThereCheckOfSelf.Count;
                    int q = CastlesOnTable[i].CastleThinkingQuantum[0].IsThereMateOfEnemy.Count;
                    int r = CastlesOnTable[i].CastleThinkingQuantum[0].IsThereMateOfSelf.Count;
                    int s = CastlesOnTable[i].CastleThinkingQuantum[0].KillerAtThinking.Count;
                    int e = 0;
                    if (CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy == null || CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count <= j)
                    {
                        e = -1;
                    }
                    else
                    {
                        if (CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j] == null)
                        {
                            e = -1;
                        }
                        else
                        {
                            e = CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count;
                        }
                    }
                    //if (a == b && b == c && d == c && a > 0)
                    Task<bool> ah = Task.Factory.StartNew(() => Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, f, h, n, m, o, l, p, q, r, s, i, j, 4));
                    ah.Wait();
                    ah.Dispose();
                    /*if (!Is)
                    {
                        if (CheckeHuristci(CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j]), Order, 1))
                        {
                            CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.RemoveAt(j);
                            CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle.RemoveAt(j);
                            CastlesOnTable[i].CastleThinkingQuantum[0].RowColumnCastle.RemoveAt(j);
                            CastlesOnTable[i].CastleThinkingQuantum[0].PenaltyRegardListCastle.RemoveAt(j);
                            CastlesOnTable[i].CastleThinkingQuantum[0].LoseChiled.RemoveAt(j);
                            CastlesOnTable[i].CastleThinkingQuantum[0].HitNumberCastle.RemoveAt(j);
                            CastlesOnTable[i].CastleThinkingQuantum[0].WinChiled.RemoveAt(j);
                            if (e >= j)
                            {
                                CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.RemoveAt(j);
                            }
                        }

                    }*/
                }
            }
            else if (Kind == 5)
            {
                //when there is
                if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count;
                    int b = MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister.Count;
                    int c = MinisterOnTable[i].MinisterThinkingQuantum[0].RowColumnMinister.Count;
                    int d = MinisterOnTable[i].MinisterThinkingQuantum[0].PenaltyRegardListMinister.Count;
                    int f = MinisterOnTable[i].MinisterThinkingQuantum[0].LoseChiled.Count;
                    int h = MinisterOnTable[i].MinisterThinkingQuantum[0].HitNumberMinister.Count;
                    int n = MinisterOnTable[i].MinisterThinkingQuantum[0].WinChiled.Count;
                    int m = MinisterOnTable[i].MinisterThinkingQuantum[0].IsSup.Count;
                    int o = MinisterOnTable[i].MinisterThinkingQuantum[0].IsSupHu.Count;
                    int l = MinisterOnTable[i].MinisterThinkingQuantum[0].IsThereCheckOfEnemy.Count;
                    int p = MinisterOnTable[i].MinisterThinkingQuantum[0].IsThereCheckOfSelf.Count;
                    int q = MinisterOnTable[i].MinisterThinkingQuantum[0].IsThereMateOfEnemy.Count;
                    int r = MinisterOnTable[i].MinisterThinkingQuantum[0].IsThereMateOfSelf.Count;
                    int s = MinisterOnTable[i].MinisterThinkingQuantum[0].KillerAtThinking.Count;
                    int e = 0;
                    if (MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy == null || MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count <= j)
                    {
                        e = -1;
                    }
                    else
                    {
                        if (MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j] == null)
                        {
                            e = -1;
                        }
                        else
                        {
                            e = MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count;
                        }
                    }

                    Task<bool> ah = Task.Factory.StartNew(() => Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, f, h, n, m, o, l, p, q, r, s, i, j, 5));
                    ah.Wait();
                    ah.Dispose();
                    /* if (!Is)
                     {
                         if (CheckeHuristci(CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j]), Order, 1))
                         {
                             MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.RemoveAt(j);
                             MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister.RemoveAt(j);
                             MinisterOnTable[i].MinisterThinkingQuantum[0].RowColumnMinister.RemoveAt(j);
                             MinisterOnTable[i].MinisterThinkingQuantum[0].PenaltyRegardListMinister.RemoveAt(j);
                             MinisterOnTable[i].MinisterThinkingQuantum[0].LoseChiled.RemoveAt(j);
                             MinisterOnTable[i].MinisterThinkingQuantum[0].HitNumberMinister.RemoveAt(j);
                             MinisterOnTable[i].MinisterThinkingQuantum[0].WinChiled.RemoveAt(j);
                             if (e >= j)
                             {
                                 MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.RemoveAt(j);
                             }
                         }

                     }*/
                }
            }
            else if (Kind == 6)
            {
                //when there is
                if (KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum != null && KingOnTable[i].KingThinkingQuantum[0] != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count;
                    int b = KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing.Count;
                    int c = KingOnTable[i].KingThinkingQuantum[0].RowColumnKing.Count;
                    int d = KingOnTable[i].KingThinkingQuantum[0].PenaltyRegardListKing.Count;
                    int f = KingOnTable[i].KingThinkingQuantum[0].LoseChiled.Count;
                    int h = KingOnTable[i].KingThinkingQuantum[0].HitNumberKing.Count;
                    int n = KingOnTable[i].KingThinkingQuantum[0].WinChiled.Count;
                    int m = KingOnTable[i].KingThinkingQuantum[0].IsSup.Count;
                    int o = KingOnTable[i].KingThinkingQuantum[0].IsSupHu.Count;
                    int l = KingOnTable[i].KingThinkingQuantum[0].IsThereCheckOfEnemy.Count;
                    int p = KingOnTable[i].KingThinkingQuantum[0].IsThereCheckOfSelf.Count;
                    int q = KingOnTable[i].KingThinkingQuantum[0].IsThereMateOfEnemy.Count;
                    int r = KingOnTable[i].KingThinkingQuantum[0].IsThereMateOfSelf.Count;
                    int s = KingOnTable[i].KingThinkingQuantum[0].KillerAtThinking.Count;
                    int e = 0;
                    if (KingOnTable[i].KingThinkingQuantum[0].AStarGreedy == null || KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count <= j)
                    {
                        e = -1;
                    }
                    else
                    {
                        if (KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j] == null)
                        {
                            e = -1;
                        }
                        else
                        {
                            e = KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count;
                        }
                    }

                    Task<bool> ah = Task.Factory.StartNew(() => Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, f, h, n, m, o, l, p, q, r, s, i, j, 6));
                    ah.Wait();
                    ah.Dispose();
                    /*if (!Is)
                    {
                        if (CheckeHuristci(CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j]), Order, 1))
                        {
                            KingOnTable[i].KingThinkingQuantum[0].TableListKing.RemoveAt(j);
                            KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing.RemoveAt(j);
                            KingOnTable[i].KingThinkingQuantum[0].RowColumnKing.RemoveAt(j);
                            KingOnTable[i].KingThinkingQuantum[0].PenaltyRegardListKing.RemoveAt(j);
                            KingOnTable[i].KingThinkingQuantum[0].LoseChiled.RemoveAt(j);
                            KingOnTable[i].KingThinkingQuantum[0].HitNumberKing.RemoveAt(j);
                            KingOnTable[i].KingThinkingQuantum[0].WinChiled.RemoveAt(j);
                            if (e >= j)
                            {
                                KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.RemoveAt(j);
                            }
                        }

                    }*/
                }
            }
            else if (Kind == 7 || Kind == -7)
            {
                //when there is
                if (CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count;
                    int b = CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling.Count;
                    int c = CastlingOnTable[i].CastlingThinking[0].RowColumnCastling.Count;
                    int d = CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling.Count;
                    int f = CastlingOnTable[i].CastlingThinking[0].LoseChiled.Count;
                    int h = CastlingOnTable[i].CastlingThinking[0].HitNumberCastling.Count;
                    int n = CastlingOnTable[i].CastlingThinking[0].WinChiled.Count;
                    int m = CastlingOnTable[i].CastlingThinking[0].IsSup.Count;
                    int o = CastlingOnTable[i].CastlingThinking[0].IsSupHu.Count;
                    int l = CastlingOnTable[i].CastlingThinking[0].IsThereCheckOfEnemy.Count;
                    int p = CastlingOnTable[i].CastlingThinking[0].IsThereCheckOfSelf.Count;
                    int q = CastlingOnTable[i].CastlingThinking[0].IsThereMateOfEnemy.Count;
                    int r = CastlingOnTable[i].CastlingThinking[0].IsThereMateOfSelf.Count;
                    int s = CastlingOnTable[i].CastlingThinking[0].KillerAtThinking.Count;
                    int e = 0;
                    if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy == null || CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count <= j)
                    {
                        e = -1;
                    }
                    else
                    {
                        if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j] == null)
                        {
                            e = -1;
                        }
                        else
                        {
                            e = CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count;
                        }
                    }

                    Task<bool> ah = Task.Factory.StartNew(() => Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, f, h, n, m, o, l, p, q, r, s, i, j, 7));
                    ah.Wait();
                    ah.Dispose();
                    /*if (!Is)
                    {
                        if (CheckeHuristci(CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]), Order, 1))
                        {
                            CastlingOnTable[i].CastlingThinking[0].TableListCastling.RemoveAt(j);
                            CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling.RemoveAt(j);
                            CastlingOnTable[i].CastlingThinking[0].RowColumnCastling.RemoveAt(j);
                            CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling.RemoveAt(j);
                            CastlingOnTable[i].CastlingThinking[0].LoseChiled.RemoveAt(j);
                            CastlingOnTable[i].CastlingThinking[0].HitNumberCastling.RemoveAt(j);
                            CastlingOnTable[i].CastlingThinking[0].WinChiled.RemoveAt(j);
                            if (e >= j)
                            {
                                CastlingOnTable[i].CastlingThinking[0].AStarGreedy.RemoveAt(j);
                            }
                        }

                    }*/
                }
            }
            return (Is);
        }

        public bool FoundOfCurrentTableNodeSolderIJ(int i, int j, int Order, ref AllDraw THIS, ref bool Found)
        {
            //if (IsSupHuTrue(i, j, 1))

            //when is null creation enough but empty and create deeper node
            if (SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count == 0)
            {
                for (int h = 0; h <= j; h++)
                //satisfied of created deeper three
                {
                    Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 1));
                    ah.Wait();
                    ah.Dispose();
                }
                SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].TableList.Clear();
                SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].TableList.Add(CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j]));
                SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].SetRowColumn(0);
                SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                                    if (SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count < j + 1)
            {
                for (int h = SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; h <= j; h++)
                //satisfied of created deeper three
                {
                    Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 1));
                    ah.Wait();
                    ah.Dispose();
                }
                SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].TableList.Clear();
                SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].TableList.Add(CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j]));
                SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].SetRowColumn(0);
                SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count > j)
                {
                    THIS = SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }

        //determine about found of equality of lists of current alldraw and call determinition of deeper
        public bool FoundOfCurrentTableNodeSoldeir(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; SolderesOnTable != null && i < SodierMidle; i++)
                {
                    FoundOfCurrentTableNodeSoldeirBase(i, Tab, Order, ref THIS, ref Found);
                }
            }
            else
            {
                for (int i = SodierMidle; SolderesOnTable != null && i < SodierHigh; i++)
                {
                    FoundOfCurrentTableNodeSoldeirBase(i, Tab, Order, ref THIS, ref Found);
                }
            }
            return Found;
        }

        public bool FoundOfCurrentTableNodeSoldeirBase(int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {

            try
            {
                for (int j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count > j; j++)
                {
                    bool ac = false;
                    Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 1));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                    {
                        continue;
                    }

                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j], Tab));
                    ah1.Wait();
                    ah1.Dispose();
                    FoundOfCurrentTableNodeSoldeirBaseKernel(ac, j, i, Tab, Order, ref THIS, ref Found);
                    if (Found)
                    {
                        return Found;
                    }
                }
            }
            catch (Exception t) { Log(t); }

            return Found;
        }
        public bool FoundOfCurrentTableNodeSoldeirBaseKernel(bool ac,int j, int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {

            if (ac)
            {
                AllDraw This = THIS;
                bool fou = Found;
                Task<bool> ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeSolderIJ(i, j, Order, ref This, ref fou));
                ah2.Wait();
                ah2.Dispose();
                Found = fou;
                THIS = This;
                if (Found)
                {
                    return Found;
                }
            }
            return Found;
        }
        //Creation Table and deeper when there is not deeper or there is
        public bool FoundOfCurrentTableNodeElephantIJ(int i, int j, int Order, ref AllDraw THIS, ref bool Found)
        {
            //if (IsSupHuTrue(i, j, 2))

            //when is null creation enough but empty and create deeper node
            if (ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count == 0)
            {
                for (int h = 0; h <= j; h++)
                //satisfied of created deeper three
                {
                    Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 2));
                    ah.Wait();
                    ah.Dispose();
                }
                ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].TableList.Clear();
                ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].TableList.Add(CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j]));
                ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].SetRowColumn(0);
                ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                                    if (ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count < j + 1)
            {
                for (int h = ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; h <= j; h++)
                //satisfied of created deeper three
                {
                    Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 2));
                    ah.Wait();
                    ah.Dispose();
                }
                ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].TableList.Clear();
                ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].TableList.Add(CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j]));
                ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].SetRowColumn(0);
                ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count > j)
                {
                    THIS = ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }

        //determine about found of equality of lists of current alldraw and call determinition of deeper
        public bool FoundOfCurrentTableNodeElephant(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; ElephantOnTable != null && i < ElefantMidle; i++)
                {
                    FoundOfCurrentTableNodeElephantBase(i,Tab, Order, ref THIS, ref Found);
                }
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
            {
                for (int i = ElefantMidle; ElephantOnTable != null && i < ElefantHigh; i++)
                {
                    FoundOfCurrentTableNodeElephantBase(i, Tab, Order, ref THIS, ref Found);
                }
            }
            return Found;
        }

        public bool FoundOfCurrentTableNodeElephantBase(int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {

            try
            {
                for (int j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count > j; j++)
                {
                    bool ac = false;
                    Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 2));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                    {
                        continue;
                    }

                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j], Tab));
                    ah1.Wait();
                    ah1.Dispose();
                    FoundOfCurrentTableNodeElephantBaseKernel(ac, j, i, Tab, Order, ref THIS, ref Found);
                    if (Found)
                    {
                        return Found;
                    }
                }
            }
            catch (Exception t)
            {
                Log(t);
            }
            return Found;
        }
        public bool FoundOfCurrentTableNodeElephantBaseKernel(bool ac,int j, int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {

 
                if (ac)
                {
                    AllDraw This = THIS;
                    bool fou = Found;
                    Task<bool> ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeElephantIJ(i, j, Order, ref This, ref fou));
                    ah2.Wait();
                    ah2.Dispose();
                    Found = fou;
                    THIS = This;
                    if (Found)
                    {
                        return Found;
                    }
                }
              return Found;
        }
        //Creation Table and deeper when there is not deeper or there is
        public bool FoundOfCurrentTableNodeHourseIJ(int i, int j, int Order, ref AllDraw THIS, ref bool Found)
        {
            //if (IsSupHuTrue(i, j, 3))

            //when is null creation enough but empty and create deeper node
            if (HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count == 0)
            {
                for (int h = 0; h <= j; h++)
                //satisfied of created deeper three
                {
                    Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 3));
                    ah.Wait();
                    ah.Dispose();
                }
                HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].TableList.Clear();
                HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].TableList.Add(CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j]));
                HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].SetRowColumn(0);
                HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                                   if (HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count < j + 1)
            {
                for (int h = HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; h <= j; h++)
                //satisfied of created deeper three
                {
                    Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 3));
                    ah.Wait();
                    ah.Dispose();
                }
                HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].TableList.Clear();
                HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].TableList.Add(CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j]));
                HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].SetRowColumn(0);
                HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count > j)
                {
                    THIS = HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }

        //determine about found of equality of lists of current alldraw and call determinition of deeper
        public bool FoundOfCurrentTableNodeHourse(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; HoursesOnTable != null && i < ElefantMidle; i++)
                {
                    FoundOfCurrentTableNodeHourseBase(i, Tab, Order, ref THIS, ref Found);
                }
            }

            else
            {
                for (int i = HourseMidle; HoursesOnTable != null && i < HourseHight; i++)
                {
                    FoundOfCurrentTableNodeHourseBase(i, Tab, Order, ref THIS, ref Found);
                }
            }
            return Found;
        }

        public bool FoundOfCurrentTableNodeHourseBase(int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {

            try
            {
                for (int j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count > j; j++)
                {
                    bool ac = false;
                    Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 3));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                    {
                        continue;
                    }

                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j], Tab));
                    ah1.Wait();
                    ah1.Dispose();
                    FoundOfCurrentTableNodeHourseBaseKernel(ac, j, i, Tab, Order, ref THIS, ref Found);
                    if (Found)
                    {
                        return Found;
                    }
                }

            }
            catch (Exception t) { Log(t); }
            return Found;
        }
        public bool FoundOfCurrentTableNodeHourseBaseKernel(bool ac,int j, int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {

            if (ac)
            {
                AllDraw This = THIS;
                bool fou = Found;
                Task<bool> ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeHourseIJ(i, j, Order, ref This, ref fou));
                ah2.Wait();
                ah2.Dispose();
                Found = fou;
                THIS = This;
                if (Found)
                {
                    return Found;
                }
            }

            return Found;
        }
        //Creation Table and deeper when there is not deeper or there is
        public bool FoundOfCurrentTableNodeCastleIJ(int i, int j, int Order, ref AllDraw THIS, ref bool Found)
        {
            //if (IsSupHuTrue(i, j, 4))

            //when is null creation enough but empty and create deeper node
            if (CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count == 0)
            {
                for (int h = 0; h <= j; h++)
                //satisfied of created deeper three
                {
                    Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 4));
                    ah.Wait();
                    ah.Dispose();
                }
                CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].TableList.Clear();
                CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].TableList.Add(CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j]));
                CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].SetRowColumn(0);
                CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                      if (CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count < j + 1)
            {
                for (int h = CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; h <= j; h++)
                //satisfied of created deeper three
                {
                    Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 4));
                    ah.Wait();
                    ah.Dispose();
                }
                CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].TableList.Clear();
                CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].TableList.Add(CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j]));
                CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].SetRowColumn(0);
                CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count > j)
                {
                    THIS = CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }

        //determine about found of equality of lists of current alldraw and call determinition of deeper
        public bool FoundOfCurrentTableNodeCastle(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; CastlesOnTable != null && i < CastleMidle; i++)
                {
                    FoundOfCurrentTableNodeCastleBase(i, Tab, Order, ref THIS, ref Found);
                }
            }
            else
            {
                for (int i = CastleMidle; CastlesOnTable != null && i < CastleHigh; i++)
                {
                    FoundOfCurrentTableNodeCastleBase(i, Tab, Order, ref THIS, ref Found);
                }
            }
            return Found;
        }

        public bool FoundOfCurrentTableNodeCastleBase(int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {

            try
            {
                for (int j = 0; CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count > j; j++)
                {
                    bool ac = false;
                    Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 4));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                    {
                        continue;
                    }

                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j], Tab));
                    ah1.Wait();
                    ah1.Dispose();
                    FoundOfCurrentTableNodeCastleBaseKernel(ac, j, i, Tab, Order, ref THIS, ref Found);
                    if (Found)
                    {
                        return Found;
                    }
                }

            }
            catch (Exception t) { Log(t); }
            return Found;
        }
        public bool FoundOfCurrentTableNodeCastleBaseKernel(bool ac,int j, int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (ac)
            {
                AllDraw This = THIS;
                bool fou = Found;
                Task<bool> ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastleIJ(i, j, Order, ref This, ref fou));
                ah2.Wait();
                ah2.Dispose();
                Found = fou;
                THIS = This;
                if (Found)
                {
                    return Found;
                }
            }
            return Found;
        }
        //Creation Table and deeper when there is not deeper or there is
        public bool FoundOfCurrentTableNodeMinisterIJ(int i, int j, int Order, ref AllDraw THIS, ref bool Found)
        {
            //if (IsSupHuTrue(i, j, 5))

            //when is null creation enough but empty and create deeper node
            if (MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count == 0)
            {
                for (int h = 0; h <= j; h++)
                //satisfied of created deeper three
                {
                    Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 5));
                    ah.Wait();
                    ah.Dispose();
                }
                MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].TableList.Clear();
                MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].TableList.Add(CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j]));
                MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].SetRowColumn(0);
                MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                                    if (MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count < j + 1)
            {
                for (int h = MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; h <= j; h++)
                //satisfied of created deeper three
                {
                    Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 5));
                    ah.Wait();
                    ah.Dispose();
                }
                MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].TableList.Clear();
                MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].TableList.Add(CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j]));
                MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].SetRowColumn(0);
                MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count > j)
                {
                    THIS = MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }

        //determine about found of equality of lists of current alldraw and call determinition of deeper
        public bool FoundOfCurrentTableNodeMinister(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; MinisterOnTable != null && i < MinisterMidle; i++)
                {
                    FoundOfCurrentTableNodeMinisterBase(i, Tab, Order, ref THIS, ref Found);
                }
            }
            else
            {
                for (int i = MinisterMidle; MinisterOnTable != null && i < MinisterHigh; i++)
                {
                    FoundOfCurrentTableNodeMinisterBase(i, Tab, Order, ref THIS, ref Found);
                }
            }
            return Found;
        }

        public bool FoundOfCurrentTableNodeMinisterBase(int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {

            try
            {
                for (int j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count > j; j++)
                {
                    bool ac = false;
                    Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 5));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                    {
                        continue;
                    }

                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j], Tab));
                    ah1.Wait();
                    ah1.Dispose();
                    FoundOfCurrentTableNodeMinisterBaseKernel(ac, j, i, Tab, Order, ref THIS, ref Found);
                    if (Found)
                    {
                        return Found;
                    }
                }
            }
            catch (Exception t) { Log(t); }
            return Found;
        }
        public bool FoundOfCurrentTableNodeMinisterBaseKernel(bool ac,int j, int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {

            if (ac)
            {
                AllDraw This = THIS;
                bool fou = Found;
                Task<bool> ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeMinisterIJ(i, j, Order, ref This, ref fou));
                ah2.Wait();
                ah2.Dispose();
                Found = fou;
                THIS = This;
                if (Found)
                {
                    return Found;
                }
            }
            return Found;
        }
        //Creation Table and deeper when there is not deeper or there is
        public bool FoundOfCurrentTableNodeKingIJ(int i, int j, int Order, ref AllDraw THIS, ref bool Found)
        {
            //if (IsSupHuTrue(i, j, 6))

            //when is null creation enough but empty and create deeper node
            if (KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count == 0)
            {
                for (int h = 0; h <= j; h++)
                //satisfied of created deeper three
                {
                    Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 6));
                    ah.Wait();
                    ah.Dispose();
                }
                KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].TableList.Clear();
                KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].TableList.Add(CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j]));
                KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].SetRowColumn(0);
                KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                                    if (KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count < j + 1)
            {
                for (int h = KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; h <= j; h++)
                //satisfied of created deeper three
                {
                    Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 6));
                    ah.Wait();
                    ah.Dispose();
                }
                KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].TableList.Clear();
                KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].TableList.Add(CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j]));
                KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].SetRowColumn(0);
                KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count > j)
                {
                    THIS = KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }

        //Creation Table and deeper when there is not deeper or there is
        public bool FoundOfCurrentTableNodeCastlingIJ(int i, int j, int Order, ref AllDraw THIS, ref bool Found)
        {
            //if (IsSupHuTrue(i, j, 6))

            //when is null creation enough but empty and create deeper node
            if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count == 0)
            {
                for (int h = 0; h <= j; h++)
                //satisfied of created deeper three
                {
                    Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 7));
                    ah.Wait();
                    ah.Dispose();
                }
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList.Clear();
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList.Add(CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]));
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].SetRowColumn(0);
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                                    if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count < j + 1)
            {
                for (int h = CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; h <= j; h++)
                //satisfied of created deeper three
                {
                    Task ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 7));
                    ah.Wait();
                    ah.Dispose();
                }
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList.Clear();
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList.Add(CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]));
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].SetRowColumn(0);
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j)
                {
                    THIS = CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }

        //determine about found of equality of lists of current alldraw and call determinition of deeper
        public bool FoundOfCurrentTableNodeKing(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; KingOnTable != null && i < KingMidle; i++)
                {
                    FoundOfCurrentTableNodeKingBase(i, Tab, Order, ref THIS, ref Found);
                }
            }
            else
            {
                for (int i = KingMidle; KingOnTable != null && i < KingHigh; i++)
                {
                    FoundOfCurrentTableNodeKingBase(i, Tab, Order, ref THIS, ref Found);
                }
            }
            return Found;
        }

        public bool FoundOfCurrentTableNodeKingBase(int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {

            try
            {
                for (int j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum != null && KingOnTable[i].KingThinkingQuantum[0] != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count > j; j++)
                {
                    bool ac = false;
                    Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 6));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                    {
                        continue;
                    }

                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j], Tab));
                    ah1.Wait();
                    ah1.Dispose();
                    FoundOfCurrentTableNodeKingBaseKernel(ac, j, i, Tab, Order, ref THIS, ref Found);
                    if (Found)
                    {
                        return Found;
                    }
                }
            }
            catch (Exception t) { Log(t); }
            return Found;
        }
        public bool FoundOfCurrentTableNodeKingBaseKernel(bool ac,int j, int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {

            if (ac)
            {
                AllDraw This = THIS;
                bool fou = Found;
                Task<bool> ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeKingIJ(i, j, Order, ref This, ref fou));
                ah2.Wait();
                ah2.Dispose();
                Found = fou;
                THIS = This;
                if (Found)
                {
                    return Found;
                }
            }

            return Found;
        }
        //determine about found of equality of lists of current alldraw and call determinition of deeper
        public bool FoundOfCurrentTableNodeCastling(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; CastlingOnTable != null && i < 1; i++)
                {
                    FoundOfCurrentTableNodeCastlingBase(i, Tab, Order, ref THIS, ref Found);
                }
            }
            else
            {
                for (int i = 0; CastlingOnTable != null && i < 1; i++)
                {
                    FoundOfCurrentTableNodeCastlingBase(i, Tab, Order, ref THIS, ref Found);
                }
            }
            return Found;
        }

        public bool FoundOfCurrentTableNodeCastlingBase(int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {

            try
            {
                for (int j = 0; CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > j; j++)
                {
                    bool ac = false;
                    Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 7));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                    {
                        continue;
                    }

                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j], Tab));
                    ah1.Wait();
                    ah1.Dispose();
                    FoundOfCurrentTableNodeCastlingBaseKernel(ac, j, i, Tab, Order, ref THIS, ref Found);
                    if (Found)
                    {
                        return Found;
                    }
                }
            }
            catch (Exception t) { Log(t); }
            return Found;
        }
        public bool FoundOfCurrentTableNodeCastlingBaseKernel(bool ac,int j, int i, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {

            if (ac)
            {
                AllDraw This = THIS;
                bool fou = Found;
                Task<bool> ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastlingIJ(i, j, Order, ref This, ref fou));
                ah2.Wait();
                ah2.Dispose();
                Found = fou;
                THIS = This;
                if (Found)
                {
                    return Found;
                }
            }

            return Found;
        }
        public AllDraw FoundOfLeafDepenOfKindSoldier(int i, ref AllDraw Leaf, ref bool Found, int Order, int LeafDeep, int ik, int jk, int iii, int jjj)
        {
            object a = new object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                {
                    return Leaf;
                }

                for (int j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && j < SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                {
                    bool ac = false;
                    Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 1));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                    {
                        continue;
                    }
                    //when leaf found set refer bool and alldraw refer objects
                    if ((!SolderesOnTableMove[i]) && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count > j// && Kind == 1
                    )
                    {
                        if (Order == 1)
                        {
                            for (int k = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && k < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].SodierMidle; k++)
                            {
                                if (!SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].SolderesOnTableMove[k])
                                {
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                    {
                                        aa = Color.Brown;
                                    }

                                    Task<AllDraw> H = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                        else
                        {
                            for (int k = SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].SodierMidle; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && k < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].SodierHigh; k++)
                            {
                                if (!SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].SolderesOnTableMove[k])
                                {
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                    {
                                        aa = Color.Brown;
                                    }

                                    Task<AllDraw> H = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;

                                    Leaf = SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                    }
                    else//deeper
                    {
                        for (int ii = 0; ii < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; ii++)
                        {
                            SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, LeafDeep++, ik, jk, iii, jjj);
                        }
                    }
                }

                return Leaf;
            }
        }

        public AllDraw FoundOfLeafDepenOfKindElephant(int i, ref AllDraw Leaf, ref bool Found, int Order, int LeafDeep, int ik, int jk, int iii, int jjj)
        {
            object a = new object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                {
                    return Leaf;
                }

                for (int j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && j < ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                {
                    bool ac = false;
                    Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 2));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                    {
                        continue;
                    }
                    //when leaf found set refer bool and alldraw refer objects
                    if ((!ElephantOnTableMove[i]) && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count > j// && Kind == 1
                    )
                    {
                        if (Order == 1)
                        {
                            for (int k = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && k < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].ElefantMidle; k++)
                            {
                                if (!ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].ElephantOnTableMove[k])
                                {
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                    {
                                        aa = Color.Brown;
                                    }

                                    Task<AllDraw> H = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                        else
                        {
                            for (int k = ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].ElefantMidle; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && k < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].ElefantHigh; k++)
                            {
                                if (!ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].ElephantOnTableMove[k])
                                {
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                    {
                                        aa = Color.Brown;
                                    }

                                    Task<AllDraw> H = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j]), Order * -1, false, false, 0));
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                                    H.Wait();
                                    H.Dispose();
                                    Leaf = ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                    }
                    else//deeper
                    {
                        for (int ii = 0; ii < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; ii++)
                        {
                            ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, LeafDeep++, ik, jk, iii, jjj);
                        }
                    }
                }
                return Leaf;
            }
        }

        public AllDraw FoundOfLeafDepenOfKindHourse(int i, ref AllDraw Leaf, ref bool Found, int Order, int LeafDeep, int ik, int jk, int iii, int jjj)
        {
            object a = new object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                {
                    return Leaf;
                }

                for (int j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && j < HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                {
                    bool ac = false;
                    Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 3));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                    {
                        continue;
                    }
                    //when leaf found set refer bool and alldraw refer objects
                    if ((!HoursesOnTableMove[i]) && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count > j// && Kind == 1
                    )
                    {
                        if (Order == 1)
                        {
                            for (int k = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && k < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].HourseMidle; k++)
                            {
                                if (!HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].HoursesOnTableMove[k])
                                {
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                    {
                                        aa = Color.Brown;
                                    }

                                    Task<AllDraw> H = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                        else
                        {
                            for (int k = HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].HourseMidle; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && k < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].HourseHight; k++)
                            {
                                if (!HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].HoursesOnTableMove[k])
                                {
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                    {
                                        aa = Color.Brown;
                                    }

                                    Task<AllDraw> H = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                    }
                    else//deeper
                    {
                        for (int ii = 0; ii < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; ii++)
                        {
                            HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, LeafDeep++, ik, jk, iii, jjj);
                        }
                    }
                }

                return Leaf;
            }
        }

        public AllDraw FoundOfLeafDepenOfKindCastle(int i, ref AllDraw Leaf, ref bool Found, int Order, int LeafDeep, int ik, int jk, int iii, int jjj)
        {
            object a = new object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                {
                    return Leaf;
                }

                for (int j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && j < CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                {
                    bool ac = false;
                    Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 4));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                    {
                        continue;
                    }

                    //when leaf found set refer bool and alldraw refer objects
                    if ((!CastlesOnTableMove[i]) && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count > j// && Kind == 1
                    )
                    {
                        if (Order == 1)
                        {
                            for (int k = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && k < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].CastleMidle; k++)
                            {
                                if (!CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].CastlesOnTableMove[k])
                                {
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                    {
                                        aa = Color.Brown;
                                    }

                                    Task<AllDraw> H = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                        else
                        {
                            for (int k = CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].CastleMidle; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && k < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].CastleHigh; k++)
                            {
                                if (!CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].CastlesOnTableMove[k])
                                {
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                    {
                                        aa = Color.Brown;
                                    }

                                    Task<AllDraw> H = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                    }
                    else//deeper
                    {
                        for (int ii = 0; ii < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; ii++)
                        {
                            CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, LeafDeep++, ik, jk, iii, jjj);
                        }
                    }
                }

                return Leaf;
            }
        }

        public AllDraw FoundOfLeafDepenOfKindMinister(int i, ref AllDraw Leaf, ref bool Found, int Order, int LeafDeep, int ik, int jk, int iii, int jjj)
        {
            object a = new object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                {
                    return Leaf;
                }

                for (int j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && j < MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                {
                    bool ac = false;
                    Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 5));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                    {
                        continue;
                    }
                    //when leaf found set refer bool and alldraw refer objects
                    if ((!MinisterOnTableMove[i]) && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count > j// && Kind == 1
                    )
                    {
                        if (Order == 1)
                        {
                            for (int k = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && k < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].MinisterMidle; k++)
                            {
                                if (!MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].MinisterOnTableMove[k])
                                {
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                    {
                                        aa = Color.Brown;
                                    }

                                    Task<AllDraw> H = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                        else
                        {
                            for (int k = MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].MinisterMidle; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && k < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].MinisterHigh; k++)
                            {
                                if (!MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].MinisterOnTableMove[k])
                                {
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                    {
                                        aa = Color.Brown;
                                    }

                                    Task<AllDraw> H = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                    }
                    else//deeper
                    {
                        for (int ii = 0; ii < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; ii++)
                        {
                            MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, LeafDeep++, ik, jk, iii, jjj);
                        }
                    }
                }

                return Leaf;
            }
        }

        public AllDraw FoundOfLeafDepenOfKindKing(int i, ref AllDraw Leaf, ref bool Found, int Order, int LeafDeep, int ik, int jk, int iii, int jjj)
        {
            object a = new object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                {
                    return Leaf;
                }

                for (int j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum[0] != null && j < KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                {
                    bool ac = false;
                    Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 6));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                    {
                        continue;
                    }
                    //when leaf found set refer bool and alldraw refer objects
                    if ((!KingOnTableMove[i]) && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count > j// && Kind == 1
                    )
                    {
                        if (Order == 1)
                        {
                            for (int k = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum[0] != null && k < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].KingMidle; k++)
                            {
                                if (!KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].KingOnTableMove[k])
                                {
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                    {
                                        aa = Color.Brown;
                                    }

                                    Task<AllDraw> H = Task.Factory.StartNew(() => KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                        else
                        {
                            for (int k = KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].KingMidle; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum[0] != null && k < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].KingHigh; k++)
                            {
                                if (!KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].KingOnTableMove[k])
                                {
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                    {
                                        aa = Color.Brown;
                                    }

                                    Task<AllDraw> H = Task.Factory.StartNew(() => KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                    }
                    else//deeper
                    {
                        for (int ii = 0; ii < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; ii++)
                        {
                            KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, LeafDeep++, ik, jk, iii, jjj);
                        }
                    }
                }

                return Leaf;
            }
        }

        public AllDraw FoundOfLeafDepenOfKindCastling(int i, ref AllDraw Leaf, ref bool Found, int Order, int LeafDeep, int ik, int jk, int iii, int jjj)
        {
            object a = new object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                {
                    return Leaf;
                }

                for (int j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                {
                    bool ac = false;
                    Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 7));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                    {
                        continue;
                    }
                    //when leaf found set refer bool and alldraw refer objects
                    if ((!CastlingOnTableMove[i]) && CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j// && Kind == 1
                    )
                    {
                        if (Order == 1)
                        {
                            for (int k = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && k < 1; k++)
                            {
                                if (!CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].CastlingOnTableMove[k])
                                {
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                    {
                                        aa = Color.Brown;
                                    }

                                    Task<AllDraw> H = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                        else
                        {
                            for (int k = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && k < 1; k++)
                            {
                                if (!CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].CastlingOnTableMove[k])
                                {
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                    {
                                        aa = Color.Brown;
                                    }

                                    Task<AllDraw> H = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                    }
                    else//deeper
                    {
                        for (int ii = 0; ii < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                        {
                            CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, LeafDeep++, ik, jk, iii, jjj);
                        }
                    }
                }

                return Leaf;
            }
        }

        //found of leadfs of created Tree depend of orderic
        public AllDraw FoundOfLeafDepenOfKind(ref AllDraw Leaf, ref bool Found, int Order, int LeafDeep, int ik, int jk, int iii, int jjj)
        {
            object a = new object();
            lock (a)
            {
                // if (LeafDeep > MaxAStarGreedy)
                //  return Leaf;
                if (FullBoundryConditions(CurrentAStarGredyMax, Order, 0))
                {
                    return Leaf;
                }
                //LeafDeep++;
                //when found return recursive
                if (UniqueLeafDetection)
                {
                    if (Found)
                    {
                        return Leaf;
                    }
                }   //Gray
                if (Order == 1)
                {
                    for (int i = 0; i < SodierMidle; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        Task<AllDraw> ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindSoldier(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }

                    if (UniqueLeafDetection)
                    {
                        if (Found)
                        {
                            return Leaf;
                        }
                    }
                    for (int i = 0; i < ElefantMidle; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        Task<AllDraw> ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindElephant(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                        {
                            return Leaf;
                        }
                    }
                    for (int i = 0; i < HourseMidle; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        Task<AllDraw> ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindHourse(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                        {
                            return Leaf;
                        }
                    }
                    for (int i = 0; i < CastleMidle; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        Task<AllDraw> ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindCastle(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                        {
                            return Leaf;
                        }
                    }
                    for (int i = 0; i < MinisterMidle; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        Task<AllDraw> ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindMinister(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                        {
                            return Leaf;
                        }
                    }
                    for (int i = 0; i < KingMidle; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        Task<AllDraw> ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindKing(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                        {
                            return Leaf;
                        }
                    }
                    for (int i = 0; i < 1; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        Task<AllDraw> ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindCastling(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                }
                else
                {
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                        {
                            return Leaf;
                        }
                    }
                    for (int i = SodierMidle; i < SodierHigh; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        Task<AllDraw> ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindSoldier(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                        {
                            return Leaf;
                        }
                    }
                    for (int i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        Task<AllDraw> ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindElephant(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                        {
                            return Leaf;
                        }
                    }
                    for (int i = HourseMidle; i < HourseHight; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        Task<AllDraw> ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindHourse(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                        {
                            return Leaf;
                        }
                    }
                    for (int i = CastleMidle; i < CastleHigh; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        Task<AllDraw> ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindCastle(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                        {
                            return Leaf;
                        }
                    }
                    for (int i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        Task<AllDraw> ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindMinister(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                        {
                            return Leaf;
                        }
                    }
                    for (int i = KingMidle; i < KingHigh; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        Task<AllDraw> ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindKing(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                        {
                            return Leaf;
                        }
                    }
                    for (int i = 0; i < 1; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        Task<AllDraw> ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindCastling(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                }

                return Leaf;
            }
        }

        //when leafs is vivtory target nodes return true found and set refrence
        public bool IsFoundOfLeafDepenOfKindhaveVictory(int Kind, ref bool Found, int Order)
        {
            object a = new object();
            lock (a)
            {
                //when found return recurve
                if (Found)
                {
                    return true;
                }
                //Gray
                if (Order == 1)
                {
                    //soldier
                    for (int i = 0; i < SodierMidle; i++)
                    {
                        IsFoundOfLeafDepenOfKindhaveVictoryS(i, Kind, ref Found, Order);
                    }
                    //elephant
                    for (int i = 0; i < ElefantMidle; i++)
                    {
                        IsFoundOfLeafDepenOfKindhaveVictoryE(i, Kind, ref Found, Order);
                    }
                    //hourse
                    for (int i = 0; i < HourseMidle; i++)
                    {
                        IsFoundOfLeafDepenOfKindhaveVictoryH(i, Kind, ref Found, Order);
                    }
                    //Castle
                    for (int i = 0; i < CastleMidle; i++)
                    {
                        IsFoundOfLeafDepenOfKindhaveVictoryC(i, Kind, ref Found, Order);
                    }
                    //minister
                    for (int i = 0; i < MinisterMidle; i++)
                    {
                        IsFoundOfLeafDepenOfKindhaveVictoryM(i, Kind, ref Found, Order);
                    }
                    //king
                    for (int i = 0; i < KingMidle; i++)
                    {
                        IsFoundOfLeafDepenOfKindhaveVictoryK(i, Kind, ref Found, Order);
                    }

                    for (int i = 0; i < 1; i++)
                    {
                        IsFoundOfLeafDepenOfKindhaveVictoryA(i, Kind, ref Found, Order);
                    }
                }
                else//Brown
                {
                    //soldier
                    for (int i = SodierMidle; i < SodierHigh; i++)
                    {
                        IsFoundOfLeafDepenOfKindhaveVictoryS(i, Kind, ref Found, Order);
                    }
                    //elephant
                    for (int i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        IsFoundOfLeafDepenOfKindhaveVictoryE(i, Kind, ref Found, Order);
                    }
                    //hourse
                    for (int i = HourseMidle; i < HourseHight; i++)
                    {
                        IsFoundOfLeafDepenOfKindhaveVictoryH(i, Kind, ref Found, Order);
                    }
                    //Castle
                    for (int i = CastleMidle; i < CastleHigh; i++)
                    {
                        IsFoundOfLeafDepenOfKindhaveVictoryC(i, Kind, ref Found, Order);
                    }
                    //minister
                    for (int i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        IsFoundOfLeafDepenOfKindhaveVictoryM(i, Kind, ref Found, Order);
                    }
                    //king
                    for (int i = KingMidle; i < KingHigh; i++)
                    {
                        IsFoundOfLeafDepenOfKindhaveVictoryK(i, Kind, ref Found, Order);
                    }

                    for (int i = 0; i < 1; i++)
                    {
                        IsFoundOfLeafDepenOfKindhaveVictoryA(i, Kind, ref Found, Order);
                    }
                }

                return Found;
            }
        }

        public bool IsFoundOfLeafDepenOfKindhaveVictoryS(int i, int Kind, ref bool Found, int Order)
        {
            object a = new object();
            lock (a)
            {
                try
                {   //when found return recurve
                    if (Found)
                    {
                        return true;
                    }

                    for (int j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && j < SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                    {
                        //when is victory
                        if (SolderesOnTable[i].SoldierThinkingQuantum[0].IsThereMateOfEnemy[j]// && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count == 0
                            && Kind == 1)
                        {
                            Found = true;

                            return true;
                        }
                        else//deeper
                        {
                            for (int ii = 0; ii < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                bool fou = Found;
                                Task<bool> ah = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                Found = fou;
                            }
                        }
                    }

                }
                catch (Exception t) { Log(t); }

                return Found;
            }
        }

        public bool IsFoundOfLeafDepenOfKindhaveVictoryE(int i, int Kind, ref bool Found, int Order)
        {
            object a = new object();
            lock (a)
            {
                try
                {  //when found return recurve
                    if (Found)
                    {
                        return true;
                    }

                    for (int j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && j < ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                    {
                        //when is victory
                        if (ElephantOnTable[i].ElefantThinkingQuantum[0].IsThereMateOfEnemy[j] //&& ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count == 0
                    && Kind == 2)
                        {
                            Found = true;

                            return true;
                        }
                        else//deeper
                        {
                            for (int ii = 0; ii < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                bool fou = Found;
                                Task<bool> ah = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                Found = fou;
                            }
                        }
                    }

                }
                catch (Exception t) { Log(t); }

                return Found;
            }
        }

        public bool IsFoundOfLeafDepenOfKindhaveVictoryH(int i, int Kind, ref bool Found, int Order)
        {
            object a = new object();
            lock (a)
            {
                try
                {  //when found return recurve
                    if (Found)
                    {
                        return true;
                    }

                    for (int j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && j < HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                    {
                        //when is victory
                        if (HoursesOnTable[i].HourseThinkingQuantum[0].IsThereMateOfEnemy[j] //&& HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count == 0
    && Kind == 3)
                        {
                            Found = true;

                            return true;
                        }
                        else//deeper
                        {
                            for (int ii = 0; ii < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                bool fou = Found;
                                Task<bool> ah = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                Found = fou;
                            }
                        }
                    }

                }
                catch (Exception t) { Log(t); }

                return Found;
            }
        }

        public bool IsFoundOfLeafDepenOfKindhaveVictoryC(int i, int Kind, ref bool Found, int Order)
        {
            object a = new object();
            lock (a)
            {
                try
                {//when found return recurve
                    if (Found)
                    {
                        return true;
                    }

                    for (int j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && j < CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                    {
                        //when is victory
                        if (CastlesOnTable[i].CastleThinkingQuantum[0].IsThereMateOfEnemy[j] //&& CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count == 0
                            && Kind == 4)
                        {
                            Found = true;

                            return true;
                        }
                        else//deeper
                        {
                            for (int ii = 0; ii < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                bool fou = Found;
                                Task<bool> ah = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                Found = fou;
                            }
                        }
                    }
                }
                catch (Exception t) { Log(t); }


                return Found;
            }
        }

        public bool IsFoundOfLeafDepenOfKindhaveVictoryM(int i, int Kind, ref bool Found, int Order)
        {
            object a = new object();
            lock (a)
            {
                try
                {   //when found return recurve
                    if (Found)
                    {
                        return true;
                    }

                    for (int j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && j < MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                    {
                        //when is victory
                        if (MinisterOnTable[i].MinisterThinkingQuantum[0].IsThereMateOfEnemy[j] //&& MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count == 0
                            && Kind == 5)
                        {
                            Found = true;

                            return true;
                        }
                        else//deeper
                        {
                            for (int ii = 0; ii < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                bool fou = Found;
                                Task<bool> ah = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                Found = fou;
                            }
                        }
                    }

                }
                catch (Exception t) { Log(t); }

                return Found;
            }
        }

        public bool IsFoundOfLeafDepenOfKindhaveVictoryK(int i, int Kind, ref bool Found, int Order)
        {
            object a = new object();
            lock (a)
            {
                //when found return recurve
                try
                {
                    if (Found)
                    {
                        return true;
                    }

                    for (int j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum[0] != null && j < KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                    {
                        //when is victory
                        if (KingOnTable[i].KingThinkingQuantum[0].IsThereMateOfEnemy[j] //&& KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count == 0
                            && Kind == 6)
                        {
                            Found = true;

                            return true;
                        }
                        else//deeper
                        {
                            for (int ii = 0; ii < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                bool fou = Found;
                                Task<bool> ah = Task.Factory.StartNew(() => KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                Found = fou;
                            }
                        }
                    }

                }
                catch (Exception t) { Log(t); }
                return Found;
            }
        }

        public bool IsFoundOfLeafDepenOfKindhaveVictoryA(int i, int Kind, ref bool Found, int Order)
        {
            object a = new object();
            lock (a)
            {
                try
                {  //when found return recurve
                    if (Found)
                    {
                        return true;
                    }

                    for (int j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                    {
                        //when is victory
                        if (CastlingOnTable[i].CastlingThinking[0].IsThereMateOfEnemy[j] //&& CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count == 0
                            && (Kind == 7 || Kind == -7))
                        {
                            Found = true;

                            return true;
                        }
                        else//deeper
                        {
                            for (int ii = 0; ii < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                            {
                                bool fou = Found;
                                Task<bool> ah = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                Found = fou;
                            }
                        }
                    }
                }
                catch (Exception t) { Log(t); }


                return Found;
            }
        }

        //Retrun determined consideration of lists of Thinking chess class list collisions.

        //3 for empty and contained compuatations
        //4 a star is not emplty and contaied computation
        private int IsSuitableForInitiation(int i, int j, int Kind)
        {
            int Is = 0;
            //determine deeper have right contained
            bool a = false;
            Task<bool> ah = Task.Factory.StartNew(() => a = IsNotAStarGreedyConanaied(i, j, Kind));
            ah.Wait();
            ah.Dispose();

            //determined deeper contained have computatinal list correctly.
            bool b = false;
            Task<bool> ah1 = Task.Factory.StartNew(() => b = IsNotComputationsConanaiedAStarGreedy(i, j, Kind));
            ah1.Wait();
            ah1.Dispose();

            //when true
            if (a)
            {
                //when true
                if (b)
                {
                    Is = 2;
                }
                else//when false
                {
                    Is = 3;
                }
            }
            else//when false
            {
                //when true
                if (b)
                {
                    Is = 1;
                }
                else//when false
                {
                    Is = 4;
                }
            }
            //when is 2 consider determinstic results about contanied
            if (Is == 2)
            {
                Task<bool> ah2 = Task.Factory.StartNew(() => IsThereCalculatedAStarGreedyNode(i, Kind));
                ah2.Wait();
                ah2.Dispose();
            }
            return Is;
        }

        //when current side of alldraw is not contained and semi computated
        private bool IsNotAStarGreedyConanaied(int i, int j, int Kind)
        {
            bool Is = false;
            int e = 0;
            int d = 0;
            //Soldier
            if (Kind == 1)
            {
                //determine nodes is coorectly existence
                if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count > 0)
                {
                    //deeper count
                    e = SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                    {
                        //alldraw table list count
                        d = SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].TableList.Count;
                    }
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingQuantumChess.TableEqual(SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j]))))
                    {
                        Is = true;
                    }
                }
            }
            else if (Kind == 2)
            {
                //determine nodes is coorectly existence
                if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count > 0)
                {
                    //deeper count
                    e = ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                    {
                        //alldraw table list count
                        d = ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].TableList.Count;
                    }
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingQuantumChess.TableEqual(ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j]))))
                    {
                        Is = true;
                    }
                }
            }
            else if (Kind == 3)
            {
                //determine nodes is coorectly existence
                if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count > 0)
                {
                    //deeper count
                    e = HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                    {
                        //alldraw table list count
                        d = HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].TableList.Count;
                    }
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingQuantumChess.TableEqual(HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j]))))
                    {
                        Is = true;
                    }
                }
            }
            else if (Kind == 4)
            {
                //determine nodes is coorectly existence
                if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count > 0)
                {
                    //deeper count
                    e = CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                    {
                        //alldraw table list count
                        d = CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].TableList.Count;
                    }
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingQuantumChess.TableEqual(CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j]))))
                    {
                        Is = true;
                    }
                }
            }
            else if (Kind == 5)
            {
                //determine nodes is coorectly existence
                if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count > 0)
                {
                    //deeper count
                    e = MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                    {
                        //alldraw table list count
                        d = MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].TableList.Count;
                    }
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingQuantumChess.TableEqual(MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j]))))
                    {
                        Is = true;
                    }
                }
            }
            else if (Kind == 6)
            {
                //determine nodes is coorectly existence
                if (KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum != null && KingOnTable[i].KingThinkingQuantum[0] != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count > 0)
                {
                    //deeper count
                    e = KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                    {
                        //alldraw table list count
                        d = KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].TableList.Count;
                    }
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingQuantumChess.TableEqual(KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListCastling[j]))))
                    {
                        Is = true;
                    }
                }
            }
            else if (Kind == 7 || Kind == -7)
            {
                //determine nodes is coorectly existence
                if (CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > 0)
                {
                    //deeper count
                    e = CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                    {
                        //alldraw table list count
                        d = CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList.Count;
                    }
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingQuantumChess.TableEqual(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList[0], CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]))))
                    {
                        Is = true;
                    }
                }
            }

            //when deeper not exist return true
            if (e == 0)
            {
                Is = true;
            }
            //when current alldraw tablelist not exist return true
            if (d == 0)
            {
                Is = true;
            }

            return Is;
        }

        public bool IsAtLeastAllObjectIsNull()
        {
            object o = new object();
            lock (o)
            {
                bool Is = false;
                //Soldier
                if (SolderesOnTable == null)
                {
                    Is = true;
                }

                if (ElephantOnTable == null)
                {
                    Is = true;
                }

                if (HoursesOnTable == null)
                {
                    Is = true;
                }

                if (CastlesOnTable == null)
                {
                    Is = true;
                }

                if (MinisterOnTable == null)
                {
                    Is = true;
                }

                if (KingOnTable == null)
                {
                    Is = true;
                }

                if (CastlingOnTable == null)
                {
                    Is = true;
                }

                return Is;
            }
        }

        //When there is computatinoal deeper and there is colosion in lists return true otherwise return false
        private bool IsNotComputationsConanaiedAStarGreedy(int i, int j, int Kind)
        {
            bool Is = false;
            int e = 0;
            //soldier
            if (Kind == 1)
            {
                IsNotComputationsConanaiedAStarGreedySoldier(i, j, Kind);
            }
            else if (Kind == 2)//elephant
            {
                IsNotComputationsConanaiedAStarGreedyElephant(i, j, Kind);
            }
            else if (Kind == 3)//hourse
            {
                IsNotComputationsConanaiedAStarGreedyHourse(i, j, Kind);
            }
            else if (Kind == 4)//Castle
            {
                IsNotComputationsConanaiedAStarGreedyCastle(i, j, Kind);
            }
            else if (Kind == 5)//minister
            {
                IsNotComputationsConanaiedAStarGreedyMinister(i, j, Kind);
            }
            else if (Kind == 6)//king
            {
                IsNotComputationsConanaiedAStarGreedyKing(i, j, Kind);
            }
            else if (Kind == 7 || Kind == -7)
            {
                IsNotComputationsConanaiedAStarGreedyCastling(i, j, Kind);
            }
            //when deeper count is less than index deeper return true
            if (e < j)
            {
                Is = true;
            }

            return Is;
        }
        private bool IsNotComputationsConanaiedAStarGreedySoldier(int i, int j, int Kind)
        {

            bool Is = false;
            int e = 0;
            if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count > 0)
            {
                //lists count
                int a = SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count;
                e = SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count;
                //when table state exist and there is equliity between lists and deeper count
                if (a == e && e > j && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].TableList != null && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].TableList.Count > 0)
                {
                    //when tow lists tables not is equal return true
                    bool ac = false;
                    Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j])));
                    ah2.Wait();
                    ah2.Dispose();
                    if (!ac)
                    {
                        Is = true;
                    }
                }
                else
                {
                    //when deeper count is larger than lists count
                    if (e > a)
                    {
                        //remove extra
                        for (int h = a; h < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; h++)
                        {
                            SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.RemoveAt(h);
                        }
                    }
                    //when deeper dose not exist return true
                    if (a == 0)
                    {
                        Is = true;
                    }
                }
            }
            //when deeper count is less than index deeper return true
            if (e < j)
            {
                Is = true;
            }

            return Is;
        }
        private bool IsNotComputationsConanaiedAStarGreedyElephant(int i, int j, int Kind)
        {
            bool Is = false;
            int e = 0;
            if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count > 0)
                {
                    //lists count
                    int a = ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count;
                    e = ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].TableList != null && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        bool ac = false;
                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j])));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                        {
                            Is = true;
                        }
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; h++)
                            {
                                ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.RemoveAt(h);
                            }
                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                        {
                            Is = true;
                        }
                    }
                }
         //when deeper count is less than index deeper return true
            if (e < j)
            {
                Is = true;
            }

            return Is;
        }
        private bool IsNotComputationsConanaiedAStarGreedyHourse(int i, int j, int Kind)
        {
            bool Is = false;
            int e = 0;
    
            if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count > 0)
                {
                    //lists count
                    int a = HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count;
                    e = HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].TableList != null && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        bool ac = false;
                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j])));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                        {
                            Is = true;
                        }
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; h++)
                            {
                                HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.RemoveAt(h);
                            }
                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                        {
                            Is = true;
                        }
                    }
                }
              //when deeper count is less than index deeper return true
            if (e < j)
            {
                Is = true;
            }

            return Is;
        }
        private bool IsNotComputationsConanaiedAStarGreedyCastle(int i, int j, int Kind)
        {
            bool Is = false;
            int e = 0;
            //soldier
                  if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count > 0)
                {
                    //lists count
                    int a = CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count;
                    e = CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].TableList != null && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        bool ac = false;
                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j])));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                        {
                            Is = true;
                        }
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; h++)
                            {
                                CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.RemoveAt(h);
                            }
                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                        {
                            Is = true;
                        }
                    }
                }
              //when deeper count is less than index deeper return true
            if (e < j)
            {
                Is = true;
            }

            return Is;
        }
        private bool IsNotComputationsConanaiedAStarGreedyMinister(int i, int j, int Kind)
        {
            bool Is = false;
            int e = 0;
            //soldier
                 if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count > 0)
                {
                    //lists count
                    int a = MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count;
                    e = MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].TableList != null && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        bool ac = false;
                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j])));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                        {
                            Is = true;
                        }
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; h++)
                            {
                                MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.RemoveAt(h);
                            }
                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                        {
                            Is = true;
                        }
                    }
                }
              //when deeper count is less than index deeper return true
            if (e < j)
            {
                Is = true;
            }

            return Is;
        }
        private bool IsNotComputationsConanaiedAStarGreedyKing(int i, int j, int Kind)
        {
            bool Is = false;
            int e = 0;
            //soldier
      
            if (KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum != null && KingOnTable[i].KingThinkingQuantum[0] != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count > 0)
                {
                    //lists count
                    int a = KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count;
                    e = KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].TableList != null && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        bool ac = false;
                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].TableList[0], CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j])));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                        {
                            Is = true;
                        }
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; h++)
                            {
                                KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.RemoveAt(h);
                            }
                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                        {
                            Is = true;
                        }
                    }
                }
            //when deeper count is less than index deeper return true
            if (e < j)
            {
                Is = true;
            }

            return Is;
        }
        private bool IsNotComputationsConanaiedAStarGreedyCastling(int i, int j, int Kind)
        {
            bool Is = false;
            int e = 0;
            //soldier
            if (CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > 0)
            {
                //lists count
                int a = CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count;
                e = CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count;
                //when table state exist and there is equliity between lists and deeper count
                if (a == e && e > j && CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList.Count > 0)
                {
                    //when tow lists tables not is equal return true
                    bool ac = false;
                    Task<bool> ah2 = Task.Factory.StartNew(() => ac = ThinkingQuantumChess.TableEqual(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList[0], CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j])));
                    ah2.Wait();
                    ah2.Dispose();
                    if (!ac)
                    {
                        Is = true;
                    }
                }
                else
                {
                    //when deeper count is larger than lists count
                    if (e > a)
                    {
                        //remove extra
                        for (int h = a; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; h++)
                        {
                            CastlingOnTable[i].CastlingThinking[0].AStarGreedy.RemoveAt(h);
                        }
                    }
                    //when deeper dose not exist return true
                    if (a == 0)
                    {
                        Is = true;
                    }
                }
            }
            //when deeper count is less than index deeper return true
            if (e < j)
            {
                Is = true;
            }

            return Is;
        }

        public void FoundOfLeafDepenOfKindFullGameSoldeir(Color a, ref bool FullGameFoundF, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            object P = new object();
            lock (P)
            {
                try
                {
                    bool FullGameFound = FullGameFoundF;
                    ParallelOptions po = new ParallelOptions
                    {
                        MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                    };
                    if (!(SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder != null))
                        return;

                    Parallel.For(0, SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count, j =>
                    {
                        object OOOOO = new object();
                        lock (OOOOO)
                        {
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 1));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                return;
                            }
                            //when search finished stop and return
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                return;
                            }
                        }
                        //determine about validity of list on current and deeper return true when successfull
                        bool IA = false;
                        Task<bool> ah2 = Task.Factory.StartNew(() => IA = IsNonValidityAllTablesHeuristicsAndMore(1, Order, i, j));
                        ah2.Wait();
                        ah2.Dispose();
                        //determine about situation of deeper against other lists computation in 4 state
                        int Is = 0;
                        Task<int> ah3 = Task.Factory.StartNew(() => Is = IsSuitableForInitiation(i, j, 1));
                        ah3.Wait();
                        ah3.Dispose();
                        if (!IA)
                        {
                            Is = 4;
                        }
                        //when is suitable for computational operation on lists
                        if (Is == 4)
                        {
                            object OOOO = new object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                bool ac = false;
                                Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                {
                                    return;
                                }
                            }
                            FullGameFound = true;

                            StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                            Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                            H.Wait();
                            H.Dispose();
                            for (int h = 0; h < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null; h++)
                            {
                                SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[h].AStarGreedyString = this;
                                SolderesOnTable[i].WinOcuuredatChiled += SumOfObjects(SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[h], Order * -1);
                            }
                            for (int h = 0; h < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null; h++)
                            {
                                SolderesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[h], Order * -1);
                            }
                            if (SolderesOnTable[i].WinOcuuredatChiled > 0 || SolderesOnTable[i].LoseOcuuredatChiled[0] < 0)
                                return;
                        }
                        else
                        {
                            //when is suitable for leafer
                            if (Is == 2)
                            {
                                for (int iii = 0; iii < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[iii].TableList != null && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                                {
                                    object OOOO = new object();
                                    lock (OOOO)
                                    {
                                        FirstTraversalTree = false;

                                        //when search finished stop and return
                                        bool ac = false;
                                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                        ah1.Wait();
                                        ah1.Dispose();
                                        if (ac)
                                        {
                                            return;
                                        }
                                    }

                                    SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[iii].TableList[0]), Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[iii].AStarGreedyString = this;
                                }
                                for (int h = 0; h < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    SolderesOnTable[i].WinOcuuredatChiled += SumOfObjects(SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                }

                                for (int h = 0; h < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    SolderesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                }
                                if (SolderesOnTable[i].WinOcuuredatChiled > 0 || SolderesOnTable[i].LoseOcuuredatChiled[0] < 0)
                                    return;
                            }
                            else if (Is == 3)//when deeper is suitable and  computational not
                            {
                                object OOOO = new object();
                                lock (OOOO)
                                {
                                    //when search finished stop and return
                                    bool ac = false;
                                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                    {
                                        return;
                                    }
                                }

                                object O1 = new object();
                                lock (O1)
                                {
                                    int Ord = Order, ii1 = ii, jj1 = jj, i1 = i, j1 = j;
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    /*Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                                    H.Wait();
                                    H.Dispose();*/
                                    for (int h = 0; h < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null; h++)
                                    {
                                        SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[h].AStarGreedyString = this;
                                        SolderesOnTable[i].WinOcuuredatChiled += SumOfObjects(SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                    }
                                    for (int h = 0; h < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null; h++)
                                    {
                                        SolderesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                    }
                                    if (SolderesOnTable[i].WinOcuuredatChiled > 0 || SolderesOnTable[i].LoseOcuuredatChiled[0] < 0)
                                        return;
                                }
                            }
                            else//otherwise
                            {
                                object OOOO = new object();
                                lock (OOOO)
                                {
                                    //when search finished stop and return
                                    bool ac = false;
                                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                    {
                                        return;
                                    }
                                }
                                object OO1 = new object();
                                lock (OO1)
                                {
                                    FullGameFound = true;

                                    a = Color.Gray;
                                    if (Order == -1)
                                    {
                                        a = Color.Brown;
                                    }

                                    object OOO = new object();
                                    lock (OOO)
                                    {
                                        FirstTraversalTree = false;

                                        //when search finished stop and return
                                        bool ac = false;
                                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                        ah1.Wait();
                                        ah1.Dispose();
                                        if (ac)
                                        {
                                            return;
                                        }
                                    }
                                    Task<bool> ah4 = Task.Factory.StartNew(() => FullGameThinkingTree(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                                    ah4.Wait();
                                    ah4.Dispose();

                                }
                            }
                        }
                    });
                    FullGameFoundF = FullGameFound;
                }
                catch (Exception t) { Log(t); }
            }
        }

        //deeper leaf found
        public void FoundOfLeafDepenOfKindFullGameElepahnt(Color a, ref bool FullGameFoundF, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            object P = new object();
            lock (P)
            {
                try
                {
                    bool FullGameFound = FullGameFoundF;
                    ParallelOptions po = new ParallelOptions
                    {
                        MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                    };
                    if (!(ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant != null))
                        return;

                    Parallel.For(0, ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count, j =>
                    {
                        object OOOOO = new object();
                        lock (OOOOO)
                        {
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 2));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                return;
                            }
                            //when search finished stop and return
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                return;
                            }
                        }
                        //determine about validity of list on current and deeper return true when successfull
                        bool IA = false;
                        Task<bool> ah2 = Task.Factory.StartNew(() => IA = IsNonValidityAllTablesHeuristicsAndMore(2, Order, i, j));
                        ah2.Wait();
                        ah2.Dispose();
                        //determine about situation of deeper against other lists computation in 4 state
                        int Is = 0;
                        Task<int> ah3 = Task.Factory.StartNew(() => Is = IsSuitableForInitiation(i, j, 2));
                        ah3.Wait();
                        ah3.Dispose();
                        if (!IA)
                        {
                            Is = 4;
                        }

                        //when is suitable for computational operation on lists
                        if (Is == 4)
                        {
                            object OOOO = new object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                bool ac = false;
                                Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                {
                                    return;
                                }
                            }
                            FullGameFound = true;

                            StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                            Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                            H.Wait();
                            H.Dispose();
                            for (int h = 0; h < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null; h++)
                            {
                                ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[h].AStarGreedyString = this;
                                ElephantOnTable[i].WinOcuuredatChiled += SumOfObjects(ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[h], Order * -1);
                            }
                            for (int h = 0; h < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null; h++)
                            {
                                ElephantOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[h], Order * -1);
                            }
                            if (ElephantOnTable[i].WinOcuuredatChiled > 0 || ElephantOnTable[i].LoseOcuuredatChiled[0] < 0)
                                return;
                        }
                        else
                        {
                            //when is suitable for leafer
                            if (Is == 2)
                            {
                                for (int iii = 0; iii < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[iii].TableList != null && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                                {
                                    object OOOO = new object();
                                    lock (OOOO)
                                    {
                                        FirstTraversalTree = false;
                                        //when search finished stop and return
                                        bool ac = false;
                                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                        ah1.Wait();
                                        ah1.Dispose();
                                        if (ac)
                                        {
                                            return;
                                        }
                                    }

                                    ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[iii].TableList[0]), Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[iii].AStarGreedyString = this;
                                }
                                for (int h = 0; h < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    ElephantOnTable[i].WinOcuuredatChiled += SumOfObjects(ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                }

                                for (int h = 0; h < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    ElephantOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                }
                                if (ElephantOnTable[i].WinOcuuredatChiled > 0 || ElephantOnTable[i].LoseOcuuredatChiled[0] < 0)
                                    return;
                            }
                            else if (Is == 3)//when is suitable for deeper
                            {
                                object OOOO = new object();
                                lock (OOOO)
                                {
                                    //when search finished stop and return
                                    bool ac = false;
                                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                    {
                                        return;
                                    }
                                }

                                object O1 = new object();
                                lock (O1)
                                {
                                    int Ord = Order, ii1 = ii, jj1 = jj, i1 = i, j1 = j;
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                                    H.Wait();
                                    H.Dispose();
                                    for (int h = 0; h < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null; h++)
                                    {
                                        ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[h].AStarGreedyString = this;
                                        ElephantOnTable[i].WinOcuuredatChiled += SumOfObjects(ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                    }
                                    for (int h = 0; h < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null; h++)
                                    {
                                        ElephantOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                    }
                                    if (ElephantOnTable[i].WinOcuuredatChiled > 0 || ElephantOnTable[i].LoseOcuuredatChiled[0] < 0)
                                        return;
                                }
                            }
                            else//otherwise
                            {
                                object OOOO = new object();
                                lock (OOOO)
                                {
                                    //when search finished stop and return
                                    bool ac = false;
                                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                    {
                                        return;
                                    }
                                }
                                object OO1 = new object();
                                lock (OO1)
                                {
                                    a = Color.Gray;
                                    if (Order == -1)
                                    {
                                        a = Color.Brown;
                                    }

                                    Task<bool> ah4 = Task.Factory.StartNew(() => FullGameThinkingTree(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                                    ah4.Wait();
                                    ah4.Dispose();
                                }
                            }
                        }
                    });
                    FullGameFoundF = FullGameFound;
                }
                catch (Exception t) { Log(t); }
            }
        }

        //deeper leaf found
        public void FoundOfLeafDepenOfKindFullGameHourse(Color a, ref bool FullGameFoundF, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            object P = new object();
            lock (P)
            {
                try
                {
                    bool FullGameFound = FullGameFoundF;
                    ParallelOptions po = new ParallelOptions
                    {
                        MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                    };
                    if (!(HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse != null))
                        return;

                    Parallel.For(0, HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count, j =>
                    {
                        object OOOOO = new object();
                        lock (OOOOO)
                        {
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 3));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                return;
                            }
                            //when search finished stop and return
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                return;
                            }
                        }
                        //determine about validity of list on current and deeper return true when successfull
                        bool IA = false;
                        Task<bool> ah2 = Task.Factory.StartNew(() => IA = IsNonValidityAllTablesHeuristicsAndMore(3, Order, i, j));
                        ah2.Wait();
                        ah2.Dispose();
                        //determine about situation of deeper against other lists computation in 4 state
                        int Is = 0;
                        Task<int> ah3 = Task.Factory.StartNew(() => Is = IsSuitableForInitiation(i, j, 3));
                        ah3.Wait();
                        ah3.Dispose();
                        if (!IA)
                        {
                            Is = 4;
                        }

                        //when is suitable for computational operation on lists
                        if (Is == 4)
                        {
                            object OOOO = new object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                bool ac = false;
                                Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                {
                                    return;
                                }
                            }
                            FullGameFound = true;
                            StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;

                            Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                            H.Wait();
                            H.Dispose();
                            for (int h = 0; h < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null; h++)
                            {
                                HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[h].AStarGreedyString = this;
                                HoursesOnTable[i].WinOcuuredatChiled += SumOfObjects(HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[h], Order * -1);
                            }
                            for (int h = 0; h < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null; h++)
                            {
                                HoursesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[h], Order * -1);
                            }
                            if (HoursesOnTable[i].WinOcuuredatChiled > 0 || HoursesOnTable[i].LoseOcuuredatChiled[0] < 0)
                                return;
                        }
                        else
                        {
                            //when is suitable for leafer
                            if (Is == 2)
                            {
                                for (int iii = 0; iii < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[iii].TableList != null && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                                {
                                    object OOOO = new object();
                                    lock (OOOO)
                                    {
                                        FirstTraversalTree = false;
                                        //when search finished stop and return
                                        bool ac = false;
                                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                        ah1.Wait();
                                        ah1.Dispose();
                                        if (ac)
                                        {
                                            return;
                                        }
                                    }

                                    HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[iii].TableList[0]), Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                    HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[iii].AStarGreedyString = this;
                                }
                                for (int h = 0; h < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    HoursesOnTable[i].WinOcuuredatChiled += SumOfObjects(HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                }

                                for (int h = 0; h < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    HoursesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                }
                                if (HoursesOnTable[i].WinOcuuredatChiled > 0 || HoursesOnTable[i].LoseOcuuredatChiled[0] < 0)
                                    return;
                            }
                            else if (Is == 3)//when is suitable for deeper
                            {
                                object OOOO = new object();
                                lock (OOOO)
                                {
                                    //when search finished stop and return
                                    bool ac = false;
                                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                    {
                                        return;
                                    }
                                }

                                object O1 = new object();
                                lock (O1)
                                {
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                                    H.Wait();
                                    H.Dispose();
                                    for (int h = 0; h < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null; h++)
                                    {
                                        HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[h].AStarGreedyString = this;
                                        HoursesOnTable[i].WinOcuuredatChiled += SumOfObjects(HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                    }
                                    for (int h = 0; h < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null; h++)
                                    {
                                        HoursesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                    }
                                    if (HoursesOnTable[i].WinOcuuredatChiled > 0 || HoursesOnTable[i].LoseOcuuredatChiled[0] < 0)
                                        return;
                                }
                            }
                            else//otherwise
                            {
                                object OOOO = new object();
                                lock (OOOO)
                                {
                                    //when search finished stop and return
                                    bool ac = false;
                                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                    {
                                        return;
                                    }
                                }
                                object OO1 = new object();
                                lock (OO1)
                                {
                                    int Ord = Order, ii1 = ii, jj1 = jj, i1 = i, j1 = j;
                                    a = Color.Gray;
                                    if (Order == -1)
                                    {
                                        a = Color.Brown;
                                    }

                                    Task<bool> ah4 = Task.Factory.StartNew(() => FullGameThinkingTree(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                                    ah4.Wait();
                                    ah4.Dispose();
                                }
                            }
                        }
                    });
                    FullGameFoundF = FullGameFound;
                }
                catch (Exception t) { Log(t); }
            }
        }

        //deeper leaf found
        public void FoundOfLeafDepenOfKindFullGameCastle(Color a, ref bool FullGameFoundF, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            object P = new object();
            lock (P)
            {
                try
                {
                    bool FullGameFound = FullGameFoundF;
                    ParallelOptions po = new ParallelOptions
                    {
                        MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                    };
                    if (!(CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle != null))
                        return;

                    Parallel.For(0, CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count, j =>
                    {
                        bool ac = false;
                        Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 4));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                        {
                            return;
                        }

                        object OOOOO = new object();
                        lock (OOOOO)
                        {
                            //when search finished stop and return
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                return;
                            }
                        }
                        //determine about validity of list on current and deeper return true when successfull
                        bool IA = false;
                        Task<bool> ah2 = Task.Factory.StartNew(() => IA = IsNonValidityAllTablesHeuristicsAndMore(4, Order, i, j));
                        ah2.Wait();
                        ah2.Dispose();

                        //determine about situation of deeper against other lists computation in 4 state
                        int Is = 0;
                        Task<int> ah3 = Task.Factory.StartNew(() => Is = IsSuitableForInitiation(i, j, 4));
                        ah3.Wait();
                        ah3.Dispose();
                        if (!IA)
                        {
                            Is = 4;
                        }
                        //when is suitable for computational operation on lists
                        if (Is == 4)
                        {
                            object OOOO = new object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                {
                                    return;
                                }
                            }
                            FullGameFound = true;
                            StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;

                            Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                            H.Wait();
                            H.Dispose();
                            for (int h = 0; h < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null; h++)
                            {
                                CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[h].AStarGreedyString = this;
                                CastlesOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[h], Order * -1);
                            }
                            for (int h = 0; h < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null; h++)
                            {
                                CastlesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[h], Order * -1);
                            }
                            if (CastlesOnTable[i].WinOcuuredatChiled > 0 || CastlesOnTable[i].LoseOcuuredatChiled[0] < 0)
                                return;
                        }
                        else
                        {
                            //when is suitable for deeper
                            if (Is == 2)
                            {
                                for (int iii = 0; iii < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[iii].TableList != null && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                                {
                                    object OOOO = new object();
                                    lock (OOOO)
                                    {
                                        FirstTraversalTree = false;
                                        //when search finished stop and return
                                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                        ah1.Wait();
                                        ah1.Dispose();
                                        if (ac)
                                        {
                                            return;
                                        }
                                    }

                                    CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[iii].TableList[0]), Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                    CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[iii].AStarGreedyString = this;
                                }
                                for (int h = 0; h < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    CastlesOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                }

                                for (int h = 0; h < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    CastlesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                }
                                if (CastlesOnTable[i].WinOcuuredatChiled > 0 || CastlesOnTable[i].LoseOcuuredatChiled[0] < 0)
                                    return;
                            }
                            else if (Is == 3)  //when is suitable for leafer
                            {
                                object OOOO = new object();
                                lock (OOOO)
                                {
                                    //when search finished stop and return
                                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                    {
                                        return;
                                    }
                                }

                                object O1 = new object();
                                lock (O1)
                                {
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                                    H.Wait();
                                    H.Dispose();
                                    for (int h = 0; h < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null; h++)
                                    {
                                        CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[h].AStarGreedyString = this;
                                        CastlesOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                    }
                                    for (int h = 0; h < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null; h++)
                                    {
                                        CastlesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                    }
                                    if (CastlesOnTable[i].WinOcuuredatChiled > 0 || CastlesOnTable[i].LoseOcuuredatChiled[0] < 0)
                                        return;
                                }
                            }
                            else//otherwise
                            {
                                object OOOO = new object();
                                lock (OOOO)
                                {
                                    //when search finished stop and return
                                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                    {
                                        return;
                                    }
                                }
                                object OO1 = new object();
                                lock (OO1)
                                {
                                    FullGameFound = true;

                                    a = Color.Gray;
                                    if (Order == -1)
                                    {
                                        a = Color.Brown;
                                    }

                                    int Ord = Order, ii1 = ii, jj1 = jj, i1 = i, j1 = j;

                                    Task<bool> ah4 = Task.Factory.StartNew(() => FullGameThinkingTree(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                                    ah4.Wait();
                                    ah4.Dispose();
                                }
                            }
                        }
                    });
                    FullGameFoundF = FullGameFound;
                }
                catch (Exception t) { Log(t); }
            }
        }

        //deeper leaf found
        public void FoundOfLeafDepenOfKindFullGameMinister(Color a, ref bool FullGameFoundF, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            object P = new object();
            lock (P)
            {
                try
                {
                    bool FullGameFound = FullGameFoundF;
                    ParallelOptions po = new ParallelOptions
                    {
                        MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                    };
                    if (!(MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister != null))
                        return;

                    Parallel.For(0, MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count, j =>
                    {
                        bool ac = false;
                        Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 5));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                        {
                            return;
                        }

                        object OOOOO = new object();
                        lock (OOOOO)
                        {
                            //when search finished stop and return
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                return;
                            }
                        }
                        //determine about validity of list on current and deeper return true when successfull
                        bool IA = false;
                        Task<bool> ah2 = Task.Factory.StartNew(() => IA = IsNonValidityAllTablesHeuristicsAndMore(5, Order, i, j));
                        ah2.Wait();
                        ah2.Dispose();

                        //determine about situation of deeper against other lists computation in 4 state
                        int Is = 0;
                        Task<int> ah3 = Task.Factory.StartNew(() => Is = IsSuitableForInitiation(i, j, 5));
                        ah3.Wait();
                        ah3.Dispose();
                        if (!IA)
                        {
                            Is = 4;
                        }
                        //when is suitable for computational operation on lists
                        if (Is == 4)
                        {
                            object OOOO = new object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                {
                                    return;
                                }
                            }
                            FullGameFound = true;

                            StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                            Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                            H.Wait();
                            H.Dispose();
                            for (int h = 0; h < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null; h++)
                            {
                                MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[h].AStarGreedyString = this;
                                MinisterOnTable[i].WinOcuuredatChiled += SumOfObjects(MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[h], Order * -1);
                            }
                            for (int h = 0; h < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null; h++)
                            {
                                MinisterOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[h], Order * -1);
                            }
                            if (MinisterOnTable[i].WinOcuuredatChiled > 0 || MinisterOnTable[i].LoseOcuuredatChiled[0] < 0)
                                return;
                        }
                        else
                        {
                            //when is suitable for leafer
                            if (Is == 2)
                            {
                                for (int iii = 0; iii < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[iii].TableList != null && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                                {
                                    object OOOO = new object();
                                    lock (OOOO)
                                    {
                                        FirstTraversalTree = false;
                                        //when search finished stop and return
                                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                        ah1.Wait();
                                        ah1.Dispose();
                                        if (ac)
                                        {
                                            return;
                                        }
                                    }

                                    MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[iii].TableList[0]), Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[iii].AStarGreedyString = this;
                                }
                                for (int h = 0; h < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    MinisterOnTable[i].WinOcuuredatChiled += SumOfObjects(MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                }

                                for (int h = 0; h < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    MinisterOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                }
                                if (MinisterOnTable[i].WinOcuuredatChiled > 0 || MinisterOnTable[i].LoseOcuuredatChiled[0] < 0)
                                    return;
                            }
                            else if (Is == 3)//when is suitable for deeper
                            {
                                object OOOO = new object();
                                lock (OOOO)
                                {
                                    //when search finished stop and return
                                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                    {
                                        return;
                                    }
                                }

                                Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                                H.Wait();
                                H.Dispose();
                                for (int h = 0; h < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[h].AStarGreedyString = this;
                                    MinisterOnTable[i].WinOcuuredatChiled += SumOfObjects(MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                }
                                for (int h = 0; h < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    MinisterOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                }
                                if (MinisterOnTable[i].WinOcuuredatChiled > 0 || MinisterOnTable[i].LoseOcuuredatChiled[0] < 0)
                                    return;
                            }
                            else//otherwise
                            {
                                object OOOO = new object();
                                lock (OOOO)
                                {
                                    //when search finished stop and return
                                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                    {
                                        return;
                                    }
                                }
                                object OO1 = new object();
                                lock (OO1)
                                {
                                    FullGameFound = true;

                                    a = Color.Gray;
                                    if (Order == -1)
                                    {
                                        a = Color.Brown;
                                    }

                                    Task<bool> ah4 = Task.Factory.StartNew(() => FullGameThinkingTree(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                                    ah4.Wait();
                                    ah4.Dispose();
                                }
                            }
                        }
                    });
                    FullGameFoundF = FullGameFound;
                }
                catch (Exception t) { Log(t); }
            }
        }

        //deeper leaf found
        public void FoundOfLeafDepenOfKindFullGameKing(Color a, ref bool FullGameFoundF, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            object P = new object();
            lock (P)
            {
                try
                {
                    bool FullGameFound = FullGameFoundF;
                    ParallelOptions po = new ParallelOptions
                    {
                        MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                    };
                    if (!(KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum != null && KingOnTable[i].KingThinkingQuantum[0] != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing != null))
                        return;

                    Parallel.For(0, KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count, j =>
                    {
                        object OOOOO = new object();
                        lock (OOOOO)
                        {
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 6));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                return;
                            }
                            //when search finished stop and return
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                return;
                            }
                        }
                        //determine about validity of list on current and deeper return true when successfull
                        bool IA = false;
                        Task<bool> ah2 = Task.Factory.StartNew(() => IA = IsNonValidityAllTablesHeuristicsAndMore(6, Order, i, j));
                        ah2.Wait();
                        ah2.Dispose();

                        //determine about situation of deeper against other lists computation in 4 state
                        int Is = 0;
                        Task<int> ah3 = Task.Factory.StartNew(() => Is = IsSuitableForInitiation(i, j, 6));
                        ah3.Wait();
                        ah3.Dispose();
                        if (!IA)
                        {
                            Is = 4;
                        }
                        //when is suitable for computational operation on lists
                        if (Is == 4)
                        {
                            object OOOO = new object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                bool ac = false;
                                Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                {
                                    return;
                                }
                            }
                            FullGameFound = true;

                            Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                            H.Wait();
                            H.Dispose();
                            for (int h = 0; h < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null; h++)
                            {
                                KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[h].AStarGreedyString = this;
                                KingOnTable[i].WinOcuuredatChiled += SumOfObjects(KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[h], Order * -1);
                            }
                            for (int h = 0; h < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null; h++)
                            {
                                KingOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[h], Order * -1);
                            }
                            if (KingOnTable[i].WinOcuuredatChiled > 0 || KingOnTable[i].LoseOcuuredatChiled[0] < 0)
                                return;
                        }
                        else
                        {
                            //when is suitable for leafer
                            if (Is == 2)
                            {
                                for (int iii = 0; iii < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[iii].TableList != null && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                                {
                                    object OOOO = new object();
                                    lock (OOOO)
                                    {
                                        FirstTraversalTree = false;

                                        //when search finished stop and return
                                        bool ac = false;
                                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                        ah1.Wait();
                                        ah1.Dispose();
                                        if (ac)
                                        {
                                            return;
                                        }
                                    }

                                    KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(CloneATable(KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[iii].TableList[0]), Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                    KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[iii].AStarGreedyString = this;
                                }
                                for (int h = 0; h < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    KingOnTable[i].WinOcuuredatChiled += SumOfObjects(KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                }

                                for (int h = 0; h < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    KingOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                }
                                if (KingOnTable[i].WinOcuuredatChiled > 0 || KingOnTable[i].LoseOcuuredatChiled[0] < 0)
                                    return;
                            }
                            else if (Is == 3)//when is suitable for deeper
                            {
                                object OOOO = new object();
                                lock (OOOO)
                                {
                                    //when search finished stop and return
                                    bool ac = false;
                                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                    {
                                        return;
                                    }
                                }

                                object O1 = new object();
                                lock (O1)
                                {
                                    int Ord = Order, ii1 = ii, jj1 = jj, i1 = i, j1 = j;
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                                    H.Wait();
                                    H.Dispose();
                                    for (int h = 0; h < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null; h++)
                                    {
                                        KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[h].AStarGreedyString = this;
                                        KingOnTable[i].WinOcuuredatChiled += SumOfObjects(KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                    }
                                    for (int h = 0; h < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null; h++)
                                    {
                                        KingOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[h], Order * -1);
                                    }
                                    if (KingOnTable[i].WinOcuuredatChiled > 0 || KingOnTable[i].LoseOcuuredatChiled[0] < 0)
                                        return;
                                }
                            }
                            else//otherwise
                            {
                                object OOOO = new object();
                                lock (OOOO)
                                {
                                    //when search finished stop and return
                                    bool ac = false;
                                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                    {
                                        return;
                                    }
                                }
                                object OO1 = new object();
                                lock (OO1)
                                {
                                    a = Color.Gray;
                                    if (Order == -1)
                                    {
                                        a = Color.Brown;
                                    }

                                    Task<bool> ah4 = Task.Factory.StartNew(() => FullGameThinkingTree(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                                    ah4.Wait();
                                    ah4.Dispose();
                                }
                            }
                        }
                    });
                    FullGameFoundF = FullGameFound;
                }
                catch (Exception t) { Log(t); }
            }
        }

        //deeper leaf found
        public void FoundOfLeafDepenOfKindFullGameCastling(Color a, ref bool FullGameFoundF, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            object P = new object();
            lock (P)
            {
                try
                {
                    bool FullGameFound = FullGameFoundF;
                    ParallelOptions po = new ParallelOptions
                    {
                        MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                    };
                    if (!(CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null))
                        return;

                    Parallel.For(0, CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count, j =>
                    {
                        object OOOOO = new object();
                        lock (OOOOO)
                        {
                            bool ac = false;
                            Task<bool> ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 7));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                return;
                            }
                            //when search finished stop and return
                            Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                            {
                                return;
                            }
                        }
                        //determine about validity of list on current and deeper return true when successfull
                        bool IA = false;
                        Task<bool> ah2 = Task.Factory.StartNew(() => IA = IsNonValidityAllTablesHeuristicsAndMore(7, Order, i, j));
                        ah2.Wait();
                        ah2.Dispose();

                        //determine about situation of deeper against other lists computation in 4 state
                        int Is = 0;
                        Task<int> ah3 = Task.Factory.StartNew(() => Is = IsSuitableForInitiation(i, j, 7));
                        ah3.Wait();
                        ah3.Dispose();
                        if (!IA)
                        {
                            Is = 4;
                        }
                        //when is suitable for computational operation on lists
                        if (Is == 4)
                        {
                            object OOOO = new object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                bool ac = false;
                                Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                {
                                    return;
                                }
                            }
                            FullGameFound = true;

                            StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                            Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                            H.Wait();
                            H.Dispose();
                            for (int h = 0; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null; h++)
                            {
                                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h].AStarGreedyString = this;
                                CastlingOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h], Order * -1);
                            }
                            for (int h = 0; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null; h++)
                            {
                                CastlingOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h], Order * -1);
                            }
                            if (CastlingOnTable[i].WinOcuuredatChiled > 0 || CastlingOnTable[i].LoseOcuuredatChiled[0] < 0)
                                return;
                        }
                        else
                        {
                            //when is suitable for leafer
                            if (Is == 2)
                            {
                                for (int iii = 0; iii < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy[iii].TableList != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                                {
                                    object OOOO = new object();
                                    lock (OOOO)
                                    {
                                        FirstTraversalTree = false;

                                        //when search finished stop and return
                                        bool ac = false;
                                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                        ah1.Wait();
                                        ah1.Dispose();
                                        if (ac)
                                        {
                                            return;
                                        }
                                    }

                                    CastlingOnTable[i].CastlingThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(CloneATable(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[iii].TableList[0]), Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                    CastlingOnTable[i].CastlingThinking[0].AStarGreedy[iii].AStarGreedyString = this;
                                }
                                for (int h = 0; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null; h++)
                                {
                                    CastlingOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h], Order * -1);
                                }

                                for (int h = 0; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null; h++)
                                {
                                    CastlingOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h], Order * -1);
                                }
                                if (CastlingOnTable[i].WinOcuuredatChiled > 0 || CastlingOnTable[i].LoseOcuuredatChiled[0] < 0)
                                    return;
                            }
                            else if (Is == 3)//when is suitable for deeper
                            {
                                object OOOO = new object();
                                lock (OOOO)
                                {
                                    //when search finished stop and return
                                    bool ac = false;
                                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                    {
                                        return;
                                    }
                                }

                                object O1 = new object();
                                lock (O1)
                                {
                                    int Ord = Order, ii1 = ii, jj1 = jj, i1 = i, j1 = j;
                                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                                    H.Wait();
                                    H.Dispose();
                                    for (int h = 0; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null; h++)
                                    {
                                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h].AStarGreedyString = this;
                                        CastlingOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h], Order * -1);
                                    }
                                    for (int h = 0; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null; h++)
                                    {
                                        CastlingOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h], Order * -1);
                                    }
                                    if (CastlingOnTable[i].WinOcuuredatChiled > 0 || CastlingOnTable[i].LoseOcuuredatChiled[0] < 0)
                                        return;
                                }
                            }
                            else//otherwise
                            {
                                object OOOO = new object();
                                lock (OOOO)
                                {
                                    //when search finished stop and return
                                    bool ac = false;
                                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                    {
                                        return;
                                    }
                                }
                                object OO1 = new object();
                                lock (OO1)
                                {
                                    a = Color.Gray;
                                    if (Order == -1)
                                    {
                                        a = Color.Brown;
                                    }

                                    Task<bool> ah4 = Task.Factory.StartNew(() => FullGameThinkingTree(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                                    ah4.Wait();
                                    ah4.Dispose();

                                }
                            }
                        }
                    });
                    FullGameFoundF = FullGameFound;
                }
                catch (Exception t) { Log(t); }
            }
        }
        public void FoundOfLeafDepenOfKindFullGame(int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int ik, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            LeafSemaphoreIndex = true;

            object a1 = new object();
            lock (a1)
            {
                //heigth justice math and logic
                /*   if (MaxAStarGreedy < MaxAStarGreedy + CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy))
                   {
                       MaxAStarGreedy = MaxAStarGreedy + CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy);
                   }
                   */
                if (
                     /*(MaxAStarGreedy <= CurrentMaxLevel + PlatformHelper.ProcessorCount) &&*/
                     ((MaxAStarGreedy < StoreInitMaxAStarGreedy + PlatformHelper.ProcessorCount
                                                                ) || (CurrentMaxLevel < StoreInitMaxAStarGreedyEqual && SStopInitMaxAStarGreedy)))// if (MaxAStarGreedy < indexStep * PlatformHelper.ProcessorCount)
                {
                    MaxAStarGreedy = CurrentMaxLevel;
                }
                else
                {
                    if (CurrentMaxLevel >= MaxAStarGreedy)
                    return;
                }

                object Omm1 = new object();
                lock (Omm1)
                {
                    /*if (CurrentMaxLevel >= MaxAStarGreedy)
                        return;
                    else
                    {
                        //if (CurrentMaxLevel < CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy))
                        //CurrentMaxLevel = CurrentMaxLevel + 1;
                        if (CurrentMaxLevel < CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy))
                             CurrentMaxLevel = CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy);
                    }*/
                    /* if (iAStarGreedy < 0 //&& iAStarGreedy < MaxDuringLevelThinkingCreation
                )
                     {
                         IS = true;
                     }*/
                }
                bool FullGameFound = false;
                object O = new object();
                lock (O)
                {
                    //Gray
                    if (Order == 1)
                    {
                        //parallel full game all deeper foundation
                        Color a = Color.Gray;
                        Task output = Task.Factory.StartNew(() =>
                        {
                            //if (!feedCancellationTokenSource.IsCancellationRequested)
                            {
                                ParallelOptions po = new ParallelOptions
                                {
                                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                                }; Parallel.Invoke(() =>
         {
             //soldier
             for (int i = 0; i < SodierMidle; i++)
             {
                 FoundOfLeafDepenOfKindFullGameBaseS(i, a, ref FullGameFound, CloneATable(Table), Order, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy);
             }
         }, () =>
         {
             //elephant
             for (int i = 0; i < ElefantMidle; i++)
             {
                 FoundOfLeafDepenOfKindFullGameBaseE(i, a, ref FullGameFound, CloneATable(Table), Order, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy);
             }
         }, () =>
         {
             //hourse
             for (int i = 0; i < HourseMidle; i++)
             {
                 FoundOfLeafDepenOfKindFullGameBaseH(i, a, ref FullGameFound, CloneATable(Table), Order, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy);
             }
         }, () =>
         {
             //Castle
             for (int i = 0; i < CastleMidle; i++)
             {
                 FoundOfLeafDepenOfKindFullGameBaseC(i, a, ref FullGameFound, CloneATable(Table), Order, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy);
             }
         }, () =>
         {
             //minister
             for (int i = 0; i < MinisterMidle; i++)
             {
                 FoundOfLeafDepenOfKindFullGameBaseM(i, a, ref FullGameFound, CloneATable(Table), Order, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy);
             }
         }, () =>
         {
             //king
             for (int i = 0; i < KingMidle; i++)
             {
                 FoundOfLeafDepenOfKindFullGameBaseK(i, a, ref FullGameFound, CloneATable(Table), Order, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy);
             }
         }, () =>
         {
             //king
             for (int i = 0; i < 1; i++)
             {
                 FoundOfLeafDepenOfKindFullGameBaseA(i, a, ref FullGameFound, CloneATable(Table), Order, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy);
             }
         });
                            }
                        });
                        output.Wait(); output.Dispose();
                    }
                    else//Brown
                    {
                        Color a = Color.Brown;
                        Task output = Task.Factory.StartNew(() =>
                        {
                            //if (!feedCancellationTokenSource.IsCancellationRequested)
                            {
                                ParallelOptions po = new ParallelOptions
                                {
                                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                                }; Parallel.Invoke(() =>
         {
             //soldier
             for (int i = SodierMidle; i < SodierHigh; i++)
             {
                 FoundOfLeafDepenOfKindFullGameBaseS(i, a, ref FullGameFound, CloneATable(Table), Order, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy);
             }
         }, () =>
         {
             //elephant
             for (int i = ElefantMidle; i < ElefantHigh; i++)
             {
                 FoundOfLeafDepenOfKindFullGameBaseE(i, a, ref FullGameFound, CloneATable(Table), Order, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy);
             }
         }, () =>
         {
             //hourse
             for (int i = HourseMidle; i < HourseHight; i++)
             {
                 FoundOfLeafDepenOfKindFullGameBaseH(i, a, ref FullGameFound, CloneATable(Table), Order, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy);
             }
         }, () =>
         {
             //Castle
             for (int i = CastleMidle; i < CastleHigh; i++)
             {
                 FoundOfLeafDepenOfKindFullGameBaseC(i, a, ref FullGameFound, CloneATable(Table), Order, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy);
             }
         }, () =>
         {
             //minister
             for (int i = MinisterMidle; i < MinisterHigh; i++)
             {
                 FoundOfLeafDepenOfKindFullGameBaseM(i, a, ref FullGameFound, CloneATable(Table), Order, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy);
             }
         }, () =>
         {
             //king
             for (int i = KingMidle; i < KingHigh; i++)
             {
                 FoundOfLeafDepenOfKindFullGameBaseK(i, a, ref FullGameFound, CloneATable(Table), Order, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy);
             }
         }, () =>
         {
             //king
             for (int i = 0; i < 1; i++)
             {
                 FoundOfLeafDepenOfKindFullGameBaseA(i, a, ref FullGameFound, CloneATable(Table), Order, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy);
             }
         });
                            }
                        });
                        output.Wait(); output.Dispose();
                    }
                }
                //when not occured untile now computational op
                if (!FullGameFound || SStopInitMaxAStarGreedy)
                {
                    object O1 = new object();
                    lock (O1)
                    {
                        //when search finished stop and return
                        bool ac = false;
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            return;
                        }
                        StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                        Color a = Color.Gray;
                        if (Order == -1)
                        {
                            a = Color.Brown;
                        }

                        Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + AllDraw.StoreInitMaxAStarGreedy - AllDraw.MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                        H.Wait();
                        H.Dispose();
                    }
                }

                return;
            }
        }

        public void FoundOfLeafDepenOfKindFullGameBaseS(int i, Color a, ref bool FullGameFoundB, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int ik, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            LeafSemaphoreIndex = true;

            object a1 = new object();
            lock (a1)
            {
                bool FullGameFound = FullGameFoundB;
                object OOOO = new object();
                lock (OOOO)
                {
                    //when search finished stop and return
                    bool ac = false;
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                    {
                        return;
                    }
                }
                object P = new object();
                lock (P)
                {
                    Task ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameSoldeir(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                    ah.Wait();
                    ah.Dispose();
                }
                FullGameFoundB = FullGameFound;

                return;
            }
        }
        public void FoundOfLeafDepenOfKindFullGameBaseE(int i, Color a, ref bool FullGameFoundB, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int ik, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            LeafSemaphoreIndex = true;

            object a1 = new object();
            lock (a1)
            {
                bool FullGameFound = FullGameFoundB;
                object OOOO = new object();
                lock (OOOO)
                {
                    //when search finished stop and return
                    bool ac = false;
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                    {
                        return;
                    }
                }
                object P = new object();
                lock (P)
                {
                    Task ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameElepahnt(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                    ah.Wait();
                    ah.Dispose();
                }

                FullGameFoundB = FullGameFound;
                return;
            }
        }
        public void FoundOfLeafDepenOfKindFullGameBaseH(int i, Color a, ref bool FullGameFoundB, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int ik, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            LeafSemaphoreIndex = true;

            object a1 = new object();
            lock (a1)
            {
                bool FullGameFound = FullGameFoundB;
                object OOOO = new object();
                lock (OOOO)
                {
                    //when search finished stop and return
                    bool ac = false;
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                    {
                        return;
                    }
                }
                object P = new object();
                lock (P)
                {
                    Task ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameHourse(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                    ah.Wait();
                    ah.Dispose();
                }
                FullGameFoundB = FullGameFound;

                return;
            }
        }
        public void FoundOfLeafDepenOfKindFullGameBaseC(int i, Color a, ref bool FullGameFoundB, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int ik, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            LeafSemaphoreIndex = true;

            object a1 = new object();
            lock (a1)
            {
                bool FullGameFound = FullGameFoundB;
                object OOOO = new object();
                lock (OOOO)
                {
                    //when search finished stop and return
                    bool ac = false;
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                    {
                        return;
                    }
                }
                object P = new object();
                lock (P)
                {
                    Task ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameCastle(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                    ah.Wait();
                    ah.Dispose();
                }
                FullGameFoundB = FullGameFound;
                return;
            }
        }
        public void FoundOfLeafDepenOfKindFullGameBaseM(int i, Color a, ref bool FullGameFoundB, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int ik, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            LeafSemaphoreIndex = true;

            object a1 = new object();
            lock (a1)
            {
                bool FullGameFound = FullGameFoundB;
                object OOOO = new object();
                lock (OOOO)
                {
                    //when search finished stop and return
                    bool ac = false;
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                    {
                        return;
                    }
                }
                object P = new object();
                lock (P)
                {
                    Task ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameMinister(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                    ah.Wait();
                    ah.Dispose();
                }
                FullGameFoundB = FullGameFound;
                return;
            }
        }
        public void FoundOfLeafDepenOfKindFullGameBaseK(int i, Color a, ref bool FullGameFoundB, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int ik, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            LeafSemaphoreIndex = true;

            object a1 = new object();
            lock (a1)
            {
                bool FullGameFound = FullGameFoundB;

                object OOOO = new object();
                lock (OOOO)
                {
                    //when search finished stop and return
                    bool ac = false;
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                    {
                        return;
                    }
                }
                object P = new object();
                lock (P)
                {
                    Task ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameKing(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                    ah.Wait();
                    ah.Dispose();
                }
                FullGameFoundB = FullGameFound;
                return;
            }
        }
        public void FoundOfLeafDepenOfKindFullGameBaseA(int i, Color a, ref bool FullGameFoundB, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int ik, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            LeafSemaphoreIndex = true;

            object a1 = new object();
            lock (a1)
            {
                bool FullGameFound = FullGameFoundB;
                object OOOO = new object();
                lock (OOOO)
                {
                    //when search finished stop and return
                    bool ac = false;
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                    {
                        return;
                    }
                }
                object P = new object();
                lock (P)
                {
                    Task ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameCastling(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                    ah.Wait();
                    ah.Dispose();
                }
                FullGameFoundB = FullGameFound;
                return;
            }
        }
        //for regard all branches of leaf victory node
        public void MakeRegardAllCheckMateBranches(AllDraw A, int Order)
        {
            object a = new object();
            lock (a)
            {
                int COrder = Order;
                int CDummy = ChessRules.CurrentOrder;
                //Gray
                if (Order == 1)
                {
                    //soldier
                    for (int i = 0; i < SodierMidle; i++)
                    {
                        for (int j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinkingQuantum[0] != null && j < A.SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                        {
                            //make regard
                            Task<double> ah = Task.Factory.StartNew(() => A.SolderesOnTable[i].SoldierThinkingQuantum[0].PenaltyRegardListSolder[i].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (int ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinkingQuantum[0] != null && ii < A.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //elephant
                    for (int i = 0; i < ElefantMidle; i++)
                    {
                        for (int j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinkingQuantum[0] != null && j < A.ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                        {
                            //make regard
                            Task<double> ah = Task.Factory.StartNew(() => A.ElephantOnTable[i].ElefantThinkingQuantum[0].PenaltyRegardListElefant[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (int ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ii < A.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //hourse
                    for (int i = 0; i < HourseMidle; i++)
                    {
                        for (int j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinkingQuantum[0] != null && j < A.HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                        {
                            //make regard
                            Task<double> ah = Task.Factory.StartNew(() => A.HoursesOnTable[i].HourseThinkingQuantum[0].PenaltyRegardListHourse[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (int ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinkingQuantum[0] != null && ii < A.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //Castle
                    for (int i = 0; i < CastleMidle; i++)
                    {
                        for (int j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinkingQuantum[0] != null && j < A.CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                        {
                            //make regard
                            Task<double> ah = Task.Factory.StartNew(() => A.CastlesOnTable[i].CastleThinkingQuantum[0].PenaltyRegardListCastle[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (int ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinkingQuantum[0] != null && ii < A.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //minister
                    for (int i = 0; i < MinisterMidle; i++)
                    {
                        for (int j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinkingQuantum[0] != null && j < A.MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                        {
                            //make regard
                            Task<double> ah = Task.Factory.StartNew(() => A.MinisterOnTable[i].MinisterThinkingQuantum[0].PenaltyRegardListMinister[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (int ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinkingQuantum[0] != null && ii < A.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //king
                    for (int i = 0; i < KingMidle; i++)
                    {
                        for (int j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinkingQuantum[0] != null && j < A.KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                        {
                            //make regard
                            Task<double> ah = Task.Factory.StartNew(() => A.KingOnTable[i].KingThinkingQuantum[0].PenaltyRegardListKing[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (int ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinkingQuantum[0] != null && ii < A.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }

                    for (int i = 0; i < 1; i++)
                    {
                        for (int j = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && j < A.CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //make regard
                            Task<double> ah = Task.Factory.StartNew(() => A.CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (int ii = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && ii < A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                }
                else//Brown
                {
                    //soldier
                    for (int i = SodierMidle; i < SodierHigh; i++)
                    {
                        for (int j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinkingQuantum[0] != null && j < A.SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                        {
                            //make regard
                            Task<double> ah = Task.Factory.StartNew(() => A.SolderesOnTable[i].SoldierThinkingQuantum[0].PenaltyRegardListSolder[i].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (int ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinkingQuantum[0] != null && ii < A.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //elephant
                    for (int i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        for (int j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinkingQuantum[0] != null && j < A.ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                        {
                            //make regard
                            Task<double> ah = Task.Factory.StartNew(() => A.ElephantOnTable[i].ElefantThinkingQuantum[0].PenaltyRegardListElefant[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (int ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ii < A.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //hourse
                    for (int i = HourseMidle; i < HourseHight; i++)
                    {
                        for (int j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinkingQuantum[0] != null && j < A.HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                        {
                            //make regard
                            Task<double> ah = Task.Factory.StartNew(() => A.HoursesOnTable[i].HourseThinkingQuantum[0].PenaltyRegardListHourse[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (int ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinkingQuantum[0] != null && ii < A.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //Castle
                    for (int i = CastleMidle; i < CastleHigh; i++)
                    {
                        for (int j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinkingQuantum[0] != null && j < A.CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                        {
                            //make regard
                            Task<double> ah = Task.Factory.StartNew(() => A.CastlesOnTable[i].CastleThinkingQuantum[0].PenaltyRegardListCastle[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (int ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinkingQuantum[0] != null && ii < A.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //minister
                    for (int i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        for (int j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinkingQuantum[0] != null && j < A.MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                        {
                            //make regard
                            Task<double> ah = Task.Factory.StartNew(() => A.MinisterOnTable[i].MinisterThinkingQuantum[0].PenaltyRegardListMinister[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (int ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinkingQuantum[0] != null && ii < A.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                    //king
                    for (int i = KingMidle; i < MinisterHigh; i++)
                    {
                        for (int j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinkingQuantum[0] != null && j < A.KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                        {
                            //make regard
                            Task<double> ah = Task.Factory.StartNew(() => A.KingOnTable[i].KingThinkingQuantum[0].PenaltyRegardListKing[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();
                            A.KingOnTable[i].KingThinkingQuantum[0].PenaltyRegardListKing[j].LearningAlgorithmRegard();
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (int ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinkingQuantum[0] != null && ii < A.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }

                    for (int i = 0; i < 1; i++)
                    {
                        for (int j = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && j < A.CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //make regard
                            Task<double> ah = Task.Factory.StartNew(() => A.CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (int ii = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && ii < A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                            {
                                Task ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    }
                }
            }
        }

        //when all branches of root is lose and close ignore of learning autamata option
        /*   int[,] HeuristicAStarGreadySearchPenalties(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
           {
               Object a1 = new Object();
               lock (a1)
               {
                   ChessRules AB = null;
                   int ToCheckMate = -1, ForCheckMate = -1, j, i;
                   List<int> Founded = new List<int>();
                   int DummyOrder = Order;
                   int DummyCurrentOrder = ChessRules.CurrentOrder;
                   bool AA = false;
                   int Do = 0;
                   int[,] TableHeuristic = new int[8, 8];
                   //For Every Soldeir
                   for (i = 0; i < SodierMidle; i++)
                   {
                       //For Every Soldier Movments AStarGreedy.
                       for (int k = 0; k < AllDraw.SodierMovments; k++)
                           //When There is an Movment in such situation.
                           for (j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum[k] != null && SolderesOnTable[i].SoldierThinkingQuantum[k] != null && j < SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder.Count; j++)
                           {
                               {
                                   //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                   int CDummy = ChessRules.CurrentOrder;
                                   int COrder = Order;
                                   ChessRules.CurrentOrder *= -1;
                                   Order *= -1;
                                   Do = 0;
                                   if (UsePenaltyRegardMechnisamT)
                                   {
                                       for (int ij = 0; ij < SolderesOnTable[i].SoldierThinkingQuantum[k].AStarGreedy.Count - 1; ij++)
                                       {
                                           int D = Do;
                                           var ah = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinkingQuantum[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref D, SolderesOnTable[i].SoldierThinkingQuantum[k].AStarGreedy[ij]));
                                           ah.Wait();
                                           ah.Dispose();
                                           Do = D;
                                       }

                                       Order = COrder;
                                       ChessRules.CurrentOrder = CDummy;
                                       ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                           continue;
                                   }
                                   Order = COrder;
                                   ChessRules.CurrentOrder = CDummy;
                                   if ((SolderesOnTable[i].SoldierThinkingQuantum[k].PenaltyRegardListSolder[j].IsPenaltyAction() != 0 && SolderesOnTable[i].SoldierThinkingQuantum[k].PenaltyRegardListSolder[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || SolderesOnTable[i].WinOcuuredatChiled >= 1 || SolderesOnTable[i].WinOcuuredatChiled >= 2 || SolderesOnTable[i].WinOcuuredatChiled >= 3)
                                   {
                                       //Set Table and Heuristic Value and Syntax.
                                       Act = true;
                                       Object On = new Object();
                                       lock (On)
                                       {
                                           AllDraw.LastRowQ = SolderesOnTable[i].SoldierThinkingQuantum[k].Row;
                                           AllDraw.LastColumnQ = SolderesOnTable[i].SoldierThinkingQuantum[k].Column;
                                           AllDraw.NextRowQ = SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0];
                                           AllDraw.NextColumnQ = SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1];

                                           Less = SolderesOnTable[i].SoldierThinkingQuantum[k].NumberOfPenalties;
                                       }

                                       TableHeuristic = SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder[j];

                                       Object O = new Object();
                                       lock (O)
                                       {
                                           ThingsConverter.ActOfClickEqualTow = true;
                                       }
                                       SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder[j], Order, false, i);
                                       int Sign = 1;
                                       if (a == Color.Brown)
                                           Sign = -1;

                                       //If there is Soldier Convert.
                                       if (SolderesOnTable[i].Convert)
                                       {
                                           if (SolderesOnTable[i].ConvertedToMinister)
                                               TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                           else if (SolderesOnTable[i].ConvertedToCastle)
                                               TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                           else if (SolderesOnTable[i].ConvertedToHourse)
                                               TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                           else if (SolderesOnTable[i].ConvertedToElefant)
                                               TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 2 * Sign;
                                       }
                                       RegardOccurred = true;
                                       continue;
                                   }
                                   //When There is No Movments in Such Order Enemy continue.
                                   Object ol = new Object();
                                   lock (ol)
                                   {
                                       if (Order != AllDraw.OrderPlateDraw)
                                           if (SolderesOnTable[i].SoldierThinkingQuantum[0].NumberOfPenalties < Less)
                                               continue;
                                       //When There is greater Heuristic Movments.
                                       if (SolderesOnTable[i].SoldierThinkingQuantum[0].NumberOfPenalties < Less)
                                       {
                                           //retrive table of current Heuristic.
                                           int[,] TableS = SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder[j];
                                           int[,] TableSS = SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder[j];
                                           //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                           if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                           {
                                               if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                   continue;
                                           }
                                           //When there is not Penalty regard mechanism.
                                           AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 1, CloneATable(TableS), Order, SolderesOnTable[i].SoldierThinkingQuantum[k].Row, SolderesOnTable[i].SoldierThinkingQuantum[k].Column);
                                           //If there is kish or kshachamaz Order.
                                           if (AB.Check(CloneATable(TableS), Order))
                                           {
                                               //When Order is Gray.
                                               if (Order == 1)
                                               {
                                                   //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                   if (AB.CheckGray)
                                                       continue;
                                               }
                                               else
                                               {
                                                   //Continue when CheckBrown and AStarGreadyFirstSearch.
                                                   if (AB.CheckBrown)
                                                       continue;
                                               }
                                           }
                                           //Sodleirs Initiate.
                                           RW1 = i;
                                           CL1 = k;
                                           Ki1 = j;
                                           RW2 = -1;
                                           CL2 = -1;
                                           Ki2 = -1;
                                           RW3 = -1;
                                           CL3 = -1;
                                           Ki3 = -1;
                                           RW4 = -1;
                                           CL4 = -1;
                                           Ki4 = -1;
                                           RW5 = -1;
                                           CL5 = -1;
                                           Ki5 = -1;
                                           RW6 = -1;
                                           CL6 = -1;
                                           Ki6 = -1;
                                           //Set Max of Soldier.
                                           MaxLess1 = (SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].NumberOfPenalties
                                               );
                                           //When Soldeirs is Greater than Others these Set Max.
                                           if (MaxLess1 > MaxLess2)
                                               MaxLess2 = -1;
                                           if (MaxLess1 > MaxLess3)
                                               MaxLess3 = -1;
                                           if (MaxLess1 > MaxLess4)
                                               MaxLess4 = -1;
                                           if (MaxLess1 > MaxLess5)
                                               MaxLess5 = -1;
                                           if (MaxLess1 > MaxLess6)
                                               MaxLess6 = -1;
                                           if (AStarGreedyi == 1)
                                           {
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {
                                                   }
                                                   else//If Order is Brown.
                                                   {
                                                   }
                                               }
                                               //Set Table and Heuristic Value and Syntax.
                                               Act = true;
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRowQ = SolderesOnTable[i].SoldierThinkingQuantum[k].Row;
                                                   AllDraw.LastColumnQ = SolderesOnTable[i].SoldierThinkingQuantum[k].Column;
                                                   AllDraw.NextRowQ = SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0];
                                                   AllDraw.NextColumnQ = SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1];
                                               }
                                               Less = SolderesOnTable[i].SoldierThinkingQuantum[k].NumberOfPenalties;

                                               TableHeuristic = SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder[j];

                                               Object O1 = new Object();
                                               lock (O1)
                                               {
                                                   ThingsConverter.ActOfClickEqualTow = true;
                                               }
                                               SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder[j], Order, false, i);
                                               int Sign = 1;
                                               if (a == Color.Brown)
                                                   Sign = -1;
                                               //If there is Soldier Convert.
                                               if (SolderesOnTable[i].Convert)
                                               {
                                                   if (SolderesOnTable[i].ConvertedToMinister)
                                                       TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                                   else if (SolderesOnTable[i].ConvertedToCastle)
                                                       TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                                   else if (SolderesOnTable[i].ConvertedToHourse)
                                                       TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                                   else if (SolderesOnTable[i].ConvertedToElefant)
                                                       TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 2 * Sign;
                                               }
                                           }
                                       }
                                       else
                                       {
                                           //Set Table and Heuristic Value and Syntax.
                                           if (AStarGreedyi == 1)
                                           {
                                               //Found of Max Non Probable Movments.
                                               Founded.Clear();
                                               int LessB = Int32.MinValue;
                                               BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                               RW1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                               CL1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                               Ki1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                               if (Founded[0] != MaxSoldeirFounded)
                                                   continue;
                                               Act = true;
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRowQ = SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].Row;
                                                   AllDraw.LastColumnQ = SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].Column;
                                                   AllDraw.NextRowQ = SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0];
                                                   AllDraw.NextColumnQ = SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1];
                                               }
                                               Less = SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].ReturnHeuristic(RW1, Ki1, Order, false, ref HaveKilled);

                                               TableHeuristic = SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].TableListSolder[Ki1];

                                               Object O1 = new Object();
                                               lock (O1)
                                               {
                                                   ThingsConverter.ActOfClickEqualTow = true;
                                               }
                                               SolderesOnTable[RW1].ConvertOperation(SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][1], a, SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].TableListSolder[Ki1], Order, false, i);
                                               int Sign = 1;
                                               if (a == Color.Brown)
                                                   Sign = -1;
                                               //If there is Soldier Convert.
                                               if (SolderesOnTable[RW1].Convert)
                                               {
                                                   if (SolderesOnTable[RW1].ConvertedToMinister)
                                                       TableHeuristic[SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][1]] = 5 * Sign;
                                                   else if (SolderesOnTable[RW1].ConvertedToCastle)
                                                       TableHeuristic[SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][1]] = 4 * Sign;
                                                   else if (SolderesOnTable[RW1].ConvertedToHourse)
                                                       TableHeuristic[SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][1]] = 3 * Sign;
                                                   else if (SolderesOnTable[RW1].ConvertedToElefant)
                                                       TableHeuristic[SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][1]] = 2 * Sign;
                                               }
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {
                                                   }
                                                   else//If Order is Brown.
                                                   {
                                                   }
                                               }
                                           }
                                       }
                                   }
                               }
                           }

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;
                   }
                   //Do For Remaining Objects same as Soldeir Documentation.
                   for (i = 0; i < ElefantMidle; i++)
                   {
                       for (int k = 0; k < AllDraw.ElefantMovments; k++)
                           for (j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum[k] != null && ElephantOnTable[i].ElefantThinkingQuantum[k] != null && j < ElephantOnTable[i].ElefantThinkingQuantum[k].TableListElefant.Count; j++)
                           {
                               {
                                   //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                   int CDummy = ChessRules.CurrentOrder;
                                   int COrder = Order;
                                   ChessRules.CurrentOrder *= -1;
                                   Order *= -1;
                                   Do = 0;
                                   if (UsePenaltyRegardMechnisamT)
                                   {
                                       for (int ij = 0; ij < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count - 1; ij++)
                                       {
                                           int D = Do;
                                           var ah = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinkingQuantum[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref D, SolderesOnTable[i].SoldierThinkingQuantum[k].AStarGreedy[ij]));
                                           ah.Wait();
                                           ah.Dispose();
                                           Do = D;
                                       }
                                       Order = COrder;
                                       ChessRules.CurrentOrder = CDummy;
                                       ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                           continue;
                                   }
                                   Order = COrder;
                                   ChessRules.CurrentOrder = CDummy;
                                   if ((ElephantOnTable[i].ElefantThinkingQuantum[k].PenaltyRegardListElefant[j].IsPenaltyAction() != 0 && ElephantOnTable[i].ElefantThinkingQuantum[k].PenaltyRegardListElefant[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || ElephantOnTable[i].WinOcuuredatChiled >= 1 || ElephantOnTable[i].WinOcuuredatChiled >= 2 || ElephantOnTable[i].WinOcuuredatChiled >= 3)
                                   {
                                       Object On = new Object();
                                       lock (On)
                                       {
                                           AllDraw.LastRowQ = ElephantOnTable[i].ElefantThinkingQuantum[k].Row;
                                           AllDraw.LastColumnQ = ElephantOnTable[i].ElefantThinkingQuantum[k].Column;
                                           AllDraw.NextRowQ = ElephantOnTable[i].ElefantThinkingQuantum[k].RowColumnElefant[j][0];
                                           AllDraw.NextColumnQ = ElephantOnTable[i].ElefantThinkingQuantum[k].RowColumnElefant[j][1];

                                           Act = true;
                                           Less = ElephantOnTable[i].ElefantThinkingQuantum[k].NumberOfPenalties;
                                       }
                                       TableHeuristic = ElephantOnTable[i].ElefantThinkingQuantum[k].TableListElefant[j];
                                       RegardOccurred = true;
                                       continue;
                                   }
                                   Object ol = new Object();
                                   lock (ol)
                                   {
                                       //When There is No Movments in Such Order Enemy continue.
                                       if (Order != AllDraw.OrderPlateDraw)
                                           if (ElephantOnTable[i].ElefantThinkingQuantum[0].NumberOfPenalties < Less)
                                               continue;
                                       //When There is greater Heuristic Movments.
                                       if (ElephantOnTable[i].ElefantThinkingQuantum[0].NumberOfPenalties < Less)
                                       {
                                           //retrive table of current Heuristic.
                                           int[,] TableS = ElephantOnTable[i].ElefantThinkingQuantum[k].TableListElefant[j];
                                           int[,] TableSS = ElephantOnTable[i].ElefantThinkingQuantum[k].TableListElefant[j];
                                           //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                           if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                           {
                                               if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                   continue;
                                           }
                                           //When there is not Penalty regard mechanism.
                                           AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 2, CloneATable(TableS), Order, -1, -1);
                                           //If there is kish or kshachamaz Order.
                                           if (AB.Check(CloneATable(TableS), Order))
                                           {
                                               //When Order is Gray.
                                               if (Order == 1)
                                               {
                                                   //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                   if (AB.CheckGray)
                                                       continue;
                                               }
                                               else
                                               {
                                                   //Continue when CheckBrown and AStarGreadyFirstSearch.
                                                   if (AB.CheckBrown)
                                                       continue;
                                               }
                                           }
                                           RW2 = i;
                                           CL2 = k;
                                           Ki2 = j;
                                           RW1 = -1;
                                           CL1 = -1;
                                           Ki1 = -1;
                                           RW3 = -1;
                                           CL3 = -1;
                                           Ki3 = -1;
                                           RW4 = -1;
                                           CL4 = -1;
                                           Ki4 = -1;
                                           RW5 = -1;
                                           CL5 = -1;
                                           Ki5 = -1;
                                           RW6 = -1;
                                           CL6 = -1;
                                           Ki6 = -1;
                                           MaxLess2 = (ElephantOnTable[RW2].ElefantThinkingQuantum[CL2].NumberOfPenalties);
                                           if (MaxLess2 > MaxLess1)
                                               MaxLess1 = -1;
                                           if (MaxLess2 > MaxLess3)
                                               MaxLess3 = -1;
                                           if (MaxLess2 > MaxLess4)
                                               MaxLess4 = -1;
                                           if (MaxLess2 > MaxLess5)
                                               MaxLess5 = -1;
                                           if (MaxLess2 > MaxLess6)
                                               MaxLess6 = -1;
                                           if (AStarGreedyi == 1)
                                           {
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {
                                                   }
                                                   else//If Order is Brown.
                                                   {
                                                   }
                                               }
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRowQ = ElephantOnTable[i].ElefantThinkingQuantum[k].Row;
                                                   AllDraw.LastColumnQ = ElephantOnTable[i].ElefantThinkingQuantum[k].Column;
                                                   AllDraw.NextRowQ = ElephantOnTable[i].ElefantThinkingQuantum[k].RowColumnElefant[j][0];
                                                   AllDraw.NextColumnQ = ElephantOnTable[i].ElefantThinkingQuantum[k].RowColumnElefant[j][1];
                                               }
                                               Act = true;
                                               Less = ElephantOnTable[i].ElefantThinkingQuantum[k].NumberOfPenalties;
                                               TableHeuristic = ElephantOnTable[i].ElefantThinkingQuantum[k].TableListElefant[j];
                                           }
                                       }
                                       else
                                       {
                                           if (AStarGreedyi == 1)
                                           {
                                               //Found of Max Non Probable Movments.
                                               Founded.Clear();
                                               int LessB = Int32.MinValue;
                                               BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                               RW2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                               CL2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                               Ki2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                               if (Founded[0] != MaxElephntFounded)
                                                   continue;
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRowQ = ElephantOnTable[RW2].ElefantThinkingQuantum[CL2].Row;
                                                   AllDraw.LastColumnQ = ElephantOnTable[RW2].ElefantThinkingQuantum[CL2].Column;
                                                   AllDraw.NextRowQ = ElephantOnTable[i].ElefantThinkingQuantum[k].RowColumnElefant[j][0];
                                                   AllDraw.NextColumnQ = ElephantOnTable[i].ElefantThinkingQuantum[k].RowColumnElefant[j][1];
                                               }
                                               Act = true;
                                               Less = ElephantOnTable[RW2].ElefantThinkingQuantum[CL2].ReturnHeuristic(RW2, Ki2, Order, false, ref HaveKilled);
                                               TableHeuristic = ElephantOnTable[RW2].ElefantThinkingQuantum[CL2].TableListElefant[Ki2];
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {
                                                   }
                                                   else//If Order is Brown.
                                                   {
                                                   }
                                               }
                                           }
                                       }
                                   }
                               }
                           }

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;
                   }
                   //hourse
                   for (i = 0; i < HourseMidle; i++)
                   {
                       for (int k = 0; k < AllDraw.HourseMovments; k++)
                           for (j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum[k] != null && HoursesOnTable[i].HourseThinkingQuantum[k] != null && j < HoursesOnTable[i].HourseThinkingQuantum[k].TableListHourse.Count; j++)
                           {
                               {
                                   //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                   int CDummy = ChessRules.CurrentOrder;
                                   int COrder = Order;
                                   ChessRules.CurrentOrder *= -1;
                                   Order *= -1;
                                   Do = 0;
                                   if (UsePenaltyRegardMechnisamT)
                                   {
                                       for (int ij = 0; ij < HoursesOnTable[i].HourseThinkingQuantum[k].AStarGreedy.Count - 1; ij++)
                                       {
                                           int D = Do;
                                           var ah = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinkingQuantum[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref D, SolderesOnTable[i].SoldierThinkingQuantum[k].AStarGreedy[ij]));
                                           ah.Wait();
                                           ah.Dispose();
                                           Do = D;
                                       }
                                       Order = COrder;
                                       ChessRules.CurrentOrder = CDummy;
                                       ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                           continue;
                                   }

                                   Order = COrder;
                                   ChessRules.CurrentOrder = CDummy;
                                   if ((HoursesOnTable[i].HourseThinkingQuantum[k].PenaltyRegardListHourse[j].IsPenaltyAction() != 0 && HoursesOnTable[i].HourseThinkingQuantum[k].PenaltyRegardListHourse[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || HoursesOnTable[i].WinOcuuredatChiled >= 1 || HoursesOnTable[i].WinOcuuredatChiled >= 2 || HoursesOnTable[i].WinOcuuredatChiled >= 3)
                                   {
                                       Object On = new Object();
                                       lock (On)
                                       {
                                           AllDraw.LastRowQ = HoursesOnTable[i].HourseThinkingQuantum[k].Row;
                                           AllDraw.LastColumnQ = HoursesOnTable[i].HourseThinkingQuantum[k].Column;
                                           AllDraw.NextRowQ = HoursesOnTable[i].HourseThinkingQuantum[k].RowColumnHourse[j][0];
                                           AllDraw.NextColumnQ = HoursesOnTable[i].HourseThinkingQuantum[k].RowColumnHourse[j][1];
                                           Act = true;
                                           Less = HoursesOnTable[i].HourseThinkingQuantum[k].NumberOfPenalties;
                                       }
                                       TableHeuristic = HoursesOnTable[i].HourseThinkingQuantum[k].TableListHourse[j];
                                       RegardOccurred = true;
                                       continue;
                                   }
                                   Object ol = new Object();
                                   lock (ol)
                                   {
                                       //When There is No Movments in Such Order Enemy continue.
                                       if (Order != AllDraw.OrderPlateDraw)
                                           if (HoursesOnTable[i].HourseThinkingQuantum[0].NumberOfPenalties < Less)
                                               continue;
                                       //When There is greater Heuristic Movments.
                                       if (HoursesOnTable[i].HourseThinkingQuantum[0].NumberOfPenalties < Less)
                                       {
                                           //retrive table of current Heuristic.
                                           int[,] TableS = HoursesOnTable[i].HourseThinkingQuantum[k].TableListHourse[j];
                                           int[,] TableSS = HoursesOnTable[i].HourseThinkingQuantum[k].TableListHourse[j];
                                           {
                                               //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                               if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                               {
                                                   if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                       continue;
                                               }
                                               //When there is not Penalty regard mechanism.
                                               AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 3, CloneATable(TableS), Order, HoursesOnTable[i].HourseThinkingQuantum[k].Row, HoursesOnTable[i].HourseThinkingQuantum[k].Column);
                                               //If there is kish or kshachamaz Order.
                                               if (AB.Check(CloneATable(TableS), Order))
                                               {
                                                   //When Order is Gray.
                                                   if (Order == 1)
                                                   {
                                                       //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                       if (AB.CheckGray)
                                                           continue;
                                                   }
                                                   else
                                                   {
                                                       //Continue when CheckBrown and AStarGreadyFirstSearch.
                                                       if (AB.CheckBrown)
                                                           continue;
                                                   }
                                               }
                                           }
                                           RW3 = i;
                                           CL3 = k;
                                           Ki3 = j;
                                           RW1 = -1;
                                           CL1 = -1;
                                           Ki1 = -1;
                                           RW2 = -1;
                                           CL2 = -1;
                                           Ki2 = -1;
                                           RW4 = -1;
                                           CL4 = -1;
                                           Ki4 = -1;
                                           RW5 = -1;
                                           CL5 = -1;
                                           Ki5 = -1;
                                           RW6 = -1;
                                           CL6 = -1;
                                           Ki6 = -1;
                                           MaxLess3 = (HoursesOnTable[RW3].HourseThinkingQuantum[CL3].NumberOfPenalties);
                                           if (MaxLess3 > MaxLess1)
                                               MaxLess1 = -1;
                                           if (MaxLess3 > MaxLess2)
                                               MaxLess2 = -1;
                                           if (MaxLess3 > MaxLess4)
                                               MaxLess4 = -1;
                                           if (MaxLess3 > MaxLess5)
                                               MaxLess5 = -1;
                                           if (MaxLess3 > MaxLess6)
                                               MaxLess6 = -1;
                                           if (AStarGreedyi == 1)
                                           {
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {
                                                   }
                                                   else//If Order is Brown.
                                                   {
                                                   }
                                               }
                                               //Set Table and Heuristic Value and Syntax.
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRowQ = HoursesOnTable[i].HourseThinkingQuantum[k].Row;
                                                   AllDraw.LastColumnQ = HoursesOnTable[i].HourseThinkingQuantum[k].Column;
                                                   AllDraw.NextRowQ = HoursesOnTable[i].HourseThinkingQuantum[k].RowColumnHourse[j][0];
                                                   AllDraw.NextColumnQ = HoursesOnTable[i].HourseThinkingQuantum[k].RowColumnHourse[j][1];
                                               }
                                               Act = true;
                                               Less = HoursesOnTable[i].HourseThinkingQuantum[k].NumberOfPenalties;
                                               TableHeuristic = HoursesOnTable[i].HourseThinkingQuantum[k].TableListHourse[j];
                                           }
                                       }
                                       else
                                       //Set Table and Heuristic Value and Syntax.
                                       if (AStarGreedyi == 1)
                                       {
                                           //Found of Max Non Probable Movments.
                                           Founded.Clear();
                                           int LessB = Int32.MinValue;
                                           BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                           RW3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                           CL3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                           Ki3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                           if (Founded[0] != MaxHourseFounded)
                                               continue;
                                           Object On = new Object();
                                           lock (On)
                                           {
                                               AllDraw.LastRowQ = HoursesOnTable[RW3].HourseThinkingQuantum[CL3].Row;
                                               AllDraw.LastColumnQ = HoursesOnTable[RW3].HourseThinkingQuantum[CL3].Column;
                                               AllDraw.NextRowQ = HoursesOnTable[i].HourseThinkingQuantum[k].RowColumnHourse[j][0];
                                               AllDraw.NextColumnQ = HoursesOnTable[i].HourseThinkingQuantum[k].RowColumnHourse[j][1];
                                           }
                                           Act = true;
                                           Less = HoursesOnTable[RW3].HourseThinkingQuantum[CL3].ReturnHeuristic(RW3, Ki3, Order, false, ref HaveKilled);
                                           TableHeuristic = HoursesOnTable[RW3].HourseThinkingQuantum[CL3].TableListHourse[Ki3];
                                           Object O = new Object();
                                           lock (O)
                                           {
                                               if (Order == 1)
                                               {
                                               }
                                               else//If Order is Brown.
                                               {
                                               }
                                           }
                                       }
                                   }
                               }
                           }

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;
                   }
                   //Castle
                   for (i = 0; i < CastleMidle; i++)
                   {
                       for (int k = 0; k < AllDraw.CastleMovments; k++)
                           for (j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum[k] != null && CastlesOnTable[i].CastleThinkingQuantum[k] != null && j < CastlesOnTable[i].CastleThinkingQuantum[k].TableListCastle.Count; j++)
                           {
                               {
                                   //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                   int CDummy = ChessRules.CurrentOrder;
                                   int COrder = Order;
                                   ChessRules.CurrentOrder *= -1;
                                   Order *= -1;
                                   Do = 0;
                                   if (UsePenaltyRegardMechnisamT)
                                   {
                                       for (int ij = 0; ij < CastlesOnTable[i].CastleThinkingQuantum[k].AStarGreedy.Count - 1; ij++)
                                       {
                                           int D = Do;
                                           var ah = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinkingQuantum[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref D, SolderesOnTable[i].SoldierThinkingQuantum[k].AStarGreedy[ij]));
                                           ah.Wait();
                                           ah.Dispose();
                                           Do = D;
                                       }
                                       Order = COrder;
                                       ChessRules.CurrentOrder = CDummy;
                                       ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                           continue;
                                   }

                                   Order = COrder;
                                   ChessRules.CurrentOrder = CDummy;
                                   if ((CastlesOnTable[i].CastleThinkingQuantum[k].PenaltyRegardListCastle[j].IsPenaltyAction() != 0 && CastlesOnTable[i].CastleThinkingQuantum[k].PenaltyRegardListCastle[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || CastlesOnTable[i].WinOcuuredatChiled >= 1 || CastlesOnTable[i].WinOcuuredatChiled >= 2 || CastlesOnTable[i].WinOcuuredatChiled >= 3)
                                   {
                                       Object On = new Object();
                                       lock (On)
                                       {
                                           AllDraw.LastRowQ = CastlesOnTable[i].CastleThinkingQuantum[k].Row;
                                           AllDraw.LastColumnQ = CastlesOnTable[i].CastleThinkingQuantum[k].Column;
                                           AllDraw.NextRowQ = CastlesOnTable[i].CastleThinkingQuantum[k].RowColumnCastle[j][0];
                                           AllDraw.NextColumnQ = CastlesOnTable[i].CastleThinkingQuantum[k].RowColumnCastle[j][1];
                                           Act = true;
                                           Less = CastlesOnTable[i].CastleThinkingQuantum[k].NumberOfPenalties;
                                       }
                                       TableHeuristic = CastlesOnTable[i].CastleThinkingQuantum[k].TableListCastle[j];
                                       RegardOccurred = true;
                                       continue;
                                   }
                                   Object ol = new Object();
                                   lock (ol)
                                   {
                                       //When There is No Movments in Such Order Enemy continue.
                                       if (Order != AllDraw.OrderPlateDraw)
                                           if (CastlesOnTable[i].CastleThinkingQuantum[0].NumberOfPenalties < Less) continue;
                                       //When There is greater Heuristic Movments.
                                       if (CastlesOnTable[i].CastleThinkingQuantum[0].NumberOfPenalties < Less)
                                       {
                                           //retrive table of current Heuristic.
                                           int[,] TableS = CastlesOnTable[i].CastleThinkingQuantum[k].TableListCastle[j];
                                           int[,] TableSS = CastlesOnTable[i].CastleThinkingQuantum[k].TableListCastle[j];
                                           //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                           if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                           {
                                               if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                   continue;
                                           }
                                           //When there is not Penalty regard mechanism.
                                           AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 4, CloneATable(TableS), Order, CastlesOnTable[i].CastleThinkingQuantum[k].Row, CastlesOnTable[i].CastleThinkingQuantum[k].Column);
                                           //If there is kish or kshachamaz Order.
                                           if (AB.Check(CloneATable(TableS), Order))
                                           {
                                               //When Order is Gray.
                                               if (Order == 1)
                                               {
                                                   //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                   if (AB.CheckGray)
                                                       continue;
                                               }
                                               else
                                               {
                                                   //Continue when CheckBrown and AStarGreadyFirstSearch.
                                                   if (AB.CheckBrown)
                                                       continue;
                                               }
                                           }
                                           RW4 = i;
                                           CL4 = k;
                                           Ki4 = j;
                                           RW1 = -1;
                                           CL1 = -1;
                                           Ki1 = -1;
                                           RW2 = -1;
                                           CL2 = -1;
                                           Ki2 = -1;
                                           RW3 = -1;
                                           CL3 = -1;
                                           Ki3 = -1;
                                           RW5 = -1;
                                           CL5 = -1;
                                           Ki5 = -1;
                                           RW6 = -1;
                                           CL6 = -1;
                                           Ki6 = -1;
                                           MaxLess4 = (CastlesOnTable[RW4].CastleThinkingQuantum[CL4].NumberOfPenalties);
                                           if (MaxLess4 > MaxLess1)
                                               MaxLess1 = -1;
                                           if (MaxLess4 > MaxLess2)
                                               MaxLess2 = -1;
                                           if (MaxLess4 > MaxLess3)
                                               MaxLess3 = -1;
                                           if (MaxLess4 > MaxLess5)
                                               MaxLess5 = -1;
                                           if (MaxLess4 > MaxLess6)
                                               MaxLess6 = -1;

                                           if (AStarGreedyi == 1)
                                           {
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {
                                                   }
                                                   else//If Order is Brown.
                                                   {
                                                   }
                                               }
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRowQ = CastlesOnTable[i].CastleThinkingQuantum[k].Row;
                                                   AllDraw.LastColumnQ = CastlesOnTable[i].CastleThinkingQuantum[k].Column;
                                                   AllDraw.NextRowQ = CastlesOnTable[i].CastleThinkingQuantum[k].RowColumnCastle[j][0];
                                                   AllDraw.NextColumnQ = CastlesOnTable[i].CastleThinkingQuantum[k].RowColumnCastle[j][1];
                                               }
                                               Act = true;
                                               Less = CastlesOnTable[i].CastleThinkingQuantum[k].NumberOfPenalties;
                                               TableHeuristic = CastlesOnTable[i].CastleThinkingQuantum[k].TableListCastle[j];
                                           }
                                       }
                                       else//Set Table and Heuristic Value and Syntax.
                                       {
                                           if (AStarGreedyi == 1)
                                           {
                                               //Found of Max Non Probable Movments.
                                               Founded.Clear();
                                               int LessB = Int32.MinValue;
                                               BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                               RW4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                               CL4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                               Ki4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                               if (Founded[0] != MaxCastlesFounded)
                                                   continue;
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRowQ = CastlesOnTable[RW4].CastleThinkingQuantum[CL4].Row;
                                                   AllDraw.LastColumnQ = CastlesOnTable[RW4].CastleThinkingQuantum[CL4].Column;
                                                   AllDraw.NextRowQ = CastlesOnTable[i].CastleThinkingQuantum[k].RowColumnCastle[j][0];
                                                   AllDraw.NextColumnQ = CastlesOnTable[i].CastleThinkingQuantum[k].RowColumnCastle[j][1];
                                               }
                                               Act = true;
                                               Less = CastlesOnTable[RW4].CastleThinkingQuantum[CL4].ReturnHeuristic(RW4, Ki4, Order, false, ref HaveKilled);
                                               TableHeuristic = CastlesOnTable[RW4].CastleThinkingQuantum[CL4].TableListCastle[Ki4];
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {
                                                   }
                                                   else//If Order is Brown.
                                                   {
                                                   }
                                               }
                                           }
                                       }
                                   }
                               }
                           }

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;
                   }
                   //minister
                   for (i = 0; i < MinisterMidle; i++)
                   {
                       for (int k = 0; k < AllDraw.MinisterMovments; k++)
                           for (j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum[k] != null && MinisterOnTable[i].MinisterThinkingQuantum[k] != null && j < MinisterOnTable[i].MinisterThinkingQuantum[k].TableListMinister.Count; j++)
                           {
                               {
                                   //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                   int CDummy = ChessRules.CurrentOrder;
                                   int COrder = Order;
                                   ChessRules.CurrentOrder *= -1;
                                   Order *= -1;
                                   Do = 0;
                                   if (UsePenaltyRegardMechnisamT)
                                   {
                                       for (int ij = 0; ij < MinisterOnTable[i].MinisterThinkingQuantum[k].AStarGreedy.Count - 1; ij++)
                                       {
                                           int D = Do;
                                           var ah = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinkingQuantum[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref D, SolderesOnTable[i].SoldierThinkingQuantum[k].AStarGreedy[ij]));
                                           ah.Wait();
                                           ah.Dispose();
                                           Do = D;
                                       }
                                       Order = COrder;
                                       ChessRules.CurrentOrder = CDummy;
                                       ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                           continue;
                                   }

                                   Order = COrder;
                                   ChessRules.CurrentOrder = CDummy;
                                   if ((MinisterOnTable[i].MinisterThinkingQuantum[k].PenaltyRegardListMinister[j].IsPenaltyAction() != 0 && MinisterOnTable[i].MinisterThinkingQuantum[k].PenaltyRegardListMinister[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || MinisterOnTable[i].WinOcuuredatChiled >= 1 || MinisterOnTable[i].WinOcuuredatChiled >= 2 || MinisterOnTable[i].WinOcuuredatChiled >= 3)
                                   {
                                       Object On = new Object();
                                       lock (On)
                                       {
                                           AllDraw.LastRowQ = MinisterOnTable[i].MinisterThinkingQuantum[k].Row;
                                           AllDraw.LastColumnQ = MinisterOnTable[i].MinisterThinkingQuantum[k].Column;
                                           AllDraw.NextRowQ = MinisterOnTable[i].MinisterThinkingQuantum[k].RowColumnMinister[j][0];
                                           AllDraw.NextColumnQ = MinisterOnTable[i].MinisterThinkingQuantum[k].RowColumnMinister[j][1];
                                           Act = true;
                                           Less = MinisterOnTable[i].MinisterThinkingQuantum[k].NumberOfPenalties;
                                       }
                                       TableHeuristic = MinisterOnTable[i].MinisterThinkingQuantum[k].TableListMinister[j];
                                       RegardOccurred = true;
                                       continue;
                                   }
                                   Object ol = new Object();
                                   lock (ol)
                                   {
                                       if (Order != AllDraw.OrderPlateDraw)
                                           if (MinisterOnTable[i].MinisterThinkingQuantum[0].NumberOfPenalties < Less)
                                               continue;
                                       if (MinisterOnTable[i].MinisterThinkingQuantum[0].NumberOfPenalties < Less)
                                       {
                                           //retrive table of current Heuristic.
                                           //retrive table of current Heuristic.
                                           int[,] TableS = MinisterOnTable[i].MinisterThinkingQuantum[k].TableListMinister[j];
                                           int[,] TableSS = MinisterOnTable[i].MinisterThinkingQuantum[k].TableListMinister[j];
                                           //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                           if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                           {
                                               if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                   continue;
                                           }
                                           //When there is not Penalty regard mechanism.
                                           AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 5, CloneATable(TableS), Order, MinisterOnTable[i].MinisterThinkingQuantum[k].Row, MinisterOnTable[i].MinisterThinkingQuantum[k].Column);
                                           //If there is kish or kshachamaz Order.
                                           if (AB.Check(CloneATable(TableS), Order))
                                           {
                                               //When Order is Gray.
                                               if (Order == 1)
                                               {
                                                   //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                   if (AB.CheckGray)
                                                       continue;
                                               }
                                               else
                                               {
                                                   //Continue when CheckBrown and AStarGreadyFirstSearch.
                                                   if (AB.CheckBrown)
                                                       continue;
                                               }
                                           }

                                           RW5 = i;
                                           CL5 = k;
                                           Ki5 = j;
                                           RW1 = -1;
                                           CL1 = -1;
                                           Ki1 = -1;
                                           RW2 = -1;
                                           CL2 = -1;
                                           Ki2 = -1;
                                           RW3 = -1;
                                           CL3 = -1;
                                           Ki3 = -1;
                                           RW4 = -1;
                                           CL4 = -1;
                                           Ki4 = -1;
                                           RW6 = -1;
                                           CL6 = -1;
                                           Ki6 = -1;
                                           MaxLess5 = (MinisterOnTable[RW5].MinisterThinkingQuantum[CL5].NumberOfPenalties);
                                           if (MaxLess5 > MaxLess1)
                                               MaxLess1 = -1;
                                           if (MaxLess5 > MaxLess2)
                                               MaxLess2 = -1;
                                           if (MaxLess5 > MaxLess3)
                                               MaxLess3 = -1;
                                           if (MaxLess5 > MaxLess4)
                                               MaxLess4 = -1;
                                           if (MaxLess5 > MaxLess6)
                                               MaxLess6 = -1;

                                           if (AStarGreedyi == 1)
                                           {
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {
                                                   }
                                                   else//If Order is Brown.
                                                   {
                                                   }   //Set Table and Heuristic Value and Syntax.
                                               }
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRowQ = MinisterOnTable[i].MinisterThinkingQuantum[k].Row;
                                                   AllDraw.LastColumnQ = MinisterOnTable[i].MinisterThinkingQuantum[k].Column;
                                                   AllDraw.NextRowQ = MinisterOnTable[i].MinisterThinkingQuantum[k].RowColumnMinister[j][0];
                                                   AllDraw.NextColumnQ = MinisterOnTable[i].MinisterThinkingQuantum[k].RowColumnMinister[j][1];
                                               }
                                               Act = true;
                                               Less = MinisterOnTable[i].MinisterThinkingQuantum[k].NumberOfPenalties;
                                               TableHeuristic = MinisterOnTable[i].MinisterThinkingQuantum[k].TableListMinister[j];
                                           }
                                       }
                                       else//Set Table and Heuristic Value and Syntax.
                                       {
                                           if (AStarGreedyi == 1)
                                           {
                                               //Found of Max Non Probable Movments.
                                               Founded.Clear();
                                               int LessB = Int32.MinValue;
                                               BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                               RW5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                               CL5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                               Ki5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                               if (Founded[0] != MaxMinisterFounded)
                                                   continue;
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRowQ = MinisterOnTable[RW5].MinisterThinkingQuantum[CL5].Row;
                                                   AllDraw.LastColumnQ = MinisterOnTable[RW5].MinisterThinkingQuantum[CL5].Column;
                                                   AllDraw.NextRowQ = MinisterOnTable[i].MinisterThinkingQuantum[k].RowColumnMinister[j][0];
                                                   AllDraw.NextColumnQ = MinisterOnTable[i].MinisterThinkingQuantum[k].RowColumnMinister[j][1];
                                               }
                                               Act = true;
                                               Less = MinisterOnTable[RW5].MinisterThinkingQuantum[CL5].ReturnHeuristic(RW5, Ki5, Order, false, ref HaveKilled);
                                               TableHeuristic = MinisterOnTable[RW5].MinisterThinkingQuantum[CL5].TableListMinister[Ki5];
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {
                                                   }
                                                   else//If Order is Brown.
                                                   {
                                                   }
                                               }
                                           }
                                       }
                                   }
                               }
                           }

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;
                   }
                   //king
                   for (i = 0; i < KingMidle; i++)
                   {
                       for (int k = 0; k < AllDraw.KingMovments; k++)
                           for (j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum[k] != null && KingOnTable[i].KingThinkingQuantum[k] != null && j < KingOnTable[i].KingThinkingQuantum[k].TableListKing.Count; j++)
                           {
                               {
                                   //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                   int CDummy = ChessRules.CurrentOrder;
                                   int COrder = Order;
                                   ChessRules.CurrentOrder *= -1;
                                   Order *= -1;
                                   Do = 0;
                                   if (UsePenaltyRegardMechnisamT)
                                   {
                                       for (int ij = 0; ij < KingOnTable[i].KingThinkingQuantum[k].AStarGreedy.Count - 1; ij++)
                                       {
                                           int D = Do;
                                           var ah = Task.Factory.StartNew(() => KingOnTable[i].KingThinkingQuantum[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref D, SolderesOnTable[i].SoldierThinkingQuantum[k].AStarGreedy[ij]));
                                           ah.Wait();
                                           ah.Dispose();
                                           Do = D;
                                       }
                                       Order = COrder;
                                       ChessRules.CurrentOrder = CDummy;
                                       ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                           continue;
                                   }

                                   Order = COrder;
                                   ChessRules.CurrentOrder = CDummy;
                                   //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                                   //)
                                   if ((KingOnTable[i].KingThinkingQuantum[k].PenaltyRegardListKing[j].IsPenaltyAction() != 0 && KingOnTable[i].KingThinkingQuantum[k].PenaltyRegardListKing[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || KingOnTable[i].WinOcuuredatChiled >= 1 || KingOnTable[i].WinOcuuredatChiled >= 2 || KingOnTable[i].WinOcuuredatChiled >= 3)
                                   {
                                       Object On = new Object();
                                       lock (On)
                                       {
                                           AllDraw.LastRowQ = KingOnTable[i].KingThinkingQuantum[k].Row;
                                           AllDraw.LastColumnQ = KingOnTable[i].KingThinkingQuantum[k].Column;
                                           AllDraw.NextRowQ = KingOnTable[i].KingThinkingQuantum[k].RowColumnKing[j][0];
                                           AllDraw.NextColumnQ = KingOnTable[i].KingThinkingQuantum[k].RowColumnKing[j][1];
                                           Act = true;
                                           Less = KingOnTable[i].KingThinkingQuantum[k].NumberOfPenalties;
                                       }
                                       TableHeuristic = KingOnTable[i].KingThinkingQuantum[k].TableListKing[j];
                                       RegardOccurred = true;
                                       continue;
                                   }
                                   Object ol = new Object();
                                   lock (ol)
                                   {
                                       //When There is No Movments in Such Order Enemy continue.
                                       if (Order != AllDraw.OrderPlateDraw)
                                           if (KingOnTable[i].KingThinkingQuantum[0].NumberOfPenalties < Less)
                                               continue;
                                       //When There is greater Heuristic Movments.
                                       if (KingOnTable[i].KingThinkingQuantum[0].NumberOfPenalties < Less)
                                       {
                                           //retrive table of current Heuristic.
                                           int[,] TableS = KingOnTable[i].KingThinkingQuantum[k].TableListKing[j];
                                           int[,] TableSS = KingOnTable[i].KingThinkingQuantum[k].TableListKing[j];
                                           //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                           if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                           {
                                               if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                   continue;
                                           }
                                           //When there is not Penalty regard mechanism.
                                           AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 6, CloneATable(TableS), Order, KingOnTable[i].KingThinkingQuantum[k].Row, KingOnTable[i].KingThinkingQuantum[k].Column);
                                           //If there is kish or kshachamaz Order.
                                           if (AB.Check(CloneATable(TableS), Order))
                                           {
                                               //When Order is Gray.
                                               if (Order == 1)
                                               {
                                                   //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                   if (AB.CheckGray)
                                                       continue;
                                               }
                                               else
                                               {
                                                   //Continue when CheckBrown and AStarGreadyFirstSearch.
                                                   if (AB.CheckBrown)
                                                       continue;
                                               }
                                           }

                                           RW6 = i;
                                           CL6 = k;
                                           Ki6 = j;
                                           RW1 = -1;
                                           CL1 = -1;
                                           Ki1 = -1;
                                           RW2 = -1;
                                           CL2 = -1;
                                           Ki2 = -1;
                                           RW3 = -1;
                                           CL3 = -1;
                                           Ki3 = -1;
                                           RW4 = -1;
                                           CL4 = -1;
                                           Ki4 = -1;
                                           RW5 = -1;
                                           CL5 = -1;
                                           Ki5 = -1;
                                           MaxLess6 = (KingOnTable[RW6].KingThinkingQuantum[CL6].NumberOfPenalties);
                                           if (MaxLess6 > MaxLess1)
                                               MaxLess1 = -1;
                                           if (MaxLess6 > MaxLess2)
                                               MaxLess2 = -1;
                                           if (MaxLess6 > MaxLess3)
                                               MaxLess3 = -1;
                                           if (MaxLess6 > MaxLess4)
                                               MaxLess4 = -1;
                                           if (MaxLess6 > MaxLess5)
                                               MaxLess5 = -1;

                                           if (AStarGreedyi == 1)
                                           {
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {
                                                   }
                                                   else//If Order is Brown.
                                                   {
                                                   }
                                               }
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRowQ = KingOnTable[i].KingThinkingQuantum[k].Row;
                                                   AllDraw.LastColumnQ = KingOnTable[i].KingThinkingQuantum[k].Column;
                                                   AllDraw.NextRowQ = KingOnTable[i].KingThinkingQuantum[k].RowColumnKing[j][0];
                                                   AllDraw.NextColumnQ = KingOnTable[i].KingThinkingQuantum[k].RowColumnKing[j][1];
                                               }
                                               Act = true;
                                               Less = KingOnTable[i].KingThinkingQuantum[k].NumberOfPenalties;
                                               TableHeuristic = KingOnTable[i].KingThinkingQuantum[k].TableListKing[j];
                                           }
                                       }
                                       else//Set Table and Heuristic Value and Syntax.
                                       {
                                           if (AStarGreedyi == 1)
                                           {
                                               //Found of Max Non Probable Movments.
                                               Founded.Clear();
                                               int LessB = Int32.MinValue;
                                               BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                               RW6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                               CL6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                               Ki6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                               if (Founded[0] != MaxKingFounded)
                                                   continue;
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRowQ = KingOnTable[RW6].KingThinkingQuantum[CL6].Row;
                                                   AllDraw.LastColumnQ = KingOnTable[RW6].KingThinkingQuantum[CL6].Column;
                                                   AllDraw.NextRowQ = KingOnTable[i].KingThinkingQuantum[k].RowColumnKing[j][0];
                                                   AllDraw.NextColumnQ = KingOnTable[i].KingThinkingQuantum[k].RowColumnKing[j][1];
                                               }
                                               Act = true;
                                               Less = KingOnTable[RW6].KingThinkingQuantum[CL6].ReturnHeuristic(RW6, Ki6, Order, false, ref HaveKilled);
                                               TableHeuristic = KingOnTable[RW6].KingThinkingQuantum[CL6].TableListKing[Ki6];
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {
                                                   }
                                                   else//If Order is Brown.
                                                   {
                                                   }
                                               }
                                           }
                                       }
                                   }
                               }
                           }

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;
                   }

                   return TableHeuristic;
               }
           }
          */ //method for monitor of main Heuristic found best movment (action string)

        /*   private void StringHeuristics(int Obj, int Sec, bool AA, int Do, int WinOcuuredatChiled, int[] LoseOcuuredatChiled)
           {
               string SOut = "";
               if (Obj == 1)
               {
                   SOut = "Soldier ";
               }
               else
                   if (Obj == 2)
               {
                   SOut = "Elephant ";
               }
               else
                   if (Obj == 3)
               {
                   SOut = "Hourse ";
               }
               else
                   if (Obj == 4)
               {
                   SOut = "Castle ";
               }
               else
                   if (Obj == 5)
               {
                   SOut = "Minister ";
               }
               else
                       if (Obj == 6)
               {
                   SOut = "King ";
               }
               SOut += "AStar Heuristics ";
               if (Sec == 1)
               {
                   SOut += " -Initiatetion- ";
               }

               if (Sec == 2)
               {
                   SOut += " -Regard- ";
               }

               if (Sec == 3)
               {
                   SOut += " -Foundation Greatest- ";
               }

               if (WinOcuuredatChiled >= 1)
               {
                   SOut += " At -WinKing Checked Mate- is active For Eneter Regard- ";
               }

               if (LoseOcuuredatChiled[0] <= -1)
               {
                   SOut += " At -LoseKing Checked Mate- is active For Eneter Penelty- ";
               }

               if (AA)
               {
                   SOut += " '-AA-' is Active due to Regard Enter- ";
               }

               if (Do == 1)
               {
                   SOut += " '-Do-' is Active due to Regard Enter- ";
               }

               SOut += " With Heuristic Count " + AllDraw.Less;
               object O = new object();
               lock (O)
               {
               }
           }

      */

        private bool IsSupHuTrue(int i, int j, int Kind)
        {
            //HarasAlphaBeta(i, k, Kind);

            bool Is = false;
            if (!AllowedSupTrue)
            {
                if (Kind == 1)
                {
                    Is = SolderesOnTable[i].SoldierThinkingQuantum[0].IsSupHu[j];
                }
                else
       if (Kind == 2)
                {
                    Is = ElephantOnTable[i].ElefantThinkingQuantum[0].IsSupHu[j];
                }
                else
       if (Kind == 3)
                {
                    Is = HoursesOnTable[i].HourseThinkingQuantum[0].IsSupHu[j];
                }
                else
       if (Kind == 4)
                {
                    Is = CastlesOnTable[i].CastleThinkingQuantum[0].IsSupHu[j];
                }
                else
       if (Kind == 5)
                {
                    Is = MinisterOnTable[i].MinisterThinkingQuantum[0].IsSupHu[j];
                }
                else
       if (Kind == 6)
                {
                    Is = KingOnTable[i].KingThinkingQuantum[0].IsSupHu[j];
                }
                else
                if (Math.Abs(Kind) == 7)
                {
                    Is = CastlingOnTable[i].CastlingThinking[0].IsSupHu[j];
                }
            }
            else
            {
                if (Kind == 1)
                {
                    Is = SolderesOnTable[i].SoldierThinkingQuantum[0].IsSup[j];
                }
                else
   if (Kind == 2)
                {
                    Is = ElephantOnTable[i].ElefantThinkingQuantum[0].IsSup[j];
                }
                else
   if (Kind == 3)
                {
                    Is = HoursesOnTable[i].HourseThinkingQuantum[0].IsSup[j];
                }
                else
   if (Kind == 4)
                {
                    Is = CastlesOnTable[i].CastleThinkingQuantum[0].IsSup[j];
                }
                else
   if (Kind == 5)
                {
                    Is = MinisterOnTable[i].MinisterThinkingQuantum[0].IsSup[j];
                }
                else
   if (Kind == 6)
                {
                    Is = KingOnTable[i].KingThinkingQuantum[0].IsSup[j];
                }
                else
                if (Math.Abs(Kind) == 7)
                {
                    Is = CastlingOnTable[i].CastlingThinking[0].IsSup[j];
                }
            }
            return Is;
        }

        //method for return index base calculated Heuristic specified and clear
        private void SaveLess(int i, int j, int k, int Kind, ref double Less, bool AA, int Order)
        {
            //soldier
            if (Kind == 1)
            {
                Less = SolderesOnTable[i].SoldierThinkingQuantum[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            else//elephant
        if (Kind == 2)
            {
                Less = ElephantOnTable[i].ElefantThinkingQuantum[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            else//hourse
        if (Kind == 3)
            {
                Less = HoursesOnTable[i].HourseThinkingQuantum[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            else//Castle
        if (Kind == 4)
            {
                Less = CastlesOnTable[i].CastleThinkingQuantum[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            else//minister
        if (Kind == 5)
            {
                Less = MinisterOnTable[i].MinisterThinkingQuantum[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            else//king
        if (Kind == 6)
            {
                Less = KingOnTable[i].KingThinkingQuantum[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            else//king
                if (Kind == 7 || Kind == -7)
            {
                Less = CastlingOnTable[i].CastlingThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
        }

        //index of tables that verified existence havbeen saved into refer var
        private void SaveTableHeuristic(int i, int j, int k, int Kind, ref int[,] TableHeuristic)
        {
            //soldier
            if (Kind == 1)
            {
                TableHeuristic = CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder[j]);
            }
            else//elephant
                if (Kind == 2)
            {
                TableHeuristic = CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[k].TableListElefant[j]);
            }
            else//hourse
                if (Kind == 3)
            {
                TableHeuristic = CloneATable(HoursesOnTable[i].HourseThinkingQuantum[k].TableListHourse[j]);
            }
            else//Castle
                if (Kind == 4)
            {
                TableHeuristic = CloneATable(CastlesOnTable[i].CastleThinkingQuantum[k].TableListCastle[j]);
            }
            else//minister
                if (Kind == 5)
            {
                TableHeuristic = CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[k].TableListMinister[j]);
            }
            else//king
                if (Kind == 6)
            {
                TableHeuristic = CloneATable(KingOnTable[i].KingThinkingQuantum[k].TableListKing[j]);
            }
            else//king
                if (Kind == 7 || Kind == -7)
            {
                TableHeuristic = CloneATable(CastlingOnTable[i].CastlingThinking[k].TableListCastling[j]);
            }
        }

        //same of befor verified existence of begin Move and end Move location saved in unique results of Last best movments
        private void SaveBeginEndLocation(int i, int j, int k, int Kind)
        {
            //soldier
            if (Kind == 1)
            {
                AllDraw.LastRowQ = SolderesOnTable[i].SoldierThinkingQuantum[k].Row;
                AllDraw.LastColumnQ = SolderesOnTable[i].SoldierThinkingQuantum[k].Column;
                AllDraw.NextRowQ = SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0];
                AllDraw.NextColumnQ = SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1];
            }
            else//elephant
                 if (Kind == 2)
            {
                AllDraw.LastRowQ = ElephantOnTable[i].ElefantThinkingQuantum[k].Row;
                AllDraw.LastColumnQ = ElephantOnTable[i].ElefantThinkingQuantum[k].Column;
                AllDraw.NextRowQ = ElephantOnTable[i].ElefantThinkingQuantum[k].RowColumnElefant[j][0];
                AllDraw.NextColumnQ = ElephantOnTable[i].ElefantThinkingQuantum[k].RowColumnElefant[j][1];
            }
            else//hourse
                 if (Kind == 3)
            {
                AllDraw.LastRowQ = HoursesOnTable[i].HourseThinkingQuantum[k].Row;
                AllDraw.LastColumnQ = HoursesOnTable[i].HourseThinkingQuantum[k].Column;
                AllDraw.NextRowQ = HoursesOnTable[i].HourseThinkingQuantum[k].RowColumnHourse[j][0];
                AllDraw.NextColumnQ = HoursesOnTable[i].HourseThinkingQuantum[k].RowColumnHourse[j][1];
            }
            else//Castle
                 if (Kind == 4)
            {
                AllDraw.LastRowQ = CastlesOnTable[i].CastleThinkingQuantum[k].Row;
                AllDraw.LastColumnQ = CastlesOnTable[i].CastleThinkingQuantum[k].Column;
                AllDraw.NextRowQ = CastlesOnTable[i].CastleThinkingQuantum[k].RowColumnCastle[j][0];
                AllDraw.NextColumnQ = CastlesOnTable[i].CastleThinkingQuantum[k].RowColumnCastle[j][1];
            }
            else//minister
                 if (Kind == 5)
            {
                AllDraw.LastRowQ = MinisterOnTable[i].MinisterThinkingQuantum[k].Row;
                AllDraw.LastColumnQ = MinisterOnTable[i].MinisterThinkingQuantum[k].Column;
                AllDraw.NextRowQ = MinisterOnTable[i].MinisterThinkingQuantum[k].RowColumnMinister[j][0];
                AllDraw.NextColumnQ = MinisterOnTable[i].MinisterThinkingQuantum[k].RowColumnMinister[j][1];
            }
            else//king
                 if (Kind == 6)
            {
                AllDraw.LastRowQ = KingOnTable[i].KingThinkingQuantum[k].Row;
                AllDraw.LastColumnQ = KingOnTable[i].KingThinkingQuantum[k].Column;
                AllDraw.NextRowQ = KingOnTable[i].KingThinkingQuantum[k].RowColumnKing[j][0];
                AllDraw.NextColumnQ = KingOnTable[i].KingThinkingQuantum[k].RowColumnKing[j][1];
            }
            else//king
                 if (Kind == 7 || Kind == -7)
            {
                AllDraw.LastRowQ = CastlingOnTable[i].CastlingThinking[k].Row;
                AllDraw.LastColumnQ = CastlingOnTable[i].CastlingThinking[k].Column;
                AllDraw.NextRowQ = CastlingOnTable[i].CastlingThinking[k].RowColumnCastling[j][0];
                AllDraw.NextColumnQ = CastlingOnTable[i].CastlingThinking[k].RowColumnCastling[j][1];
            }
        }

        //regard section of main Heuristic in learning autamata section
        private bool HeuristicRegardSection(int i, int j, int k, ref bool Act, ref int[,] TableHeuristic, ref bool AA, Color a, int Kind, ref int Do, int AStarGreedyi, int Order)
        {
            bool continued = false;
            if (IsSupHuTrue(i, j, Kind))
            {
                return true;
            }

            bool A = WinReturnValue(Kind, i, j);
            bool B = WinPerfromeRegardMethod(Kind, i, j);
            continued = A;
            if (!(A && B))
            {
                return continued;
            }
            //soldier
            if (Kind == 1)
            {
                if ((SolderesOnTable[i].SoldierThinkingQuantum[k].PenaltyRegardListSolder[j].IsPenaltyAction() != 0 && SolderesOnTable[i].SoldierThinkingQuantum[k].PenaltyRegardListSolder[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((((Do == 1 || AA) && UsePenaltyRegardMechnisamT)) && UsePenaltyRegardMechnisamT) || SolderesOnTable[i].WinOcuuredatChiled >= 1 || SolderesOnTable[i].WinOcuuredatChiled >= 2 || SolderesOnTable[i].WinOcuuredatChiled >= 3)
                {
                    //Set Table and Heuristic Value and Syntax.
                    Act = true;
                    object On = new object();
                    lock (On)
                    {
                        //if (!RegardLessOptimized(i, j, k, Kind, ref Less, AA, Order))

                        Task ah = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                        ah.Wait();
                        ah.Dispose();

                        int[,] Th = TableHeuristic;
                        Task ah1 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                        ah1.Wait();
                        ah1.Dispose();
                        TableHeuristic = Th;

                        double le = Less;
                        bool AAA = AA;
                        Task ah2 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                        ah2.Wait();
                        ah2.Dispose();
                        Less = le;
                        AA = AAA;
                    }
                    object O = new object();
                    lock (O)
                    {
                        ThingsConverter.ActOfClickEqualTow = true;
                    }
                    SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder[j], Order);
                    int Sign = 1;
                    if (a == Color.Brown)
                    {
                        Sign = -1;
                    }
                    //If there is Soldier Convert.
                    if (SolderesOnTable[i].Convert)
                    {
                        if (SolderesOnTable[i].ConvertedToMinister)
                        {
                            TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 5 * Sign;
                        }
                        else if (SolderesOnTable[i].ConvertedToCastle)
                        {
                            TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 4 * Sign;
                        }
                        else if (SolderesOnTable[i].ConvertedToHourse)
                        {
                            TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 3 * Sign;
                        }
                        else if (SolderesOnTable[i].ConvertedToElefant)
                        {
                            TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 2 * Sign;
                        }
                    }
                    RegardOccurred = true;
                    // StringHeuristics(1, 2, AA, Do, SolderesOnTable[i].WinOcuuredatChiled, SolderesOnTable[i].LoseOcuuredatChiled);
                    continued = true;
                }
            }
            else//elephant
            if (Kind == 2)
            {
                if ((ElephantOnTable[i].ElefantThinkingQuantum[k].PenaltyRegardListElefant[j].IsPenaltyAction() != 0 && ElephantOnTable[i].ElefantThinkingQuantum[k].PenaltyRegardListElefant[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || ElephantOnTable[i].WinOcuuredatChiled >= 1 || ElephantOnTable[i].WinOcuuredatChiled >= 2 || ElephantOnTable[i].WinOcuuredatChiled >= 3)
                {
                    object On = new object();
                    lock (On)
                    {
                        //if (!RegardLessOptimized(i, j, k, Kind, ref Less, AA, Order))

                        Task ah = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                        ah.Wait();
                        ah.Dispose();

                        int[,] Th = TableHeuristic;
                        Task ah1 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                        ah1.Wait();
                        ah1.Dispose();
                        TableHeuristic = Th;

                        double le = Less;
                        bool AAA = AA;
                        Task ah2 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                        ah2.Wait();
                        ah2.Dispose();
                        Less = le;
                        AA = AAA;
                    }
                    // StringHeuristics(2, 2, AA, Do, ElephantOnTable[i].WinOcuuredatChiled, ElephantOnTable[i].LoseOcuuredatChiled);
                    RegardOccurred = true;
                    continued = true;
                }
            }
            else//hourse
            if (Kind == 3)
            {
                if ((HoursesOnTable[i].HourseThinkingQuantum[k].PenaltyRegardListHourse[j].IsPenaltyAction() != 0 && HoursesOnTable[i].HourseThinkingQuantum[k].PenaltyRegardListHourse[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || HoursesOnTable[i].WinOcuuredatChiled >= 1 || HoursesOnTable[i].WinOcuuredatChiled >= 2 || HoursesOnTable[i].WinOcuuredatChiled >= 3)
                {
                    object On = new object();
                    lock (On)
                    {
                        //if (!RegardLessOptimized(i, j, k, Kind, ref Less, AA, Order))

                        Task ah = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                        ah.Wait();
                        ah.Dispose();

                        int[,] Th = TableHeuristic;
                        Task ah1 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                        ah1.Wait();
                        ah1.Dispose();
                        TableHeuristic = Th;

                        double le = Less;
                        bool AAA = AA;
                        Task ah2 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                        ah2.Wait();
                        ah2.Dispose();
                        Less = le;
                        AA = AAA;
                    }
                    RegardOccurred = true;
                    // StringHeuristics(3, 2, AA, Do, HoursesOnTable[i].WinOcuuredatChiled, HoursesOnTable[i].LoseOcuuredatChiled);
                    continued = true;
                }
            }
            else//Castle
            if (Kind == 4)
            {
                if ((CastlesOnTable[i].CastleThinkingQuantum[k].PenaltyRegardListCastle[j].IsPenaltyAction() != 0 && CastlesOnTable[i].CastleThinkingQuantum[k].PenaltyRegardListCastle[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || CastlesOnTable[i].WinOcuuredatChiled >= 1 || CastlesOnTable[i].WinOcuuredatChiled >= 2 || CastlesOnTable[i].WinOcuuredatChiled >= 3)
                {
                    object On = new object();
                    lock (On)
                    {
                        //if (!RegardLessOptimized(i, j, k, Kind, ref Less, AA, Order))

                        Task ah = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                        ah.Wait();
                        ah.Dispose();

                        int[,] Th = TableHeuristic;
                        Task ah1 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                        ah1.Wait();
                        ah1.Dispose();
                        TableHeuristic = Th;

                        double le = Less;
                        bool AAA = AA;
                        Task ah2 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                        ah2.Wait();
                        ah2.Dispose();
                        Less = le;
                        AA = AAA;
                    }
                    RegardOccurred = true;
                    // StringHeuristics(4, 2, AA, Do, CastlesOnTable[i].WinOcuuredatChiled, CastlesOnTable[i].LoseOcuuredatChiled);
                    continued = true;
                }
            }
            else//minister
                if (Kind == 5)
            {
                if ((MinisterOnTable[i].MinisterThinkingQuantum[k].PenaltyRegardListMinister[j].IsPenaltyAction() != 0 && MinisterOnTable[i].MinisterThinkingQuantum[k].PenaltyRegardListMinister[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || MinisterOnTable[i].WinOcuuredatChiled >= 1 || MinisterOnTable[i].WinOcuuredatChiled >= 2 || MinisterOnTable[i].WinOcuuredatChiled >= 3)
                {
                    object On = new object();
                    lock (On)
                    {
                        //if (!RegardLessOptimized(i, j, k, Kind, ref Less, AA, Order))

                        Task ah = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                        ah.Wait();
                        ah.Dispose();

                        int[,] Th = TableHeuristic;
                        Task ah1 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                        ah1.Wait();
                        ah1.Dispose();
                        TableHeuristic = Th;

                        double le = Less;
                        bool AAA = AA;
                        Task ah2 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                        ah2.Wait();
                        ah2.Dispose();
                        Less = le;
                        AA = AAA;
                    }
                    TableHeuristic = MinisterOnTable[i].MinisterThinkingQuantum[k].TableListMinister[j];
                    RegardOccurred = true;
                    // StringHeuristics(5, 2, AA, Do, MinisterOnTable[i].WinOcuuredatChiled, MinisterOnTable[i].LoseOcuuredatChiled);
                    continued = true;
                }
            }
            else//king
            if (Kind == 6)
            {
                if ((KingOnTable[i].KingThinkingQuantum[k].PenaltyRegardListKing[j].IsPenaltyAction() != 0 && KingOnTable[i].KingThinkingQuantum[k].PenaltyRegardListKing[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || KingOnTable[i].WinOcuuredatChiled >= 1 || KingOnTable[i].WinOcuuredatChiled >= 2 || KingOnTable[i].WinOcuuredatChiled >= 3)
                {
                    object On = new object();
                    lock (On)
                    {
                        //if (!RegardLessOptimized(i, j, k, Kind, ref Less, AA, Order))

                        Task ah = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                        ah.Wait();
                        ah.Dispose();

                        int[,] Th = TableHeuristic;
                        Task ah1 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                        ah1.Wait();
                        ah1.Dispose();
                        TableHeuristic = Th;

                        double le = Less;
                        bool AAA = AA;
                        Task ah2 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                        ah2.Wait();
                        ah2.Dispose();
                        Less = le;
                        AA = AAA;
                    }
                    RegardOccurred = true;
                    // StringHeuristics(6, 2, AA, Do, KingOnTable[i].WinOcuuredatChiled, KingOnTable[i].LoseOcuuredatChiled);
                    //if (KingOnTable[i].WinOcuuredatChiled >= 1 || KingOnTable[i].WinOcuuredatChiled >= 2 || KingOnTable[i].WinOcuuredatChiled >= 3)

                    //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                    continued = true;
                }
            }
            else//king
            if (Kind == 7 || Kind == -7)
            {
                if ((CastlingOnTable[i].CastlingThinking[k].PenaltyRegardListCastling[j].IsPenaltyAction() != 0 && CastlingOnTable[i].CastlingThinking[k].PenaltyRegardListCastling[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || CastlingOnTable[i].WinOcuuredatChiled >= 1 || CastlingOnTable[i].WinOcuuredatChiled >= 2 || CastlingOnTable[i].WinOcuuredatChiled >= 3)
                {
                    object On = new object();
                    lock (On)
                    {
                        //if (!RegardLessOptimized(i, j, k, Kind, ref Less, AA, Order))

                        Task ah = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                        ah.Wait();
                        ah.Dispose();

                        int[,] Th = TableHeuristic;
                        Task ah1 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                        ah1.Wait();
                        ah1.Dispose();
                        TableHeuristic = Th;

                        double le = Less;
                        bool AAA = AA;
                        Task ah2 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                        ah2.Wait();
                        ah2.Dispose();
                        Less = le;
                        AA = AAA;
                    }
                    RegardOccurred = true;
                    // StringHeuristics(7, 2, AA, Do, CastlingOnTable[i].WinOcuuredatChiled, CastlingOnTable[i].LoseOcuuredatChiled);
                    //if (KingOnTable[i].WinOcuuredatChiled >= 1 || KingOnTable[i].WinOcuuredatChiled >= 2 || KingOnTable[i].WinOcuuredatChiled >= 3)

                    //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                    continued = true;
                }
            }
            if (continued)
            {
                OnlyWin = true;
            }

            return continued;
        }

        //initiate deterministic vars of orderic Heuristic value
        private void InitiateVars(int i, int j, int k, int Kind)
        {
            RW1 = -1;
            CL1 = -1;
            Ki1 = -1;
            RW2 = -1;
            CL2 = -1;
            Ki2 = -1;
            RW3 = -1;
            CL3 = -1;
            Ki3 = -1;
            RW4 = -1;
            CL4 = -1;
            Ki4 = -1;
            RW5 = -1;
            CL5 = -1;
            Ki5 = -1;
            RW6 = -1;
            CL6 = -1;
            Ki6 = -1;
            RW7 = -1;
            CL7 = -1;
            //Sodleirs
            if (Kind == 1)
            {
                RW1 = i;
                CL1 = k;
                Ki1 = j;
            }
            else//elephant
                if (Kind == 2)
            {
                RW2 = i;
                CL2 = k;
                Ki2 = j;
            }
            else//hourse
                if (Kind == 3)
            {
                RW3 = i;
                CL3 = k;
                Ki3 = j;
            }
            else//Castle
                if (Kind == 4)
            {
                RW4 = i;
                CL4 = k;
                Ki4 = j;
            }
            else//minister
                if (Kind == 5)
            {
                RW5 = i;
                CL5 = k;
                Ki5 = j;
            }
            else//king
                if (Kind == 6)
            {
                RW6 = i;
                CL6 = k;
                Ki6 = j;
            }
            else//king
                if (Kind == 7 || Kind == -7)
            {
                RW7 = i;
                CL7 = k;
            }
        }

        //deterministic of checke of movments occured for ignore
        private bool CheckeHuristci(int[,] TableS, int Order,int Ki)
        {
            bool continued = false;
            ChessRules AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Ki, CloneATable(TableS), Order);
            //If there is kish or kshachamaz Order.
            bool ac = false;
            Task<bool> ah = Task.Factory.StartNew(() => ac = AB.Check(CloneATable(TableS), Order));
            ah.Wait();
            ah.Dispose();

            if (ac)
            {
                //When Order is Gray.
                if (Order == 1)
                {
                    //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                    if (AB.CheckGray)
                    {
                        continued = true;
                    }
                }
                else
                {
                    //Continue when CheckBrown and AStarGreadyFirstSearch.
                    if (AB.CheckBrown)
                    {
                        continued = true;
                    }
                }
            }

            return continued;
        }

        //minitoring of Heuristic output
        private void OutputHeuristic(int Order)
        {
            object O1 = new object();
            lock (O1)
            {
                if (Order == 1)
                {
                }
                else//If Order is Brown.
                {
                }
            }
        }

        //main method of Heuristic
        private bool HeuristicMainBody(int i, int j, int k, ref bool Act, ref int[,] TableHeuristic, ref bool CurrentTableHeuristic, ref bool AA, Color a, int Kind, ref int Do, int AStarGreedyi, int Order)
        {
            bool continued = false;
            if (IsSupHuTrue(i, j, Kind))
            {
                return true;
            }

            if (Kind == 1)
            {
                bool ac = false;
                bool AAA = AA;
                double Le = Less;
                int Havk = HaveKilled;
                Task<bool> ah = Task.Factory.StartNew(() => ac = SolderesOnTable[i].SoldierThinkingQuantum[0].ReturnHeuristic(i, j, Order, AAA, ref Havk) > Le);
                ah.Wait();
                ah.Dispose();
                AA = AAA;
                Less = Le;
                HaveKilled = Havk;
                if (ac)
                {
                    object O11 = new object();
                    lock (O11)
                    {
                        int[,] TableS = SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder[j];
                        //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                        if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                        {
                            if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                            {
                                //if (Order == 1)

                                //else

                                return true;
                            }
                        }
                        //When there is not Penalty regard mechanism.
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac =  CheckeHuristci(CloneATable(TableS), Order,Kind));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            return true;
                        }

                        Task ah2 = Task.Factory.StartNew(() => InitiateVars(i, j, k, Kind));
                        ah2.Wait();
                        ah2.Dispose();

                        //Set Max of Soldier.
                        AAA = AA;
                        Havk = HaveKilled;
                        Task<double> ah3 = Task.Factory.StartNew(() => MaxLess1 = SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].ReturnHeuristic(i, j, Order, AAA, ref Havk));
                        ah3.Wait();
                        ah3.Dispose();
                        AA = AAA;
                        HaveKilled = Havk;

                        if (ThinkingQuantumChess.IsAtLeastOneKillerAtDraw)
                        {
                            if ((!KiilledForce(ref HaveKilled)) && (HaveKilled < 0))
                            {
                                return true;
                            }
                        }
                        if (!KillerForce(ref HaveKilled))
                        {
                            return true;
                        }
                        //When Soldeirs is Greater than Others these Set Max.
                        if (MaxLess1 > MaxLess2)
                        {
                            MaxLess2 = -1;
                        }

                        if (MaxLess1 > MaxLess3)
                        {
                            MaxLess3 = -1;
                        }

                        if (MaxLess1 > MaxLess4)
                        {
                            MaxLess4 = -1;
                        }

                        if (MaxLess1 > MaxLess5)
                        {
                            MaxLess5 = -1;
                        }

                        if (MaxLess2 > MaxLess6)
                        {
                            MaxLess6 = -1;
                        }

                        if (MaxLess2 > MaxLess7)
                        {
                            MaxLess7 = -1;
                        }

                        if (AStarGreedyi == 1)
                        {
                            OutputHeuristic(Order);
                            //Set Table and Heuristic Value and Syntax.
                            Act = true;
                            object On = new object();
                            lock (On)
                            {
                                Task ah4 = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                                ah4.Wait();
                                ah4.Dispose();

                                int[,] Th = TableHeuristic;
                                Task ah5 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                                ah5.Wait();
                                ah5.Dispose();
                                TableHeuristic = Th;

                                double le = Less;
                                AAA = AA;
                                Task ah6 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                                ah6.Wait();
                                ah6.Dispose();
                                Less = le;
                                AA = AAA;
                            }
                            // StringHeuristics(1, 3, AA, Do, SolderesOnTable[i].WinOcuuredatChiled, SolderesOnTable[i].LoseOcuuredatChiled);

                            object O1 = new object();
                            lock (O1)
                            {
                                ThingsConverter.ActOfClickEqualTow = true;
                            }
                            SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder[j], Order);
                            int Sign = 1;
                            if (a == Color.Brown)
                            {
                                Sign = -1;
                            }
                            //If there is Soldier Convert.
                            if (SolderesOnTable[i].Convert)
                            {
                                if (SolderesOnTable[i].ConvertedToMinister)
                                {
                                    TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                }
                                else if (SolderesOnTable[i].ConvertedToCastle)
                                {
                                    TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                }
                                else if (SolderesOnTable[i].ConvertedToHourse)
                                {
                                    TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                }
                                else if (SolderesOnTable[i].ConvertedToElefant)
                                {
                                    TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 2 * Sign;
                                }
                            }
                        }
                    }
                }
            }
            else if (Kind == 2)
            {
                bool ac = false;
                bool AAA = AA;
                double Le = Less;
                int Havk = HaveKilled;
                Task<bool> ah = Task.Factory.StartNew(() => ac = ElephantOnTable[i].ElefantThinkingQuantum[0].ReturnHeuristic(i, j, Order, AAA, ref Havk) > Le);
                ah.Wait();
                ah.Dispose();
                AA = AAA;
                Less = Le;
                HaveKilled = Havk;
                if (ac)
                {
                    object O = new object();
                    lock (O)
                    {
                    }
                    //retrive table of current Heuristic.
                    int[,] TableS = ElephantOnTable[i].ElefantThinkingQuantum[k].TableListElefant[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                    {
                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            //if (Order == 1)

                            //else

                            return true;
                        }
                    }
                    //When there is not Penalty regard mechanism.
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac =  CheckeHuristci(CloneATable(TableS), Order,Kind));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                    {
                        return true;
                    }

                    Task ah2 = Task.Factory.StartNew(() => InitiateVars(i, j, k, Kind));
                    ah2.Wait();
                    ah2.Dispose();

                    AAA = AA;
                    Havk = HaveKilled;
                    Task<double> ah3 = Task.Factory.StartNew(() => MaxLess2 = ElephantOnTable[RW2].ElefantThinkingQuantum[CL2].ReturnHeuristic(i, j, Order, AAA, ref Havk));
                    ah3.Wait();
                    ah3.Dispose();
                    AA = AAA;
                    HaveKilled = Havk;

                    if (ThinkingQuantumChess.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(ref HaveKilled)) && (HaveKilled < 0))
                        {
                            return true;
                        }
                    }
                    if (!KillerForce(ref HaveKilled))
                    {
                        return true;
                    }

                    if (MaxLess2 > MaxLess1)
                    {
                        MaxLess1 = -1;
                    }

                    if (MaxLess2 > MaxLess3)
                    {
                        MaxLess3 = -1;
                    }

                    if (MaxLess2 > MaxLess4)
                    {
                        MaxLess4 = -1;
                    }

                    if (MaxLess2 > MaxLess5)
                    {
                        MaxLess5 = -1;
                    }

                    if (MaxLess2 > MaxLess6)
                    {
                        MaxLess6 = -1;
                    }

                    if (MaxLess2 > MaxLess7)
                    {
                        MaxLess7 = -1;
                    }

                    if (AStarGreedyi == 1)
                    {
                        OutputHeuristic(Order);
                        //Set Table and Heuristic Value and Syntax.
                        object On = new object();
                        lock (On)
                        {
                            Task ah4 = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                            ah4.Wait();
                            ah4.Dispose();

                            int[,] Th = TableHeuristic;
                            Task ah5 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                            ah5.Wait();
                            ah5.Dispose();
                            TableHeuristic = Th;

                            double le = Less;
                            AAA = AA;
                            Task ah6 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                            ah6.Wait();
                            ah6.Dispose();
                            Less = le;
                            AA = AAA;
                        }
                        Act = true;
                        // StringHeuristics(2, 3, AA, Do, ElephantOnTable[i].WinOcuuredatChiled, ElephantOnTable[i].LoseOcuuredatChiled);
                    }
                }
            }
            else if (Kind == 3)
            {
                bool ac = false;
                bool AAA = AA;
                double Le = Less;
                int Havk = HaveKilled;
                Task<bool> ah = Task.Factory.StartNew(() => ac = HoursesOnTable[i].HourseThinkingQuantum[0].ReturnHeuristic(i, j, Order, AAA, ref Havk) > Le);
                ah.Wait();
                ah.Dispose();
                AA = AAA;
                Less = Le;
                HaveKilled = Havk;
                if (ac)
                {
                    object O = new object();
                    lock (O)
                    {
                    }
                    //retrive table of current Heuristic.
                    int[,] TableS = HoursesOnTable[i].HourseThinkingQuantum[k].TableListHourse[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                    {
                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            if (Order == 1)
                            {
                            }
                            else
                            {
                                return true;
                            }
                        }
                    }
                    //When there is not Penalty regard mechanism.
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac =  CheckeHuristci(CloneATable(TableS), Order,Kind));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                    {
                        return true;
                    }

                    Task ah2 = Task.Factory.StartNew(() => InitiateVars(i, j, k, Kind));
                    ah2.Wait();
                    ah2.Dispose();

                    AAA = AA;
                    Havk = HaveKilled;
                    Task<double> ah3 = Task.Factory.StartNew(() => MaxLess3 = HoursesOnTable[RW3].HourseThinkingQuantum[CL3].ReturnHeuristic(i, j, Order, AAA, ref Havk));
                    ah3.Wait();
                    ah3.Dispose();
                    AA = AAA;
                    HaveKilled = Havk;

                    if (ThinkingQuantumChess.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(ref HaveKilled)) && (HaveKilled < 0))
                        {
                            return true;
                        }
                    }
                    if (!KillerForce(ref HaveKilled))
                    {
                        return true;
                    }

                    if (MaxLess3 > MaxLess1)
                    {
                        MaxLess1 = -1;
                    }

                    if (MaxLess3 > MaxLess2)
                    {
                        MaxLess2 = -1;
                    }

                    if (MaxLess3 > MaxLess4)
                    {
                        MaxLess4 = -1;
                    }

                    if (MaxLess3 > MaxLess5)
                    {
                        MaxLess5 = -1;
                    }

                    if (MaxLess3 > MaxLess6)
                    {
                        MaxLess6 = -1;
                    }

                    if (MaxLess3 > MaxLess7)
                    {
                        MaxLess7 = -1;
                    }

                    if (AStarGreedyi == 1)
                    {
                        OutputHeuristic(Order);
                        //Set Table and Heuristic Value and Syntax.
                        object On = new object();
                        lock (On)
                        {
                            Task ah4 = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                            ah4.Wait();
                            ah4.Dispose();

                            int[,] Th = TableHeuristic;
                            Task ah5 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                            ah5.Wait();
                            ah5.Dispose();
                            TableHeuristic = Th;

                            double le = Less;
                            AAA = AA;
                            Task ah6 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                            ah6.Wait();
                            ah6.Dispose();
                            Less = le;
                            AA = AAA;
                        }
                        Act = true;
                        // StringHeuristics(3, 3, AA, Do, HoursesOnTable[i].WinOcuuredatChiled, HoursesOnTable[i].LoseOcuuredatChiled);
                    }
                }
            }
            else if (Kind == 4)
            {
                bool ac = false;
                bool AAA = AA;
                double Le = Less;
                int Havk = HaveKilled;
                Task<bool> ah = Task.Factory.StartNew(() => ac = CastlesOnTable[i].CastleThinkingQuantum[0].ReturnHeuristic(i, j, Order, AAA, ref Havk) > Le);
                ah.Wait();
                ah.Dispose();
                AA = AAA;
                Less = Le;
                HaveKilled = Havk;
                if (ac)
                {
                    object O = new object();
                    lock (O)
                    {
                    }
                    //retrive table of current Heuristic.
                    //retrive table of current Heuristic.
                    int[,] TableS = CastlesOnTable[i].CastleThinkingQuantum[k].TableListCastle[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                    {
                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            //if (Order == 1)

                            //else

                            return true;
                        }
                    }
                    //When there is not Penalty regard mechanism.
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac =  CheckeHuristci(CloneATable(TableS), Order,Kind));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                    {
                        return true;
                    }

                    Task ah2 = Task.Factory.StartNew(() => InitiateVars(i, j, k, Kind));
                    ah2.Wait();
                    ah2.Dispose();

                    AAA = AA;
                    Havk = HaveKilled;
                    Task<double> ah3 = Task.Factory.StartNew(() => MaxLess4 = CastlesOnTable[RW4].CastleThinkingQuantum[CL4].ReturnHeuristic(i, j, Order, AAA, ref Havk));
                    ah3.Wait();
                    ah3.Dispose();
                    AA = AAA;
                    HaveKilled = Havk;

                    if (ThinkingQuantumChess.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(ref HaveKilled)) && (HaveKilled < 0))
                        {
                            return true;
                        }
                    }
                    if (!KillerForce(ref HaveKilled))
                    {
                        return true;
                    }

                    if (MaxLess4 > MaxLess1)
                    {
                        MaxLess1 = -1;
                    }

                    if (MaxLess4 > MaxLess2)
                    {
                        MaxLess2 = -1;
                    }

                    if (MaxLess4 > MaxLess3)
                    {
                        MaxLess3 = -1;
                    }

                    if (MaxLess4 > MaxLess5)
                    {
                        MaxLess5 = -1;
                    }

                    if (MaxLess4 > MaxLess6)
                    {
                        MaxLess6 = -1;
                    }

                    if (MaxLess4 > MaxLess7)
                    {
                        MaxLess7 = -1;
                    }

                    if (AStarGreedyi == 1)
                    {
                        OutputHeuristic(Order);
                        //Set Table and Heuristic Value and Syntax.
                        object On = new object();
                        lock (On)
                        {
                            Task ah4 = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                            ah4.Wait();
                            ah4.Dispose();

                            int[,] Th = TableHeuristic;
                            Task ah5 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                            ah5.Wait();
                            ah5.Dispose();
                            TableHeuristic = Th;

                            double le = Less;
                            AAA = AA;
                            Task ah6 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                            ah6.Wait();
                            ah6.Dispose();
                            Less = le;
                            AA = AAA;
                        }
                        Act = true;
                        // StringHeuristics(4, 3, AA, Do, CastlesOnTable[i].WinOcuuredatChiled, CastlesOnTable[i].LoseOcuuredatChiled);
                    }
                }
                else//Set Table and Heuristic Value and Syntax.
                {
                }
            }
            else if (Kind == 5)
            {
                bool ac = false;
                bool AAA = AA;
                double Le = Less;
                int Havk = HaveKilled;
                Task<bool> ah = Task.Factory.StartNew(() => ac = MinisterOnTable[i].MinisterThinkingQuantum[0].ReturnHeuristic(i, j, Order, AAA, ref Havk) > Le);
                ah.Wait();
                ah.Dispose();
                AA = AAA;
                Less = Le;
                HaveKilled = Havk;
                if (ac)
                {
                    object O = new object();
                    lock (O)
                    {
                    }
                    //retrive table of current Heuristic.
                    //retrive table of current Heuristic.
                    int[,] TableS = MinisterOnTable[i].MinisterThinkingQuantum[k].TableListMinister[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                    {
                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            //if (Order == 1)

                            //else

                            return true;
                        }
                    }
                    //When there is not Penalty regard mechanism.
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac =  CheckeHuristci(CloneATable(TableS), Order,Kind));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                    {
                        return true;
                    }

                    Task ah2 = Task.Factory.StartNew(() => InitiateVars(i, j, k, Kind));
                    ah2.Wait();
                    ah2.Dispose();

                    AAA = AA;
                    Havk = HaveKilled;
                    Task<double> ah3 = Task.Factory.StartNew(() => MaxLess5 = MinisterOnTable[RW5].MinisterThinkingQuantum[CL5].ReturnHeuristic(i, j, Order, AAA, ref Havk));
                    ah3.Wait();
                    ah3.Dispose();
                    AA = AAA;
                    HaveKilled = Havk;

                    if (ThinkingQuantumChess.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(ref HaveKilled)) && (HaveKilled < 0))
                        {
                            return true;
                        }
                    }
                    if (!KillerForce(ref HaveKilled))
                    {
                        return true;
                    }

                    if (MaxLess5 > MaxLess1)
                    {
                        MaxLess1 = -1;
                    }

                    if (MaxLess5 > MaxLess2)
                    {
                        MaxLess2 = -1;
                    }

                    if (MaxLess5 > MaxLess3)
                    {
                        MaxLess3 = -1;
                    }

                    if (MaxLess5 > MaxLess4)
                    {
                        MaxLess4 = -1;
                    }

                    if (MaxLess5 > MaxLess6)
                    {
                        MaxLess6 = -1;
                    }

                    if (MaxLess5 > MaxLess7)
                    {
                        MaxLess7 = -1;
                    }

                    if (AStarGreedyi == 1)
                    {
                        OutputHeuristic(Order);
                        //Set Table and Heuristic Value and Syntax.
                        object On = new object();
                        lock (On)
                        {
                            Task ah4 = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                            ah4.Wait();
                            ah4.Dispose();

                            int[,] Th = TableHeuristic;
                            Task ah5 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                            ah5.Wait();
                            ah5.Dispose();
                            TableHeuristic = Th;

                            double le = Less;
                            AAA = AA;
                            Task ah6 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                            ah6.Wait();
                            ah6.Dispose();
                            Less = le;
                            AA = AAA;
                        }
                        Act = true;
                        // StringHeuristics(5, 3, AA, Do, MinisterOnTable[i].WinOcuuredatChiled, MinisterOnTable[i].LoseOcuuredatChiled);
                    }
                }
            }
            else if (Kind == 6)
            {
                bool ac = false;
                bool AAA = AA;
                double Le = Less;
                int Havk = HaveKilled;
                Task<bool> ah = Task.Factory.StartNew(() => ac = KingOnTable[i].KingThinkingQuantum[0].ReturnHeuristic(i, j, Order, AAA, ref Havk) > Le);
                ah.Wait();
                ah.Dispose();
                AA = AAA;
                Less = Le;
                HaveKilled = Havk;
                if (ac)
                {
                    object OO = new object();
                    lock (OO)
                    {
                    }
                    //retrive table of current Heuristic.
                    //retrive table of current Heuristic.
                    int[,] TableS = KingOnTable[i].KingThinkingQuantum[k].TableListKing[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                    {
                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            //if (Order == 1)

                            //else

                            return true;
                        }
                    }
                    //When there is not Penalty regard mechanism.
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac =  CheckeHuristci(CloneATable(TableS), Order,Kind));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                    {
                        return true;
                    }

                    Task ah2 = Task.Factory.StartNew(() => InitiateVars(i, j, k, Kind));
                    ah2.Wait();
                    ah2.Dispose();

                    AAA = AA;
                    Havk = HaveKilled;
                    Task<double> ah3 = Task.Factory.StartNew(() => MaxLess6 = KingOnTable[RW6].KingThinkingQuantum[CL6].ReturnHeuristic(i, j, Order, AAA, ref Havk));
                    ah3.Wait();
                    ah3.Dispose();
                    AA = AAA;
                    HaveKilled = Havk;

                    if (ThinkingQuantumChess.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(ref HaveKilled)) && (HaveKilled < 0))
                        {
                            return true;
                        }
                    }
                    if (!KillerForce(ref HaveKilled))
                    {
                        return true;
                    }

                    if (MaxLess6 > MaxLess1)
                    {
                        MaxLess1 = -1;
                    }

                    if (MaxLess6 > MaxLess2)
                    {
                        MaxLess2 = -1;
                    }

                    if (MaxLess6 > MaxLess3)
                    {
                        MaxLess3 = -1;
                    }

                    if (MaxLess6 > MaxLess4)
                    {
                        MaxLess4 = -1;
                    }

                    if (MaxLess6 > MaxLess5)
                    {
                        MaxLess5 = -1;
                    }

                    if (MaxLess6 > MaxLess7)
                    {
                        MaxLess7 = -1;
                    }

                    if (AStarGreedyi == 1)
                    {
                        OutputHeuristic(Order);
                        //Set Table and Heuristic Value and Syntax.
                        object On = new object();
                        lock (On)
                        {
                            Task ah4 = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                            ah4.Wait();
                            ah4.Dispose();

                            int[,] Th = TableHeuristic;
                            Task ah5 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                            ah5.Wait();
                            ah5.Dispose();
                            TableHeuristic = Th;

                            double le = Less;
                            AAA = AA;
                            Task ah6 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                            ah6.Wait();
                            ah6.Dispose();
                            Less = le;
                            AA = AAA;
                        }
                        Act = true;
                        // StringHeuristics(6, 3, AA, Do, KingOnTable[i].WinOcuuredatChiled, KingOnTable[i].LoseOcuuredatChiled);
                    }
                }
                else//Set Table and Heuristic Value and Syntax.
                {
                }
            }
            else if (Kind == 7 || Kind == -7)
            {
                bool ac = false;
                bool AAA = AA;
                double Le = Less;
                int Havk = HaveKilled;
                Task<bool> ah = Task.Factory.StartNew(() => ac = CastlingOnTable[i].CastlingThinking[0].ReturnHeuristic(i, j, Order, AAA, ref Havk) > Le);
                ah.Wait();
                ah.Dispose();
                AA = AAA;
                Less = Le;
                HaveKilled = Havk;
                if (ac)
                {
                    object OO = new object();
                    lock (OO)
                    {
                    }
                    //retrive table of current Heuristic.
                    //retrive table of current Heuristic.
                    int[,] TableS = CastlingOnTable[i].CastlingThinking[k].TableListCastling[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                    {
                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            //if (Order == 1)

                            //else

                            return true;
                        }
                    }
                    //When there is not Penalty regard mechanism.
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac =  CheckeHuristci(CloneATable(TableS), Order,Kind));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                    {
                        return true;
                    }

                    Task ah2 = Task.Factory.StartNew(() => InitiateVars(i, j, k, Kind));
                    ah2.Wait();
                    ah2.Dispose();

                    AAA = AA;
                    Havk = HaveKilled;
                    Task<double> ah3 = Task.Factory.StartNew(() => MaxLess7 = CastlingOnTable[RW7].CastlingThinking[CL7].ReturnHeuristic(i, j, Order, AAA, ref Havk));
                    ah3.Wait();
                    ah3.Dispose();
                    AA = AAA;
                    HaveKilled = Havk;

                    if (ThinkingQuantumChess.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(ref HaveKilled)) && (HaveKilled < 0))
                        {
                            return true;
                        }
                    }
                    if (!KillerForce(ref HaveKilled))
                    {
                        return true;
                    }

                    if (MaxLess7 > MaxLess1)
                    {
                        MaxLess1 = -1;
                    }

                    if (MaxLess7 > MaxLess2)
                    {
                        MaxLess2 = -1;
                    }

                    if (MaxLess7 > MaxLess3)
                    {
                        MaxLess3 = -1;
                    }

                    if (MaxLess7 > MaxLess4)
                    {
                        MaxLess4 = -1;
                    }

                    if (MaxLess7 > MaxLess5)
                    {
                        MaxLess5 = -1;
                    }

                    if (MaxLess7 > MaxLess5)
                    {
                        MaxLess6 = -1;
                    }

                    if (AStarGreedyi == 1)
                    {
                        OutputHeuristic(Order);
                        //Set Table and Heuristic Value and Syntax.
                        object On = new object();
                        lock (On)
                        {
                            Task ah4 = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                            ah4.Wait();
                            ah4.Dispose();

                            int[,] Th = TableHeuristic;
                            Task ah5 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                            ah5.Wait();
                            ah5.Dispose();
                            TableHeuristic = Th;

                            double le = Less;
                            AAA = AA;
                            Task ah6 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                            ah6.Wait();
                            ah6.Dispose();
                            Less = le;
                            AA = AAA;
                        }
                        Act = true;
                        // StringHeuristics(7, 3, AA, Do, CastlingOnTable[i].WinOcuuredatChiled, CastlingOnTable[i].LoseOcuuredatChiled);
                    }
                }
                else//Set Table and Heuristic Value and Syntax.
                {
                }
            }

            return continued;
        }

        //determined verified victom occured
        private bool KiilledForce(ref int HaveKiller)
        {
            if (ThinkingQuantumChess.IsAtLeastOneKillerAtDraw)
            {
                if (HaveKiller < 0)
                {
                    HaveKiller = 0;
                    return true;
                }
            }
            return false;
        }

        //detrmined verfied ingured occured
        private bool KillerForce(ref int HaveKiller)
        {
            bool s = ((ThinkingQuantumChess.IsAtLeastOneKillerAtDraw) || (!(HaveKiller < 0)));
            HaveKiller = 0;
            return s;
        }

        //determine when there is lose or checked self
        private bool Lose(int Kind, int i, int j, int Order)
        {
            bool Is = false;
            //HarasAlphaBeta(i, j, Kind);
            if (Kind == 1)
            {
                Is = Is || LoseS(Kind, i, j, Order);
            }
            else
        if (Kind == 2)
            {
                Is = Is || LoseE(Kind, i, j, Order);
            }
            else
        if (Kind == 3)
            {
                Is = Is || LoseH(Kind, i, j, Order);
            }
            else
        if (Kind == 4)
            {
                Is = Is || LoseC(Kind, i, j, Order);
            }
            else
        if (Kind == 5)
            {
                Is = Is || LoseM(Kind, i, j, Order);
            }
            else
        if (Kind == 6)
            {
                Is = Is || LoseK(Kind, i, j, Order);
            }
            else
       if (Kind == 7 || Kind == -7)
            {
                Is = Is || LoseA(Kind, i, j, Order);
            }
            return Is;
        }
        private bool LoseS(int Kind, int i, int j, int Order)
        {
            bool Is = false;
            //HarasAlphaBeta(i, j, Kind);
            try
            {
                if ((SolderesOnTable[i].SoldierThinkingQuantum[0].LoseChiled[j] <= -1 || SolderesOnTable[i].SoldierThinkingQuantum[0].LoseChiled[j] <= -2 || SolderesOnTable[i].SoldierThinkingQuantum[0].LoseChiled[j] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) == -1)
                {
                    return true;
                }

                if (!AllowedSupTrue)
                {
                    if ((SolderesOnTable[i].LoseOcuuredatChiled[0] <= -1 || SolderesOnTable[i].LoseOcuuredatChiled[0] <= -2 || SolderesOnTable[i].LoseOcuuredatChiled[0] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) == -1)
                    {
                        return true;
                    }
                }
            }
            catch (Exception t) { Log(t); }
            return Is;
        }
        private bool LoseE(int Kind, int i, int j, int Order)
        {
            bool Is = false;
            //HarasAlphaBeta(i, j, Kind);
            try
            {
                if ((ElephantOnTable[i].ElefantThinkingQuantum[0].LoseChiled[j] <= -1 || ElephantOnTable[i].ElefantThinkingQuantum[0].LoseChiled[j] <= -2 || ElephantOnTable[i].ElefantThinkingQuantum[0].LoseChiled[j] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) == -1)
                {
                    return true;
                }

                if (!AllowedSupTrue)
                {
                    if ((ElephantOnTable[i].LoseOcuuredatChiled[0] <= -1 || ElephantOnTable[i].LoseOcuuredatChiled[0] <= -2 || ElephantOnTable[i].LoseOcuuredatChiled[0] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) == -1)
                    {
                        return true;
                    }
                }
            }
            catch (Exception t)
            {
                Log(t);
            }
            return Is;
        }
        private bool LoseH(int Kind, int i, int j, int Order)
        {
            bool Is = false;
            //HarasAlphaBeta(i, j, Kind);
            try
            {
                if ((HoursesOnTable[i].HourseThinkingQuantum[0].LoseChiled[j] <= -1 || HoursesOnTable[i].HourseThinkingQuantum[0].LoseChiled[j] <= -2 || HoursesOnTable[i].HourseThinkingQuantum[0].LoseChiled[j] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) == -1)
                {
                    return true;
                }

                if (!AllowedSupTrue)
                {
                    if ((HoursesOnTable[i].LoseOcuuredatChiled[0] <= -1 || HoursesOnTable[i].LoseOcuuredatChiled[0] <= -2 || HoursesOnTable[i].LoseOcuuredatChiled[0] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) == -1)
                    {
                        return true;
                    }
                }
            }
            catch (Exception t) { Log(t); }
            return Is;
        }
        private bool LoseC(int Kind, int i, int j, int Order)
        {
            bool Is = false;
            //HarasAlphaBeta(i, j, Kind);
            try
            {
                if ((CastlesOnTable[i].CastleThinkingQuantum[0].LoseChiled[j] <= -1 || CastlesOnTable[i].CastleThinkingQuantum[0].LoseChiled[j] <= -2 || CastlesOnTable[i].CastleThinkingQuantum[0].LoseChiled[j] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) == -1)
                {
                    return true;
                }

                if (!AllowedSupTrue)
                {
                    if ((CastlesOnTable[i].LoseOcuuredatChiled[0] <= -1 || CastlesOnTable[i].LoseOcuuredatChiled[0] <= -2 || CastlesOnTable[i].LoseOcuuredatChiled[0] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) == -1)
                    {
                        return true;
                    }
                }
            }
            catch (Exception t) { Log(t); }
            return Is;
        }
        private bool LoseM(int Kind, int i, int j, int Order)
        {
            bool Is = false;
            //HarasAlphaBeta(i, j, Kind);
            try
            {
                if ((MinisterOnTable[i].MinisterThinkingQuantum[0].LoseChiled[j] <= -1 || MinisterOnTable[i].MinisterThinkingQuantum[0].LoseChiled[j] <= -2 || MinisterOnTable[i].MinisterThinkingQuantum[0].LoseChiled[j] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) == -1)
                {
                    return true;
                }

                if (!AllowedSupTrue)
                {
                    if ((MinisterOnTable[i].LoseOcuuredatChiled[0] <= -1 || MinisterOnTable[i].LoseOcuuredatChiled[0] <= -2 || MinisterOnTable[i].LoseOcuuredatChiled[0] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) == -1)
                    {
                        return true;
                    }
                }
            }
            catch (Exception t) { Log(t); }
            return Is;
        }
        private bool LoseK(int Kind, int i, int j, int Order)
        {
            bool Is = false;
            //HarasAlphaBeta(i, j, Kind);
            try
            {
                if ((KingOnTable[i].KingThinkingQuantum[0].LoseChiled[j] <= -1 || KingOnTable[i].KingThinkingQuantum[0].LoseChiled[j] <= -2 || KingOnTable[i].KingThinkingQuantum[0].LoseChiled[j] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) == -1)
                {
                    return true;
                }

                if (!AllowedSupTrue)
                {
                    if ((KingOnTable[i].LoseOcuuredatChiled[0] <= -1 || KingOnTable[i].LoseOcuuredatChiled[0] <= -2 || KingOnTable[i].LoseOcuuredatChiled[0] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) == -1)
                    {
                        return true;
                    }
                }
            }
            catch (Exception t) { Log(t); }
            return Is;
        }
        private bool LoseA(int Kind, int i, int j, int Order)
        {
            bool Is = false;
            //HarasAlphaBeta(i, j, Kind);
            try
            {
                if ((CastlingOnTable[i].CastlingThinking[0].LoseChiled[j] <= -1 || CastlingOnTable[i].CastlingThinking[0].LoseChiled[j] <= -2 || CastlingOnTable[i].CastlingThinking[0].LoseChiled[j] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) == -1)
                {
                    return true;
                }

                if (!AllowedSupTrue)
                {
                    if ((CastlingOnTable[i].LoseOcuuredatChiled[0] <= -1 || CastlingOnTable[i].LoseOcuuredatChiled[0] <= -2 || CastlingOnTable[i].LoseOcuuredatChiled[0] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) == -1)
                    {
                        return true;
                    }
                }
            }
            catch (Exception t) { Log(t); }
            return Is;
        }
        private bool WinReturnValue(int Kind, int i, int j)
        {
            bool Is = false;
            if (Kind == 1)
            {
                bool B = SolderesOnTable[i].WinOcuuredatChiled >= 1 || SolderesOnTable[i].WinOcuuredatChiled >= 2 || SolderesOnTable[i].WinOcuuredatChiled >= 3;
                Is = B;
            }
            else
      if (Kind == 2)
            {
                bool B = ElephantOnTable[i].WinOcuuredatChiled >= 1 || ElephantOnTable[i].WinOcuuredatChiled >= 2 || ElephantOnTable[i].WinOcuuredatChiled >= 3;
                Is = B;
            }
            else
      if (Kind == 3)
            {
                bool B = HoursesOnTable[i].WinOcuuredatChiled >= 1 || HoursesOnTable[i].WinOcuuredatChiled >= 2 || HoursesOnTable[i].WinOcuuredatChiled >= 3;
                Is = B;
            }
            else
      if (Kind == 4)
            {
                bool B = CastlesOnTable[i].WinOcuuredatChiled >= 1 || CastlesOnTable[i].WinOcuuredatChiled >= 2 || CastlesOnTable[i].WinOcuuredatChiled >= 3;
                Is = B;
            }
            else
      if (Kind == 5)
            {
                bool B = MinisterOnTable[i].WinOcuuredatChiled >= 1 || MinisterOnTable[i].WinOcuuredatChiled >= 2 || MinisterOnTable[i].WinOcuuredatChiled >= 3;
                Is = B;
            }
            else
      if (Kind == 6)
            {
                bool B = KingOnTable[i].WinOcuuredatChiled >= 1 || KingOnTable[i].WinOcuuredatChiled >= 2 || KingOnTable[i].WinOcuuredatChiled >= 3;
                Is = B;
            }
            else
       if (Kind == 7 || Kind == -7)
            {
                bool B = CastlingOnTable[i].WinOcuuredatChiled >= 1 || CastlingOnTable[i].WinOcuuredatChiled >= 2 || CastlingOnTable[i].WinOcuuredatChiled >= 3;
                Is = B;
            }
            return Is;
        }

        private bool WinPerfromeRegardMethod(int Kind, int i, int j)
        {
            bool Is = false;
            if (Kind == 1)
            {
                try
                {
                    bool A = false;

                    A = A || SolderesOnTable[i].SoldierThinkingQuantum[0].WinChiled[j] >= 1 || SolderesOnTable[i].SoldierThinkingQuantum[0].WinChiled[j] >= 2 || SolderesOnTable[i].SoldierThinkingQuantum[0].WinChiled[j] >= 3;

                    Is = A;
                }
                catch (Exception t) { Log(t); }
            }
            else
    if (Kind == 2)
            {
                try
                {
                    bool A = false;

                    A = A || ElephantOnTable[i].ElefantThinkingQuantum[0].WinChiled[j] >= 1 || ElephantOnTable[i].ElefantThinkingQuantum[0].WinChiled[j] >= 2 || ElephantOnTable[i].ElefantThinkingQuantum[0].WinChiled[j] >= 3;

                    Is = A;
                }
                catch (Exception t) { Log(t); }
            }
            else
    if (Kind == 3)
            {
                try
                {
                    bool A = false;

                    A = A || HoursesOnTable[i].HourseThinkingQuantum[0].WinChiled[j] >= 1 || HoursesOnTable[i].HourseThinkingQuantum[0].WinChiled[j] >= 2 || HoursesOnTable[i].HourseThinkingQuantum[0].WinChiled[j] >= 3;

                    Is = A;
                }
                catch (Exception t)
                {
                    Log(t);
                }
            }
            else
    if (Kind == 4)
            {
                try
                {
                    bool A = false;

                    A = A || CastlesOnTable[i].CastleThinkingQuantum[0].WinChiled[j] >= 1 || CastlesOnTable[i].CastleThinkingQuantum[0].WinChiled[j] >= 2 || CastlesOnTable[i].CastleThinkingQuantum[0].WinChiled[j] >= 3;

                    Is = A;
                }
                catch (Exception t) { Log(t); }
            }
            else
    if (Kind == 5)
            {
                try
                {
                    bool A = false;

                    A = A || MinisterOnTable[i].MinisterThinkingQuantum[0].WinChiled[j] >= 1 || MinisterOnTable[i].MinisterThinkingQuantum[0].WinChiled[j] >= 2 || MinisterOnTable[i].MinisterThinkingQuantum[0].WinChiled[j] >= 3;

                    Is = A;
                }
                catch (Exception t) { Log(t); }
            }
            else
    if (Kind == 6)
            {
                try
                {
                    bool A = false;

                    A = A || KingOnTable[i].KingThinkingQuantum[0].WinChiled[j] >= 1 || KingOnTable[i].KingThinkingQuantum[0].WinChiled[j] >= 2 || KingOnTable[i].KingThinkingQuantum[0].WinChiled[j] >= 3;

                    Is = A;
                }
                catch (Exception t) { Log(t); }
            }
            else
    if (Kind == 7 || Kind == -7)
            {
                try
                {
                    bool A = false;

                    A = A || CastlingOnTable[i].CastlingThinking[0].WinChiled[j] >= 1 || CastlingOnTable[i].CastlingThinking[0].WinChiled[j] >= 2 || CastlingOnTable[i].CastlingThinking[0].WinChiled[j] >= 3;

                    Is = A;
                }
                catch (Exception t) { Log(t); }
            }
            return Is;
        }

        //soldier Heuristic
        private int[,] HeuristicAStarGreadySearchSoldier(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object a1 = new object();
            lock (a1)
            {
                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;

                //For Every Soldier Movments AStarGreedy.
                for (int k = 0; k < AllDraw.SodierMovments; k++)
                //When There is an Movment in such situation.
                {
                    for (j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum != null && SolderesOnTable[i].SoldierThinkingQuantum[k] != null && j < SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder.Count; j++)
                    {
                        bool ac = false;
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 1));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (SolderesOnTable[i].SoldierThinkingQuantum[k].PenaltyRegardListSolder[j].IsPenaltyAction() == 0)
                            {
                                continue;
                            }

                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            if (SolderesOnTable[i].SoldierThinkingQuantum[k].AStarGreedy.Count > j && SolderesOnTable[i].SoldierThinkingQuantum[k].AStarGreedy[j] != null)
                            {
                                bool AAAA = AA;
                                Task<bool> ah = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinkingQuantum[k].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(1, ref AAAA, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                AA = AAAA;
                            }
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;

                            // StringHeuristics(1, 1, AA, Do, SolderesOnTable[i].WinOcuuredatChiled, SolderesOnTable[i].LoseOcuuredatChiled);
                            /* var ah3 = Task.Factory.StartNew(() => ac = Lose(1, i, j, Order));
                           ah3.Wait();
                           ah3.Dispose();
                           if (ac)
                               continue;*/
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)

                            bool Ac = Act;
                            int[,] Ta = TableHeuristic;
                            bool AAA = AA;
                            int D = Do;
                            Task<bool> ah4 = Task.Factory.StartNew(() => ac = HeuristicRegardSection(i, j, k, ref Ac, ref Ta, ref AAA, a, 1, ref D, AStarGreedyi, Order));
                            ah4.Wait();
                            ah4.Dispose();
                            Act = ac;
                            TableHeuristic = Ta;
                            AA = AAA;
                            if (ac)
                            {
                                continue;
                            }
                            //When There is No Movments in Such Order Enemy continue.
                            object ol = new object();
                            lock (ol)
                            {
                                if (Order != AllDraw.OrderPlateDraw)
                                {
                                    if (SolderesOnTable[i].SoldierThinkingQuantum[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                    {
                                        continue;
                                    }
                                }
                                //When There is greater Heuristic Movments.
                                Ac = Act;
                                Ta = TableHeuristic;
                                bool CuTH = CurrentTableHeuristic;
                                AAA = AA;
                                D = Do;
                                Task<bool> ah5 = Task.Factory.StartNew(() => ac = HeuristicMainBody(i, j, k, ref Ac, ref Ta, ref CuTH, ref AAA, a, 1, ref D, AStarGreedyi, Order));
                                ah5.Wait();
                                ah5.Dispose();
                                Act = ac;
                                TableHeuristic = Ta;
                                CurrentTableHeuristic = CuTH;
                                AA = AAA;
                                if (ac)
                                {
                                    continue;
                                }
                            }
                        }
                    }
                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                return TableHeuristic;
            }
        }

        //Gray section of soldier Heuristic
        private int[,] HeuristicAStarGreadySearchSoldierGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object a1 = new object();
            lock (a1)
            {
                if (SodierMidle != 0)
                {
                    for (int i = 0; i < SodierMidle; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        Task<int[,]> ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchSoldier(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;
                    }
                }
                //else

                return TableHeuristic;
            }
        }

        //Brown section of soldier Heuristic
        private int[,] HeuristicAStarGreadySearchSoldierBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object a1 = new object();
            lock (a1)
            {
                if (SodierMidle != SodierHigh)
                {
                    for (int i = SodierMidle; i < SodierHigh; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        Task<int[,]> ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchSoldier(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;
                    }
                }
                //else

                return TableHeuristic;
            }
        }

        //Gray section of elephant Heuristic
        private int[,] HeuristicAStarGreadySearchElephantGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object a1 = new object();
            lock (a1)
            {
                if (0 != ElefantMidle)
                {
                    //Do For Remaining Objects same as Soldeir Documentation.
                    for (int i = 0; i < ElefantMidle; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        Task<int[,]> ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchElephant(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;
                    }
                }
                //else

                return TableHeuristic;
            }
        }

        //Brown section of elephant Heuristic
        private int[,] HeuristicAStarGreadySearchElephantBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object a1 = new object();
            lock (a1)
            {
                if (ElefantHigh != ElefantMidle)
                {
                    //Do For Remaining Objects same as Soldeir Documentation.
                    for (int i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        Task<int[,]> ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchElephant(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;
                    }
                }
                //else

                return TableHeuristic;
            }
        }

        //main section of elephant Heuristic
        private int[,] HeuristicAStarGreadySearchElephant(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object a1 = new object();
            lock (a1)
            {
                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;
                for (int k = 0; k < AllDraw.ElefantMovments; k++)
                {
                    for (j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum != null && ElephantOnTable[i].ElefantThinkingQuantum[k] != null && j < ElephantOnTable[i].ElefantThinkingQuantum[k].TableListElefant.Count; j++)
                    {
                        bool ac = false;
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 2));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (ElephantOnTable[i].ElefantThinkingQuantum[k].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)
                            {
                                continue;
                            }

                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            if (ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count > j && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j] != null)
                            {
                                bool AAAA = AA;
                                Task<bool> ah = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(1, ref AAAA, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                AA = AAAA;
                            }
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;

                            // StringHeuristics(2, 1, AA, Do, ElephantOnTable[i].WinOcuuredatChiled, ElephantOnTable[i].LoseOcuuredatChiled);
                            /* var ah3 = Task.Factory.StartNew(() => ac = Lose(2, i, j, Order));
                          ah3.Wait();
                          ah3.Dispose();
                          if (ac)
                              continue;*/
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            bool Ac = Act;
                            int[,] Ta = TableHeuristic;
                            bool AAA = AA;
                            int D = Do;
                            Task<bool> ah4 = Task.Factory.StartNew(() => ac = HeuristicRegardSection(i, j, k, ref Ac, ref Ta, ref AAA, a, 2, ref D, AStarGreedyi, Order));
                            ah4.Wait();
                            ah4.Dispose();
                            Act = ac;
                            TableHeuristic = Ta;
                            AA = AAA;
                            if (ac)
                            {
                                continue;
                            }

                            object ol = new object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                {
                                    if (ElephantOnTable[i].ElefantThinkingQuantum[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                    {
                                        continue;
                                    }
                                }
                                //When There is greater Heuristic Movments.
                                Ac = Act;
                                Ta = TableHeuristic;
                                bool CuTH = CurrentTableHeuristic;
                                AAA = AA;
                                D = Do;
                                Task<bool> ah5 = Task.Factory.StartNew(() => ac = HeuristicMainBody(i, j, k, ref Ac, ref Ta, ref CuTH, ref AAA, a, 2, ref D, AStarGreedyi, Order));
                                ah5.Wait();
                                ah5.Dispose();
                                Act = ac;
                                TableHeuristic = Ta;
                                CurrentTableHeuristic = CuTH;
                                AA = AAA;
                                if (ac)
                                {
                                    continue;
                                }
                            }
                        }
                    }
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                return TableHeuristic;
            }
        }

        //Gray section of hourse Heuristic
        private int[,] HeuristicAStarGreadySearchHourseGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object a1 = new object();
            lock (a1)
            {
                if (0 != HourseMidle)
                {
                    //For Every Soldeir
                    for (int i = 0; i < HourseMidle; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        Task<int[,]> ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchHourse(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;
                    }
                }
                // else

                return TableHeuristic;
            }
        }

        //Brown section of hourse Heuristic
        private int[,] HeuristicAStarGreadySearchHourseBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object a1 = new object();
            lock (a1)
            {
                if (HourseHight != HourseMidle)
                {
                    //For Every Soldeir
                    for (int i = HourseMidle; i < HourseHight; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        Task<int[,]> ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchHourse(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;
                    }
                }
                //else

                return TableHeuristic;
            }
        }

        //main section of hourse Heuristic
        private int[,] HeuristicAStarGreadySearchHourse(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object a1 = new object();
            lock (a1)
            {
                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;

                for (int k = 0; k < AllDraw.HourseMovments; k++)
                {
                    for (j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum != null && HoursesOnTable[i].HourseThinkingQuantum[k] != null && j < HoursesOnTable[i].HourseThinkingQuantum[k].TableListHourse.Count; j++)
                    {
                        bool ac = false;
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 3));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (HoursesOnTable[i].HourseThinkingQuantum[k].PenaltyRegardListHourse[j].IsPenaltyAction() == 0)
                            {
                                continue;
                            }

                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            if (HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count > j && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j] != null)
                            {
                                bool AAAA = AA;
                                Task<bool> ah = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(1, ref AAAA, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                AA = AAAA;
                            }
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            // StringHeuristics(3, 1, AA, Do, HoursesOnTable[i].WinOcuuredatChiled, HoursesOnTable[i].LoseOcuuredatChiled);
                            /* var ah3 = Task.Factory.StartNew(() => ac = Lose(3, i, j, Order));
                        ah3.Wait();
                        ah3.Dispose();
                        if (ac)
                            continue;*/

                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            bool Ac = Act;
                            int[,] Ta = TableHeuristic;
                            bool AAA = AA;
                            int D = Do;
                            Task<bool> ah4 = Task.Factory.StartNew(() => ac = HeuristicRegardSection(i, j, k, ref Ac, ref Ta, ref AAA, a, 3, ref D, AStarGreedyi, Order));
                            ah4.Wait();
                            ah4.Dispose();
                            Act = ac;
                            TableHeuristic = Ta;
                            AA = AAA;
                            if (ac)
                            {
                                continue;
                            }

                            object ol = new object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                {
                                    if (HoursesOnTable[i].HourseThinkingQuantum[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                    {
                                        continue;
                                    }
                                }
                                //When There is greater Heuristic Movments.
                                Ac = Act;
                                Ta = TableHeuristic;
                                bool CuTH = CurrentTableHeuristic;
                                AAA = AA;
                                D = Do;
                                Task<bool> ah5 = Task.Factory.StartNew(() => ac = HeuristicMainBody(i, j, k, ref Ac, ref Ta, ref CuTH, ref AAA, a, 3, ref D, AStarGreedyi, Order));
                                ah5.Wait();
                                ah5.Dispose();
                                Act = ac;
                                TableHeuristic = Ta;
                                CurrentTableHeuristic = CuTH;
                                AA = AAA;
                                if (ac)
                                {
                                    continue;
                                }
                            }
                        }
                    }
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                return TableHeuristic;
            }
        }

        //Gray section of Castle Heuristic
        private int[,] HeuristicAStarGreadySearchCastleGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object O = new object();
            lock (O)
            {
                if (0 != HourseMidle)
                {
                    for (int i = 0; i < CastleMidle; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        Task<int[,]> ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchCastle(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;
                    }
                }
                //else

                return TableHeuristic;
            }
        }

        //main Brown section of Castle Heuristic
        private int[,] HeuristicAStarGreadySearchCastleBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object O = new object();
            lock (O)
            {
                if (CastleMidle != CastleHigh)
                {
                    for (int i = CastleMidle; i < CastleHigh; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        Task<int[,]> ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchCastle(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;
                    }
                }
                //else

                return TableHeuristic;
            }
        }

        //main section of Castle Heuristic
        private int[,] HeuristicAStarGreadySearchCastle(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object O1 = new object();
            lock (O1)
            {
                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;
                for (int k = 0; k < AllDraw.CastleMovments; k++)
                {
                    for (j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum != null && CastlesOnTable[i].CastleThinkingQuantum[k] != null && j < CastlesOnTable[i].CastleThinkingQuantum[k].TableListCastle.Count; j++)
                    {
                        bool ac = false;
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 4));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (CastlesOnTable[i].CastleThinkingQuantum[k].PenaltyRegardListCastle[j].IsPenaltyAction() == 0)
                            {
                                continue;
                            }

                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            if (CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count > j && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j] != null)
                            {
                                bool AAAA = AA;
                                Task<bool> ah = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(1, ref AAAA, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                AA = AAAA;
                            }
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Order = COrder;
                            // StringHeuristics(4, 1, AA, Do, CastlesOnTable[i].WinOcuuredatChiled, CastlesOnTable[i].LoseOcuuredatChiled);
                            /* var ah3 = Task.Factory.StartNew(() => ac = Lose(4, i, j, Order));
                         ah3.Wait();
                         ah3.Dispose();
                         if (ac)
                             continue;*/
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)

                            bool Ac = Act;
                            int[,] Ta = TableHeuristic;
                            bool AAA = AA;
                            int D = Do;
                            Task<bool> ah4 = Task.Factory.StartNew(() => ac = HeuristicRegardSection(i, j, k, ref Ac, ref Ta, ref AAA, a, 4, ref D, AStarGreedyi, Order));
                            ah4.Wait();
                            ah4.Dispose();
                            Act = ac;
                            TableHeuristic = Ta;
                            AA = AAA;
                            if (ac)
                            {
                                continue;
                            }

                            object ol = new object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                {
                                    if (CastlesOnTable[i].CastleThinkingQuantum[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                    {
                                        continue;
                                    }
                                }
                                //When There is greater Heuristic Movments.
                                Ac = Act;
                                Ta = TableHeuristic;
                                bool CuTH = CurrentTableHeuristic;
                                AAA = AA;
                                D = Do;
                                Task<bool> ah5 = Task.Factory.StartNew(() => ac = HeuristicMainBody(i, j, k, ref Ac, ref Ta, ref CuTH, ref AAA, a, 4, ref D, AStarGreedyi, Order));
                                ah5.Wait();
                                ah5.Dispose();
                                Act = ac;
                                TableHeuristic = Ta;
                                CurrentTableHeuristic = CuTH;
                                AA = AAA;
                                if (ac)
                                {
                                    continue;
                                }
                            }
                        }
                    }
                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                return TableHeuristic;
            }
        }

        //main section of minister Heuristic
        private int[,] HeuristicAStarGreadySearchMinsisterGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object O = new object();
            lock (O)
            {
                if (0 != MinisterMidle)
                {
                    for (int i = 0; i < MinisterMidle; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        Task<int[,]> ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchMinsister(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;
                    }
                }
                //else

                return TableHeuristic;
            }
        }

        //Brown main section of minister Heuristic
        private int[,] HeuristicAStarGreadySearchMinsisterBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object O = new object();
            lock (O)
            {
                if (MinisterHigh != MinisterMidle)
                {
                    for (int i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        Task<int[,]> ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchMinsister(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;
                    }
                }
                //else

                return TableHeuristic;
            }
        }

        //main section of minister Heuristic
        private int[,] HeuristicAStarGreadySearchMinsister(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object O3 = new object();
            lock (O3)
            {
                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;
                for (int k = 0; k < AllDraw.MinisterMovments; k++)
                {
                    for (j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum != null && MinisterOnTable[i].MinisterThinkingQuantum[k] != null && j < MinisterOnTable[i].MinisterThinkingQuantum[k].TableListMinister.Count; j++)
                    {
                        bool ac = false;
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 5));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (MinisterOnTable[i].MinisterThinkingQuantum[k].PenaltyRegardListMinister[j].IsPenaltyAction() == 0)
                            {
                                continue;
                            }

                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            if (MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count > j && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j] != null)
                            {
                                bool AAAA = AA;
                                Task<bool> ah = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(1, ref AAAA, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                AA = AAAA;
                            }
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            // StringHeuristics(5, 1, AA, Do, MinisterOnTable[i].WinOcuuredatChiled, MinisterOnTable[i].LoseOcuuredatChiled);
                            /* var ah3 = Task.Factory.StartNew(() => ac = Lose(5, i, j, Order));
                         ah3.Wait();
                         ah3.Dispose();
                         if (ac)
                             continue;*/
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)

                            bool Ac = Act;
                            int[,] Ta = TableHeuristic;
                            bool AAA = AA;
                            int D = Do;
                            Task<bool> ah4 = Task.Factory.StartNew(() => ac = HeuristicRegardSection(i, j, k, ref Ac, ref Ta, ref AAA, a, 5, ref D, AStarGreedyi, Order));
                            ah4.Wait();
                            ah4.Dispose();
                            Act = ac;
                            TableHeuristic = Ta;
                            AA = AAA;
                            if (ac)
                            {
                                continue;
                            }

                            object ol = new object();
                            lock (ol)
                            {
                                if (Order != AllDraw.OrderPlateDraw)
                                {
                                    if (MinisterOnTable[i].MinisterThinkingQuantum[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                    {
                                        continue;
                                    }
                                }

                                Ac = Act;
                                Ta = TableHeuristic;
                                bool CuTH = CurrentTableHeuristic;
                                AAA = AA;
                                D = Do;
                                Task<bool> ah5 = Task.Factory.StartNew(() => ac = HeuristicMainBody(i, j, k, ref Ac, ref Ta, ref CuTH, ref AAA, a, 5, ref D, AStarGreedyi, Order));
                                ah5.Wait();
                                ah5.Dispose();
                                Act = ac;
                                TableHeuristic = Ta;
                                CurrentTableHeuristic = CuTH;
                                AA = AAA;
                                if (ac)
                                {
                                    continue;
                                }
                            }
                        }
                    }
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                return TableHeuristic;
            }
        }

        //main Gray section of king Heuristic
        private int[,] HeuristicAStarGreadySearchKingGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object O = new object();
            lock (O)
            {
                if (0 != KingMidle)
                {
                    for (int i = 0; i < KingMidle; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        Task<int[,]> ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchKing(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;
                    }
                }
                // else

                return TableHeuristic;
            }
        }

        private int[,] HeuristicAStarGreadySearchCastlingGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object O = new object();
            lock (O)
            {
                if (0 != 1)
                {
                    for (int i = 0; i < 1; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        Task<int[,]> ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchCastling(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;
                    }
                }
                // else

                return TableHeuristic;
            }
        }

        //main Brown section of king Heuristic
        private int[,] HeuristicAStarGreadySearchKingBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object O = new object();
            lock (O)
            {
                if (KingHigh != KingMidle)
                {
                    for (int i = KingMidle; i < KingHigh; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        Task<int[,]> ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchKing(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;
                    }
                }
                // else

                return TableHeuristic;
            }
        }

        private int[,] HeuristicAStarGreadySearchCastlingBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object O = new object();
            lock (O)
            {
                if (0 != 1)
                {
                    for (int i = 0; i < 1; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        Task<int[,]> ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchCastling(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;
                    }
                }
                // else

                return TableHeuristic;
            }
        }

        //main section of king Heuristic
        private int[,] HeuristicAStarGreadySearchCastling(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object O = new object();
            lock (O)
            {
                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;
                for (int k = 0; k < 1; k++)
                {
                    for (j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[k] != null && CastlingOnTable[i].CastlingThinking != null && j < CastlingOnTable[i].CastlingThinking[k].TableListCastling.Count; j++)
                    {
                        bool ac = false;
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 7));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (CastlingOnTable[i].CastlingThinking[k].PenaltyRegardListCastling[j].IsPenaltyAction() == 0)
                            {
                                continue;
                            }

                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j && CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j] != null)
                            {
                                bool AAAA = AA;
                                Task<bool> ah = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(1, ref AAAA, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                AA = AAAA;
                            }
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            // StringHeuristics(6, 1, AA, Do, CastlingOnTable[i].WinOcuuredatChiled, CastlingOnTable[i].LoseOcuuredatChiled);

                            /* var ah3 = Task.Factory.StartNew(() => ac = Lose(7, i, j, Order));
                            ah3.Wait();
                            ah3.Dispose();
                            if (ac)
                                continue;*/
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)

                            bool Ac = Act;
                            int[,] Ta = TableHeuristic;
                            bool AAA = AA;
                            int D = Do;
                            Task<bool> ah4 = Task.Factory.StartNew(() => ac = HeuristicRegardSection(i, j, k, ref Ac, ref Ta, ref AAA, a, 6, ref D, AStarGreedyi, Order));
                            ah4.Wait();
                            ah4.Dispose();
                            Act = ac;
                            TableHeuristic = Ta;
                            AA = AAA;
                            if (ac)
                            {
                                continue;
                            }

                            object ol = new object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                {
                                    if (CastlingOnTable[i].CastlingThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                    {
                                        continue;
                                    }
                                }
                                //When There is greater Heuristic Movments.
                                Ac = Act;
                                Ta = TableHeuristic;
                                bool CuTH = CurrentTableHeuristic;
                                AAA = AA;
                                D = Do;
                                Task<bool> ah5 = Task.Factory.StartNew(() => ac = HeuristicMainBody(i, j, k, ref Ac, ref Ta, ref CuTH, ref AAA, a, 7, ref D, AStarGreedyi, Order));
                                ah5.Wait();
                                ah5.Dispose();
                                Act = ac;
                                TableHeuristic = Ta;
                                CurrentTableHeuristic = CuTH;
                                AA = AAA;
                                if (ac)
                                {
                                    continue;
                                }
                            }
                        }
                    }
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                return TableHeuristic;
            }
        }

        //main section of king Heuristic
        private int[,] HeuristicAStarGreadySearchKing(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object O = new object();
            lock (O)
            {
                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;
                for (int k = 0; k < AllDraw.KingMovments; k++)
                {
                    for (j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum[k] != null && KingOnTable[i].KingThinkingQuantum != null && j < KingOnTable[i].KingThinkingQuantum[k].TableListKing.Count; j++)
                    {
                        bool ac = false;
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 6));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (KingOnTable[i].KingThinkingQuantum[k].PenaltyRegardListKing[j].IsPenaltyAction() == 0)
                            {
                                continue;
                            }

                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            if (KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count > j && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j] != null)
                            {
                                bool AAAA = AA;
                                Task<bool> ah = Task.Factory.StartNew(() => KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(1, ref AAAA, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                AA = AAAA;
                            }
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            // StringHeuristics(6, 1, AA, Do, KingOnTable[i].WinOcuuredatChiled, KingOnTable[i].LoseOcuuredatChiled);

                            /* var ah3 = Task.Factory.StartNew(() => ac = Lose(6, i, j, Order));
                        ah3.Wait();
                        ah3.Dispose();
                        if (ac)
                            continue;*/
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)

                            bool Ac = Act;
                            int[,] Ta = TableHeuristic;
                            bool AAA = AA;
                            int D = Do;
                            Task<bool> ah4 = Task.Factory.StartNew(() => ac = HeuristicRegardSection(i, j, k, ref Ac, ref Ta, ref AAA, a, 6, ref D, AStarGreedyi, Order));
                            ah4.Wait();
                            ah4.Dispose();
                            Act = ac;
                            TableHeuristic = Ta;
                            AA = AAA;
                            if (ac)
                            {
                                continue;
                            }

                            object ol = new object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                {
                                    if (KingOnTable[i].KingThinkingQuantum[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                    {
                                        continue;
                                    }
                                }
                                //When There is greater Heuristic Movments.
                                Ac = Act;
                                Ta = TableHeuristic;
                                bool CuTH = CurrentTableHeuristic;
                                AAA = AA;
                                D = Do;
                                Task<bool> ah5 = Task.Factory.StartNew(() => ac = HeuristicMainBody(i, j, k, ref Ac, ref Ta, ref CuTH, ref AAA, a, 6, ref D, AStarGreedyi, Order));
                                ah5.Wait();
                                ah5.Dispose();
                                Act = ac;
                                TableHeuristic = Ta;
                                CurrentTableHeuristic = CuTH;
                                AA = AAA;
                                if (ac)
                                {
                                    continue;
                                }
                            }
                        }
                    }
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                return TableHeuristic;
            }
        }

        //main Gray section of  Heuristic
        private int[,] HeuristicAStarGreadySearchGray(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object O = new object();
            lock (O)
            {
                int[,] TableHeuristic = new int[8, 8];
                bool Ac = Act;
                int[,] Ta = TableHeuristic;
                Task<int[,]> ah = Task.Factory.StartNew(() => HeuristicAStarGreadySearchSoldierGray(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                ah.Wait();
                ah.Dispose();
                Act = Ac;
                TableHeuristic = Ta;

                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    Task<int[,]> ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchElephantGray(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    Task<int[,]> ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchHourseGray(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }

                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    Task<int[,]> ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchCastleGray(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    Task<int[,]> ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchMinsisterGray(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    Task<int[,]> ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchKingGray(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    Task<int[,]> ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchCastlingGray(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                return TableHeuristic;
            }
        }

        //main Brown section of Heuristic
        private int[,] HeuristicAStarGreadySearchBrown(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            object O = new object();
            lock (O)
            {
                int[,] TableHeuristic = new int[8, 8];
                bool Ac = Act;
                int[,] Ta = TableHeuristic;
                Task<int[,]> ah = Task.Factory.StartNew(() => HeuristicAStarGreadySearchSoldierBrown(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                ah.Wait();
                ah.Dispose();
                Act = Ac;
                TableHeuristic = Ta;

                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    Task<int[,]> ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchElephantBrown(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    Task<int[,]> ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchHourseBrown(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }

                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    Task<int[,]> ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchCastleBrown(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    Task<int[,]> ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchMinsisterBrown(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    Task<int[,]> ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchKingBrown(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    Task<int[,]> ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchCastlingBrown(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                return TableHeuristic;
            }
        }

        //Brown section of penalty Heuristic
        /*int[,] BrownHeuristicAStarGreaedySearchPenalites(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {
            Object O = new Object();
            lock (O)
            {
                ChessRules AB = null;
                int ToCheckMate = -1, ForCheckMate = -1, j, i;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;
                int[,] TableHeuristic = new int[8, 8];
                //For Every Soldeir
                for (i = SodierMidle; i < SodierHigh; i++)
                {
                    //For Every Soldier Movments AStarGreedy.
                    for (int k = 0; k < AllDraw.SodierMovments; k++)
                        //When There is an Movment in such situation.
                        for (j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum[k] != null && SolderesOnTable[i].SoldierThinkingQuantum[k] != null && j < SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder.Count; j++)
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < SolderesOnTable[i].SoldierThinkingQuantum[k].AStarGreedy.Count - 1; ij++)
                                    SolderesOnTable[i].SoldierThinkingQuantum[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, SolderesOnTable[i].SoldierThinkingQuantum[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }

                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            if ((SolderesOnTable[i].SoldierThinkingQuantum[k].PenaltyRegardListSolder[j].IsPenaltyAction() != 0 && SolderesOnTable[i].SoldierThinkingQuantum[k].PenaltyRegardListSolder[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {
                                //Set Table and Heuristic Value and Syntax.
                                Act = true;
                                Object o1l = new Object();
                                lock (o1l)
                                {
                                    AllDraw.LastRowQ = SolderesOnTable[i].SoldierThinkingQuantum[k].Row;
                                    AllDraw.LastColumnQ = SolderesOnTable[i].SoldierThinkingQuantum[k].Column;
                                    AllDraw.NextRowQ = SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0];
                                    AllDraw.NextColumnQ = SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1];
                                    Less = SolderesOnTable[i].SoldierThinkingQuantum[k].NumberOfPenalties;
                                }

                                TableHeuristic = SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder[j];

                                Object OO = new Object();
                                lock (OO)
                                {
                                    ThingsConverter.ActOfClickEqualTow = true;
                                }
                                SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder[j], Order, false, i);
                                int Sign = 1;
                                if (a == Color.Brown)
                                    Sign = -1;
                                //If there is Soldier Convert.
                                if (SolderesOnTable[i].Convert)
                                {
                                    if (SolderesOnTable[i].ConvertedToMinister)
                                        TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                    else if (SolderesOnTable[i].ConvertedToCastle)
                                        TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                    else if (SolderesOnTable[i].ConvertedToHourse)
                                        TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                    else if (SolderesOnTable[i].ConvertedToElefant)
                                        TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 2 * Sign;

                                    RegardOccurred = true;
                                    continue;
                                }
                            }
                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (SolderesOnTable[i].SoldierThinkingQuantum[0].NumberOfPenalties < Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                if (SolderesOnTable[i].SoldierThinkingQuantum[0].NumberOfPenalties < Less)
                                {
                                    //retrive table of current Heuristic.
                                    int[,] TableS = SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                    {
                                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                            continue;
                                    }
                                    //When there is not Penalty regard mechanism.
                                    AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 1, CloneATable(TableS), Order, SolderesOnTable[i].SoldierThinkingQuantum[k].Row, SolderesOnTable[i].SoldierThinkingQuantum[k].Column);
                                    //If there is kish or kshachamaz Order.
                                    if (AB.Check(CloneATable(TableS), Order))
                                    {
                                        //When Order is Gray.
                                        if (Order == 1)
                                        {
                                            //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                            if (AB.CheckGray)
                                                continue;
                                        }
                                        else
                                        {
                                            //Continue when CheckBrown and AStarGreadyFirstSearch.
                                            if (AB.CheckBrown)
                                                continue;
                                        }
                                    }
                                    RW1 = i;
                                    CL1 = k;
                                    Ki1 = j;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess1 = SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].NumberOfPenalties;
                                    if (MaxLess1 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess1 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess1 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess1 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (MaxLess1 > MaxLess6)
                                        MaxLess6 = -1;
                                    //Set Table and Heuristic Value and Syntax.
                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                            }
                                            else//If Order is Brown.
                                            {
                                            }
                                        }
                                        //Set Table and Heuristic Value and Syntax.
                                        Act = true;
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRowQ = SolderesOnTable[i].SoldierThinkingQuantum[k].Row;
                                            AllDraw.LastColumnQ = SolderesOnTable[i].SoldierThinkingQuantum[k].Column;
                                            AllDraw.NextRowQ = SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0];
                                            AllDraw.NextColumnQ = SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1];
                                        }
                                        Less = SolderesOnTable[i].SoldierThinkingQuantum[k].NumberOfPenalties;

                                        TableHeuristic = SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder[j];

                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            ThingsConverter.ActOfClickEqualTow = true;
                                        }
                                        SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinkingQuantum[k].TableListSolder[j], Order, false, i);
                                        int Sign = 1;
                                        if (a == Color.Brown)
                                            Sign = -1;
                                        //If there is Soldier Convert.
                                        if (SolderesOnTable[i].Convert)
                                        {
                                            if (SolderesOnTable[i].ConvertedToMinister)
                                                TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToCastle)
                                                TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToHourse)
                                                TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToElefant)
                                                TableHeuristic[SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1]] = 2 * Sign;
                                        }
                                    }
                                    else
                                    {  //Set Table and Heuristic Value and Syntax.
                                        if (AStarGreedyi == 1)
                                        {
                                            //Found of Max Non Probable Movments.
                                            Founded.Clear();
                                            int LessB = Int32.MinValue;
                                            BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                            RW1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                            CL1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                            Ki1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                            if (Founded[0] != MaxSoldeirFounded)
                                                continue;
                                            Act = true;
                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRowQ = SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].Row;
                                                AllDraw.LastColumnQ = SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].Column;
                                                AllDraw.NextRowQ = SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][0];
                                                AllDraw.NextColumnQ = SolderesOnTable[i].SoldierThinkingQuantum[k].RowColumnSoldier[j][1];
                                            }
                                            Less = SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].ReturnHeuristic(RW1, Ki1, Order, false, ref HaveKilled);

                                            TableHeuristic = SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].TableListSolder[Ki1];

                                            Object O1 = new Object();
                                            lock (O1)
                                            {
                                                ThingsConverter.ActOfClickEqualTow = true;
                                            }
                                            SolderesOnTable[RW1].ConvertOperation(SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][1], a, SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].TableListSolder[Ki1], Order, false, i);
                                            int Sign = 1;
                                            if (a == Color.Brown)
                                                Sign = -1;
                                            //If there is Soldier Convert.
                                            if (SolderesOnTable[RW1].Convert)
                                            {
                                                if (SolderesOnTable[RW1].ConvertedToMinister)
                                                    TableHeuristic[SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][1]] = 5 * Sign;
                                                else if (SolderesOnTable[RW1].ConvertedToCastle)
                                                    TableHeuristic[SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][1]] = 4 * Sign;
                                                else if (SolderesOnTable[RW1].ConvertedToHourse)
                                                    TableHeuristic[SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][1]] = 3 * Sign;
                                                else if (SolderesOnTable[RW1].ConvertedToElefant)
                                                    TableHeuristic[SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinkingQuantum[CL1].RowColumnSoldier[Ki1][1]] = 2 * Sign;
                                            }
                                            Object OO = new Object();
                                            lock (OO)
                                            {
                                                if (Order == 1)
                                                {
                                                }
                                                else//If Order is Brown.
                                                {
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                //Do For Remaining Objects same as Soldeir Documentation.
                for (i = ElefantMidle; i < ElefantHigh; i++)
                {
                    for (int k = 0; k < AllDraw.ElefantMovments; k++)
                        for (j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum[k] != null && ElephantOnTable[i].ElefantThinkingQuantum[k] != null && j < ElephantOnTable[i].ElefantThinkingQuantum[k].TableListElefant.Count; j++)
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                            //   if (ElephantOnTable[i].ElefantThinkingQuantum[k].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)

                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < ElephantOnTable[i].ElefantThinkingQuantum[k].AStarGreedy.Count - 1; ij++)
                                    ElephantOnTable[i].ElefantThinkingQuantum[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, ElephantOnTable[i].ElefantThinkingQuantum[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }

                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if ((ElephantOnTable[i].ElefantThinkingQuantum[k].PenaltyRegardListElefant[j].IsPenaltyAction() != 0 && ElephantOnTable[i].ElefantThinkingQuantum[k].PenaltyRegardListElefant[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {
                                Object On = new Object();
                                lock (On)
                                {
                                    AllDraw.LastRowQ = ElephantOnTable[i].ElefantThinkingQuantum[k].Row;
                                    AllDraw.LastColumnQ = ElephantOnTable[i].ElefantThinkingQuantum[k].Column;
                                    AllDraw.NextRowQ = ElephantOnTable[i].ElefantThinkingQuantum[k].RowColumnElefant[j][0];
                                    AllDraw.NextColumnQ = ElephantOnTable[i].ElefantThinkingQuantum[k].RowColumnElefant[j][1];

                                    Act = true;
                                    Less = ElephantOnTable[i].ElefantThinkingQuantum[k].NumberOfPenalties;
                                }
                                TableHeuristic = ElephantOnTable[i].ElefantThinkingQuantum[k].TableListElefant[j];
                                RegardOccurred = true;
                                //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))

                                continue;
                            }
                            //When There is No Movments in Such Order Enemy continue.
                            if (ElephantOnTable[i].ElefantThinkingQuantum[k].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)
                                continue;
                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (ElephantOnTable[i].ElefantThinkingQuantum[0].NumberOfPenalties < Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                if (ElephantOnTable[i].ElefantThinkingQuantum[0].NumberOfPenalties < Less)
                                {
                                    //retrive table of current Heuristic.
                                    //if (CheckG || CheckB)
                                    //{
                                    //retrive table of current Heuristic.
                                    int[,] TableS = ElephantOnTable[i].ElefantThinkingQuantum[k].TableListElefant[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                    {
                                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                            continue;
                                    }
                                    //When there is not Penalty regard mechanism.
                                    //if (!UsePenaltyRegardMechnisamT)
                                    {
                                        AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 2, CloneATable(TableS), Order, ElephantOnTable[i].ElefantThinkingQuantum[k].Row, ElephantOnTable[i].ElefantThinkingQuantum[k].Column);
                                        //If there is kish or kshachamaz Order.
                                        if (AB.Check(CloneATable(TableS), Order))
                                        {
                                            //When Order is Gray.
                                            if (Order == 1)
                                            {
                                                //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                if (AB.CheckGray)
                                                    continue;
                                            }
                                            else
                                            {
                                                //Continue when CheckBrown and AStarGreadyFirstSearch.
                                                if (AB.CheckBrown)
                                                    continue;
                                            }
                                        }
                                        else
                                        {
                                        }
                                    }
                                    RW2 = i;
                                    CL2 = k;
                                    Ki2 = j;
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess2 = (ElephantOnTable[RW2].ElefantThinkingQuantum[CL2].NumberOfPenalties);
                                    MaxLess1 = -1;
                                    if (MaxLess2 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess2 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess2 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (MaxLess2 > MaxLess6)
                                        MaxLess6 = -1;
                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                            }
                                            else//If Order is Brown.
                                            {
                                            }
                                        }
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRowQ = ElephantOnTable[i].ElefantThinkingQuantum[k].Row;
                                            AllDraw.LastColumnQ = ElephantOnTable[i].ElefantThinkingQuantum[k].Column;
                                            AllDraw.NextRowQ = ElephantOnTable[i].ElefantThinkingQuantum[k].RowColumnElefant[j][0];
                                            AllDraw.NextColumnQ = ElephantOnTable[i].ElefantThinkingQuantum[k].RowColumnElefant[j][1];
                                        }
                                        Act = true;
                                        Less = ElephantOnTable[i].ElefantThinkingQuantum[k].NumberOfPenalties;
                                        TableHeuristic = ElephantOnTable[i].ElefantThinkingQuantum[k].TableListElefant[j];
                                    }
                                }
                                else//Set Table and Heuristic Value and Syntax.
                                {
                                    if (AStarGreedyi == 1)
                                    {
                                        //Found of Max Non Probable Movments.
                                        Founded.Clear();
                                        int LessB = Int32.MinValue;
                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                        RW2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                        CL2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                        Ki2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                        if (Founded[0] != MaxElephntFounded)
                                            continue;
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRowQ = ElephantOnTable[RW2].ElefantThinkingQuantum[CL2].Row;
                                            AllDraw.LastColumnQ = ElephantOnTable[RW2].ElefantThinkingQuantum[CL2].Column;
                                            AllDraw.NextRowQ = ElephantOnTable[i].ElefantThinkingQuantum[k].RowColumnElefant[j][0];
                                            AllDraw.NextColumnQ = ElephantOnTable[i].ElefantThinkingQuantum[k].RowColumnElefant[j][1];
                                        }
                                        Act = true;
                                        Less = ElephantOnTable[RW2].ElefantThinkingQuantum[CL2].ReturnHeuristic(RW2, Ki2, Order, false, ref HaveKilled);
                                        TableHeuristic = ElephantOnTable[RW2].ElefantThinkingQuantum[CL2].TableListElefant[Ki2];
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                            }
                                            else//If Order is Brown.
                                            {
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                for (i = HourseMidle; i < HourseHight; i++)
                {
                    for (int k = 0; k < AllDraw.HourseMovments; k++)
                        for (j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum[k] != null && HoursesOnTable[i].HourseThinkingQuantum[k] != null && j < HoursesOnTable[i].HourseThinkingQuantum[k].TableListHourse.Count; j++)
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                            //    if (HoursesOnTable[i].HourseThinkingQuantum[k].PenaltyRegardListHourse[j].IsPenaltyAction() == 0)

                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < HoursesOnTable[i].HourseThinkingQuantum[k].AStarGreedy.Count - 1; ij++)
                                    HoursesOnTable[i].HourseThinkingQuantum[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, HoursesOnTable[i].HourseThinkingQuantum[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }

                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if ((HoursesOnTable[i].HourseThinkingQuantum[k].PenaltyRegardListHourse[j].IsPenaltyAction() != 0 && HoursesOnTable[i].HourseThinkingQuantum[k].PenaltyRegardListHourse[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {
                                Object On = new Object();
                                lock (On)
                                {
                                    AllDraw.LastRowQ = HoursesOnTable[i].HourseThinkingQuantum[k].Row;
                                    AllDraw.LastColumnQ = HoursesOnTable[i].HourseThinkingQuantum[k].Column;
                                    AllDraw.NextRowQ = HoursesOnTable[i].HourseThinkingQuantum[k].RowColumnHourse[j][0];
                                    AllDraw.NextColumnQ = HoursesOnTable[i].HourseThinkingQuantum[k].RowColumnHourse[j][1];

                                    Act = true;
                                    Less = HoursesOnTable[i].HourseThinkingQuantum[k].NumberOfPenalties;
                                }
                                TableHeuristic = HoursesOnTable[i].HourseThinkingQuantum[k].TableListHourse[j];
                                RegardOccurred = true;
                                //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))

                                continue;
                            }
                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (HoursesOnTable[i].HourseThinkingQuantum[0].NumberOfPenalties < Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                if (HoursesOnTable[i].HourseThinkingQuantum[0].NumberOfPenalties < Less)
                                {
                                    //retrive table of current Heuristic.
                                    //retrive table of current Heuristic.
                                    int[,] TableS = HoursesOnTable[i].HourseThinkingQuantum[k].TableListHourse[j];
                                    {
                                        //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                        if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                        {
                                            if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                continue;
                                        }
                                        //When there is not Penalty regard mechanism.
                                        //if (!UsePenaltyRegardMechnisamT)
                                        {
                                            AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 3, CloneATable(TableS), Order, HoursesOnTable[i].HourseThinkingQuantum[k].Row, HoursesOnTable[i].HourseThinkingQuantum[k].Column);
                                            //If there is kish or kshachamaz Order.
                                            if (AB.Check(CloneATable(TableS), Order))
                                            {
                                                //When Order is Gray.
                                                if (Order == 1)
                                                {
                                                    //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                    if (AB.CheckGray)
                                                        continue;
                                                }
                                                else
                                                {
                                                    //Continue when CheckBrown and AStarGreadyFirstSearch.
                                                    if (AB.CheckBrown)
                                                        continue;
                                                }
                                            }
                                            else
                                            {
                                            }
                                        }
                                    }
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = i;
                                    CL3 = k;
                                    Ki3 = j;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess3 = HoursesOnTable[RW3].HourseThinkingQuantum[CL3].NumberOfPenalties;
                                    if (MaxLess3 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess3 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess3 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess3 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (MaxLess3 > MaxLess6)
                                        MaxLess6 = -1;
                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                            }
                                            else//If Order is Brown.
                                            {
                                            }
                                        }
                                        //Set Table and Heuristic Value and Syntax.
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRowQ = HoursesOnTable[i].HourseThinkingQuantum[k].Row;
                                            AllDraw.LastColumnQ = HoursesOnTable[i].HourseThinkingQuantum[k].Column;
                                            AllDraw.NextRowQ = HoursesOnTable[i].HourseThinkingQuantum[k].RowColumnHourse[j][0];
                                            AllDraw.NextColumnQ = HoursesOnTable[i].HourseThinkingQuantum[k].RowColumnHourse[j][1];
                                        }
                                        Act = true;
                                        Less = HoursesOnTable[i].HourseThinkingQuantum[k].NumberOfPenalties;
                                        TableHeuristic = HoursesOnTable[i].HourseThinkingQuantum[k].TableListHourse[j];
                                    }
                                }
                                else//Set Table and Heuristic Value and Syntax.
                                {
                                    if (AStarGreedyi == 1)
                                    {
                                        //Found of Max Non Probable Movments.
                                        Founded.Clear();
                                        int LessB = Int32.MinValue;
                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                        RW3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                        CL3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                        Ki3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                        if (Founded[0] != MaxHourseFounded)
                                            continue;
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRowQ = HoursesOnTable[RW3].HourseThinkingQuantum[CL3].Row;
                                            AllDraw.LastColumnQ = HoursesOnTable[RW3].HourseThinkingQuantum[CL3].Column;
                                            AllDraw.NextRowQ = HoursesOnTable[i].HourseThinkingQuantum[k].RowColumnHourse[j][0];
                                            AllDraw.NextColumnQ = HoursesOnTable[i].HourseThinkingQuantum[k].RowColumnHourse[j][1];
                                        }
                                        Act = true;
                                        Less = HoursesOnTable[RW3].HourseThinkingQuantum[CL3].ReturnHeuristic(RW3, Ki3, Order, false, ref HaveKilled);
                                        TableHeuristic = HoursesOnTable[RW3].HourseThinkingQuantum[CL3].TableListHourse[Ki3];
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                            }
                                            else//If Order is Brown.
                                            {
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                for (i = CastleMidle; i < CastleHigh; i++)
                {
                    for (int k = 0; k < AllDraw.CastleMovments; k++)
                        for (j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum[k] != null && CastlesOnTable[i].CastleThinkingQuantum[k] != null && j < CastlesOnTable[i].CastleThinkingQuantum[k].TableListCastle.Count; j++)
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                            ///   if (CastlesOnTable[i].CastleThinkingQuantum[k].PenaltyRegardListCastle[j].IsPenaltyAction() == 0)

                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < CastlesOnTable[i].CastleThinkingQuantum[k].AStarGreedy.Count - 1; ij++)
                                    CastlesOnTable[i].CastleThinkingQuantum[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, CastlesOnTable[i].CastleThinkingQuantum[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }

                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if ((CastlesOnTable[i].CastleThinkingQuantum[k].PenaltyRegardListCastle[j].IsPenaltyAction() != 0 && CastlesOnTable[i].CastleThinkingQuantum[k].PenaltyRegardListCastle[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {
                                Object On = new Object();
                                lock (On)
                                {
                                    AllDraw.LastRowQ = CastlesOnTable[i].CastleThinkingQuantum[k].Row;
                                    AllDraw.LastColumnQ = CastlesOnTable[i].CastleThinkingQuantum[k].Column;
                                    AllDraw.NextRowQ = CastlesOnTable[i].CastleThinkingQuantum[k].RowColumnCastle[j][0];
                                    AllDraw.NextColumnQ = CastlesOnTable[i].CastleThinkingQuantum[k].RowColumnCastle[j][1];
                                    Act = true;
                                    Less = CastlesOnTable[i].CastleThinkingQuantum[k].NumberOfPenalties;
                                }
                                TableHeuristic = CastlesOnTable[i].CastleThinkingQuantum[k].TableListCastle[j];
                                RegardOccurred = true;
                                //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))

                                continue;
                            }
                            Object ol = new Object();
                            lock (ol)
                            {
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (CastlesOnTable[i].CastleThinkingQuantum[0].NumberOfPenalties < Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                if (CastlesOnTable[i].CastleThinkingQuantum[0].NumberOfPenalties < Less)
                                {
                                    //retrive table of current Heuristic.
                                    //retrive table of current Heuristic.
                                    int[,] TableS = CastlesOnTable[i].CastleThinkingQuantum[k].TableListCastle[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                    {
                                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                            continue;
                                    }
                                    //When there is not Penalty regard mechanism.
                                    //if (!UsePenaltyRegardMechnisamT)
                                    {
                                        AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 4, CloneATable(TableS), Order, CastlesOnTable[i].CastleThinkingQuantum[k].Row, CastlesOnTable[i].CastleThinkingQuantum[k].Column);
                                        //If there is kish or kshachamaz Order.
                                        if (AB.Check(CloneATable(TableS), Order))
                                        {
                                            //When Order is Gray.
                                            if (Order == 1)
                                            {
                                                //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                if (AB.CheckGray)
                                                    continue;
                                            }
                                            else
                                            {
                                                //Continue when CheckBrown and AStarGreadyFirstSearch.
                                                if (AB.CheckBrown)
                                                    continue;
                                            }
                                        }
                                        else
                                        {
                                        }
                                    }
                                    RW4 = i;
                                    CL4 = k;
                                    Ki4 = j;
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess4 = (CastlesOnTable[RW4].CastleThinkingQuantum[CL4].NumberOfPenalties);
                                    if (MaxLess4 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess4 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess4 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess4 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (MaxLess4 > MaxLess6)
                                        MaxLess6 = -1;
                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                            }
                                            else//If Order is Brown.
                                            {
                                            }
                                        }
                                        //Set Table and Heuristic Value and Syntax.
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRowQ = CastlesOnTable[i].CastleThinkingQuantum[k].Row;
                                            AllDraw.LastColumnQ = CastlesOnTable[i].CastleThinkingQuantum[k].Column;
                                            AllDraw.NextRowQ = CastlesOnTable[i].CastleThinkingQuantum[k].RowColumnCastle[j][0];
                                            AllDraw.NextColumnQ = CastlesOnTable[i].CastleThinkingQuantum[k].RowColumnCastle[j][1];
                                        }
                                        Act = true;
                                        Less = CastlesOnTable[i].CastleThinkingQuantum[k].NumberOfPenalties;
                                        TableHeuristic = CastlesOnTable[i].CastleThinkingQuantum[k].TableListCastle[j];
                                    }
                                }
                                else//Set Table and Heuristic Value and Syntax.
                                {
                                    if (AStarGreedyi == 1)
                                    {
                                        //Found of Max Non Probable Movments.
                                        Founded.Clear();
                                        int LessB = Int32.MinValue;
                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                        RW4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                        CL4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                        Ki4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                        if (Founded[0] != MaxCastlesFounded)
                                            continue;
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRowQ = CastlesOnTable[RW4].CastleThinkingQuantum[CL4].Row;
                                            AllDraw.LastColumnQ = CastlesOnTable[RW4].CastleThinkingQuantum[CL4].Column;
                                            AllDraw.NextRowQ = CastlesOnTable[i].CastleThinkingQuantum[k].RowColumnCastle[j][0];
                                            AllDraw.NextColumnQ = CastlesOnTable[i].CastleThinkingQuantum[k].RowColumnCastle[j][1];
                                        }
                                        Act = true;
                                        Less = CastlesOnTable[RW4].CastleThinkingQuantum[CL4].ReturnHeuristic(RW4, Ki4, Order, false, ref HaveKilled);
                                        TableHeuristic = CastlesOnTable[RW4].CastleThinkingQuantum[CL4].TableListCastle[Ki4];
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                            }
                                            else//If Order is Brown.
                                            {
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }

                for (i = MinisterMidle; i < MinisterHigh; i++)
                {
                    for (int k = 0; k < AllDraw.MinisterMovments; k++)
                        for (j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum[k] != null && MinisterOnTable[i].MinisterThinkingQuantum[k] != null && j < MinisterOnTable[i].MinisterThinkingQuantum[k].TableListMinister.Count; j++)
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < MinisterOnTable[i].MinisterThinkingQuantum[k].AStarGreedy.Count - 1; ij++)
                                    MinisterOnTable[i].MinisterThinkingQuantum[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, MinisterOnTable[i].MinisterThinkingQuantum[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }

                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            if ((MinisterOnTable[i].MinisterThinkingQuantum[k].PenaltyRegardListMinister[j].IsPenaltyAction() != 0 && MinisterOnTable[i].MinisterThinkingQuantum[k].PenaltyRegardListMinister[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {
                                Object On = new Object();
                                lock (On)
                                {
                                    AllDraw.LastRowQ = MinisterOnTable[i].MinisterThinkingQuantum[k].Row;
                                    AllDraw.LastColumnQ = MinisterOnTable[i].MinisterThinkingQuantum[k].Column;
                                    AllDraw.NextRowQ = MinisterOnTable[i].MinisterThinkingQuantum[k].RowColumnMinister[j][0];
                                    AllDraw.NextColumnQ = MinisterOnTable[i].MinisterThinkingQuantum[k].RowColumnMinister[j][1];

                                    Act = true;
                                    Less = MinisterOnTable[i].MinisterThinkingQuantum[k].NumberOfPenalties;
                                }
                                TableHeuristic = MinisterOnTable[i].MinisterThinkingQuantum[k].TableListMinister[j];
                                RegardOccurred = true;
                                continue;
                            }
                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (MinisterOnTable[i].MinisterThinkingQuantum[0].NumberOfPenalties < Less)
                                        continue;

                                //When There is greater Heuristic Movments.
                                if (MinisterOnTable[i].MinisterThinkingQuantum[0].NumberOfPenalties < Less)
                                //retrive table of current Heuristic.
                                {
                                    //retrive table of current Heuristic.
                                    int[,] TableS = MinisterOnTable[i].MinisterThinkingQuantum[k].TableListMinister[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                    {
                                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                            continue;
                                    }
                                    //When there is not Penalty regard mechanism.
                                    AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 5, CloneATable(TableS), Order, MinisterOnTable[i].MinisterThinkingQuantum[k].Row, MinisterOnTable[i].MinisterThinkingQuantum[k].Column);
                                    //If there is kish or kshachamaz Order.
                                    if (AB.Check(CloneATable(TableS), Order))
                                    {
                                        //When Order is Gray.
                                        if (Order == 1)
                                        {
                                            //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                            if (AB.CheckGray)
                                                continue;
                                        }
                                        else
                                        {
                                            //Continue when CheckBrown and AStarGreadyFirstSearch.
                                            if (AB.CheckBrown)
                                                continue;
                                        }
                                    }
                                    RW5 = i;
                                    CL5 = k;
                                    Ki5 = j;
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess5 = (MinisterOnTable[RW5].MinisterThinkingQuantum[CL5].NumberOfPenalties);
                                    if (MaxLess5 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess5 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess5 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess5 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess5 > MaxLess6)
                                        MaxLess6 = -1;
                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                            }
                                            else//If Order is Brown.
                                            {
                                            }
                                        }
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRowQ = MinisterOnTable[i].MinisterThinkingQuantum[k].Row;
                                            AllDraw.LastColumnQ = MinisterOnTable[i].MinisterThinkingQuantum[k].Column;
                                            AllDraw.NextRowQ = MinisterOnTable[i].MinisterThinkingQuantum[k].RowColumnMinister[j][0];
                                            AllDraw.NextColumnQ = MinisterOnTable[i].MinisterThinkingQuantum[k].RowColumnMinister[j][1];
                                        }
                                        Act = true;
                                        Less = MinisterOnTable[i].MinisterThinkingQuantum[k].NumberOfPenalties;
                                        TableHeuristic = MinisterOnTable[i].MinisterThinkingQuantum[k].TableListMinister[j];
                                    }
                                }
                                else//Set Table and Heuristic Value and Syntax.
                                {
                                    if (AStarGreedyi == 1)
                                    {
                                        //Found of Max Non Probable Movments.
                                        Founded.Clear();
                                        int LessB = Int32.MinValue;
                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                        RW5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                        CL5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                        Ki5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                        if (Founded[0] != MaxMinisterFounded)
                                            continue;
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRowQ = MinisterOnTable[RW5].MinisterThinkingQuantum[CL5].Row;
                                            AllDraw.LastColumnQ = MinisterOnTable[RW5].MinisterThinkingQuantum[CL5].Column;
                                            AllDraw.NextRowQ = MinisterOnTable[i].MinisterThinkingQuantum[k].RowColumnMinister[j][0];
                                            AllDraw.NextColumnQ = MinisterOnTable[i].MinisterThinkingQuantum[k].RowColumnMinister[j][1];
                                        }
                                        Act = true;
                                        Less = MinisterOnTable[RW5].MinisterThinkingQuantum[CL5].ReturnHeuristic(RW5, Ki5, Order, false, ref HaveKilled);
                                        TableHeuristic = MinisterOnTable[RW5].MinisterThinkingQuantum[CL5].TableListMinister[Ki5];
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                            }
                                            else//If Order is Brown.
                                            {
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                for (i = KingMidle; i < KingHigh; i++)
                {
                    for (int k = 0; k < AllDraw.KingMovments; k++)
                        for (j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum[k] != null && KingOnTable[i].KingThinkingQuantum[k] != null && j < KingOnTable[i].KingThinkingQuantum[k].TableListKing.Count; j++)
                        {
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < KingOnTable[i].KingThinkingQuantum[k].AStarGreedy.Count - 1; ij++)
                                    KingOnTable[i].KingThinkingQuantum[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, KingOnTable[i].KingThinkingQuantum[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }

                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            if ((KingOnTable[i].KingThinkingQuantum[k].PenaltyRegardListKing[j].IsPenaltyAction() != 0 && KingOnTable[i].KingThinkingQuantum[k].PenaltyRegardListKing[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {
                                Object On = new Object();
                                lock (On)
                                {
                                    AllDraw.LastRowQ = KingOnTable[i].KingThinkingQuantum[k].Row;
                                    AllDraw.LastColumnQ = KingOnTable[i].KingThinkingQuantum[k].Column;
                                    AllDraw.NextRowQ = KingOnTable[i].KingThinkingQuantum[k].RowColumnKing[j][0];
                                    AllDraw.NextColumnQ = KingOnTable[i].KingThinkingQuantum[k].RowColumnKing[j][1];

                                    Act = true;
                                    Less = KingOnTable[i].KingThinkingQuantum[k].NumberOfPenalties;
                                }
                                TableHeuristic = KingOnTable[i].KingThinkingQuantum[k].TableListKing[j];
                                RegardOccurred = true;
                                continue;
                            }
                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (KingOnTable[i].KingThinkingQuantum[0].NumberOfPenalties < Less)
                                        continue;

                                //When There is greater Heuristic Movments.
                                if (KingOnTable[i].KingThinkingQuantum[0].NumberOfPenalties < Less)
                                //retrive table of current Heuristic.
                                {
                                    //retrive table of current Heuristic.
                                    int[,] TableS = KingOnTable[i].KingThinkingQuantum[k].TableListKing[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                    {
                                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                            continue;
                                    }
                                    //When there is not Penalty regard mechanism.
                                    AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 6, CloneATable(TableS), Order, KingOnTable[i].KingThinkingQuantum[k].Row, KingOnTable[i].KingThinkingQuantum[k].Column);
                                    //If there is kish or kshachamaz Order.
                                    if (AB.Check(CloneATable(TableS), Order))
                                    {
                                        //When Order is Gray.
                                        if (Order == 1)
                                        {
                                            //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                            if (AB.CheckGray)
                                                continue;
                                        }
                                        else
                                        {
                                            //Continue when CheckBrown and AStarGreadyFirstSearch.
                                            if (AB.CheckBrown)
                                                continue;
                                        }
                                    }

                                    RW6 = i;
                                    CL6 = k;
                                    Ki6 = j;
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    MaxLess6 = (KingOnTable[RW6].KingThinkingQuantum[CL6].NumberOfPenalties);
                                    if (MaxLess6 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess6 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess6 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess6 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess6 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                            }
                                            else//If Order is Brown.
                                            {
                                            }
                                        }
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRowQ = KingOnTable[i].KingThinkingQuantum[k].Row;
                                            AllDraw.LastColumnQ = KingOnTable[i].KingThinkingQuantum[k].Column;
                                            AllDraw.NextRowQ = KingOnTable[i].KingThinkingQuantum[k].RowColumnKing[j][0];
                                            AllDraw.NextColumnQ = KingOnTable[i].KingThinkingQuantum[k].RowColumnKing[j][1];
                                        }
                                        Act = true;
                                        Less = KingOnTable[i].KingThinkingQuantum[k].NumberOfPenalties;
                                        TableHeuristic = KingOnTable[i].KingThinkingQuantum[k].TableListKing[j];
                                    }
                                }
                                else//Set Table and Heuristic Value and Syntax.
                                {
                                    if (AStarGreedyi == 1)
                                    {
                                        //Found of Max Non Probable Movments.
                                        Founded.Clear();
                                        int LessB = Int32.MinValue;
                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                        if (Founded[0] != 1)
                                            continue;
                                        RW6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                        CL6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                        Ki6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                        if (Founded[0] != MaxKingFounded)
                                            continue;
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRowQ = KingOnTable[RW6].KingThinkingQuantum[CL6].Row;
                                            AllDraw.LastColumnQ = KingOnTable[RW6].KingThinkingQuantum[CL6].Column;
                                            AllDraw.NextRowQ = KingOnTable[i].KingThinkingQuantum[k].RowColumnKing[j][0];
                                            AllDraw.NextColumnQ = KingOnTable[i].KingThinkingQuantum[k].RowColumnKing[j][1];
                                        }
                                        Act = true;
                                        Less = KingOnTable[RW6].KingThinkingQuantum[CL6].ReturnHeuristic(RW6, Ki6, Order, false, ref HaveKilled);
                                        TableHeuristic = KingOnTable[RW6].KingThinkingQuantum[CL6].TableListKing[Ki6];
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {
                                            }
                                            else//If Order is Brown.
                                            {
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }

                return TableHeuristic;
            }
        }
        //AStarGreedy First Heuristic Method.
      */

        public int[,] HeuristicAStarGreedySearch(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic)
        {
            object O = new object();
            lock (O)
            {
                int[,] TableHeuristic = new int[8, 8];
                AStarGreedyi++;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                //Initiate For Dynamic Backward Current AStarGreedyi Non Minus Founded Max Movments Detection Global Variables.
                List<int> Founded = new List<int>();
                //Initiateing Indicating Heuristic Multiple Same Value Best Found of Movments.
                MaxLess1 = -1;
                MaxLess2 = -1;
                MaxLess3 = -1;
                MaxLess4 = -1;
                MaxLess5 = -1;
                MaxLess6 = -1;
                RW1 = -1;
                CL1 = -1;
                Ki1 = -1;
                RW2 = -1;
                CL2 = -1;
                Ki2 = -1;
                RW3 = -1;
                CL3 = -1;
                Ki3 = -1;
                RW4 = -1;
                CL4 = -1;
                Ki4 = -1;
                RW5 = -1;
                CL5 = -1;
                Ki5 = -1;
                RW6 = -1;
                CL6 = -1;
                Ki6 = -1;
                double[] BacWard = new double[25];
                object Omm = new object();
                lock (Omm)
                {
                    //if (AStarGreedyi > MaxAStarGreedy)
                    //return TableHeuristic;
                }
                bool Act = false;
                if (Order == 1)
                {
                    bool Ac = Act;
                    int[,] Ta = TableHeuristic;
                    Task<int[,]> ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchGray(AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah.Wait();
                    ah.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                else
                {
                    bool Ac = Act;
                    int[,] Ta = TableHeuristic;
                    Task<int[,]> ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchBrown(AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah.Wait();
                    ah.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //Store In Local Variable and Dynamic Purpose Proccessing.
                //Every Non Minuse Non Idept in List Has Gretest Max Order.
                //Is Desired of Idept Oner Best Movments.
                BacWard[0] = AStarGreedyi;
                BacWard[1] = MaxLess1;
                BacWard[2] = RW1;
                BacWard[3] = RW1;
                BacWard[4] = Ki1;

                BacWard[5] = MaxLess2;
                BacWard[6] = RW2;
                BacWard[7] = RW2;
                BacWard[8] = Ki2;
                BacWard[9] = MaxLess3;
                BacWard[10] = RW3;
                BacWard[11] = RW3;
                BacWard[12] = Ki3;
                BacWard[13] = MaxLess4;
                BacWard[14] = RW4;
                BacWard[15] = RW4;
                BacWard[16] = Ki4;
                BacWard[17] = MaxLess5;
                BacWard[18] = RW5;
                BacWard[19] = RW5;
                BacWard[20] = Ki5;
                BacWard[21] = MaxLess6;
                BacWard[22] = RW6;
                BacWard[23] = RW6;
                BacWard[24] = Ki6;
                //We Have Information of Maximum of Heuristic in Each Level and Table.
                MaxHeuristicAStarGreedytBackWard.Add(BacWard);
                MaxHeuristicAStarGreedytBackWardTable.Add(TableHeuristic);
                Founded.Clear();
                //If Found retrun table.
                if (Act)
                {
                    return TableHeuristic;
                }
                //Return what found table.

                return TableHeuristic;
            }
        }

        /*    public int[,] HeuristicAStarGreedySearchPenalties(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic)
            {
                Object O = new Object();
                lock (O)
                {
                    int[,] TableHeuristic = new int[8, 8];
                    AStarGreedyi++;
                    int DummyOrder = Order;
                    int DummyCurrentOrder = ChessRules.CurrentOrder;
                    //Initiate For Dynamic Backward Current AStarGreedyi Non Minus Founded Max Movments Detection Global Variables.
                    List<int> Founded = new List<int>();
                    //Initiateing Indicating Heuristic Multiple Same Value Best Found of Movments.
                    MaxLess1 = -1;
                    MaxLess2 = -1;
                    MaxLess3 = -1;
                    MaxLess4 = -1;
                    MaxLess5 = -1;
                    MaxLess6 = -1;
                    RW1 = -1;
                    CL1 = -1;
                    Ki1 = -1;
                    RW2 = -1;
                    CL2 = -1;
                    Ki2 = -1;
                    RW3 = -1;
                    CL3 = -1;
                    Ki3 = -1;
                    RW4 = -1;
                    CL4 = -1;
                    Ki4 = -1;
                    RW5 = -1;
                    CL5 = -1;
                    Ki5 = -1;
                    RW6 = -1;
                    CL6 = -1;
                    Ki6 = -1;
                    int[] BacWard = new int[25];
                    Object Omm = new Object();
                    lock (Omm)
                    {
                        if (AStarGreedyi > MaxAStarGreedy)
                            return TableHeuristic;
                    }
                    bool Act = false;
                    if (Order == 1)
                    {
                        TableHeuristic = HeuristicAStarGreadySearchPenalties(AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                    }
                    else
                    {
                        TableHeuristic = BrownHeuristicAStarGreaedySearchPenalites(AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                    }
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //Store In Local Variable and Dynamic Purpose Proccessing.
                    //Every Non Minuse Non Idept in List Has Gretest Max Order.
                    //Is Desired of Idept Oner Best Movments.
                    BacWard[0] = AStarGreedyi;
                    BacWard[1] = MaxLess1;
                    BacWard[2] = RW1;
                    BacWard[3] = RW1;
                    BacWard[4] = Ki1;

                    BacWard[5] = MaxLess2;
                    BacWard[6] = RW2;
                    BacWard[7] = RW2;
                    BacWard[8] = Ki2;
                    BacWard[9] = MaxLess3;
                    BacWard[10] = RW3;
                    BacWard[11] = RW3;
                    BacWard[12] = Ki3;
                    BacWard[13] = MaxLess4;
                    BacWard[14] = RW4;
                    BacWard[15] = RW4;
                    BacWard[16] = Ki4;
                    BacWard[17] = MaxLess5;
                    BacWard[18] = RW5;
                    BacWard[19] = RW5;
                    BacWard[20] = Ki5;
                    BacWard[21] = MaxLess6;
                    BacWard[22] = RW6;
                    BacWard[23] = RW6;
                    BacWard[24] = Ki6;
                    //We Have Information of Maximum of Heuristic in Each Level and Table.
                    MaxHeuristicAStarGreedytBackWard.Add(BacWard);
                    MaxHeuristicAStarGreedytBackWardTable.Add(TableHeuristic);
                    Founded.Clear();

                    //If Found retrun table.
                    if (Act)
                        return TableHeuristic;
                    //Return what found table.
                    return TableHeuristic;
                }
            }
            //Genethic Algorithm Game Method.
        */

        private bool ServeBoundryConditions(int i, int Kind, int Order)
        {
            bool Is = false;
            try
            {
                if (Kind == 1)
                {
                    Is = Is || ServeBoundryConditionsSoldier(i, Kind, Order);
                }
                else
                if (Kind == 2)
                {
                    Is = Is || ServeBoundryConditionsElephant(i, Kind, Order);
                }
                else
                if (Kind == 3)
                {
                    Is = Is || ServeBoundryConditionsHourse(i, Kind, Order);
                }
                else
                if (Kind == 4)
                {
                    Is = Is || ServeBoundryConditionsCastle(i, Kind, Order);
                }
                else
                if (Kind == 5)
                {
                    Is = Is || ServeBoundryConditionsMinister(i, Kind, Order);
                }
                else
                if (Kind == 6)
                {
                    Is = Is || ServeBoundryConditionsKing(i, Kind, Order);
                }
                else
                if (Kind == 7 || Kind == -7)
                {
                    Is = Is || ServeBoundryConditionsCasttling(i, Kind, Order);
                }
            }
            catch (Exception t)
            {
                Log(t);
                Is = true;
            }
            return Is;
        }

        private bool ServeBoundryConditionsSoldier(int i, int Kind, int Order)
        {
            if (Order == 1 && i >= SodierMidle)
            {
                return true;
            }

            if (Order == -1 && i >= SodierHigh)
            {
                return true;
            }

            if (SolderesOnTable == null)
            {
                return true;
            }

            if (SolderesOnTable[i] == null)
            {
                return true;
            }

            return false;
        }

        private bool ServeBoundryConditionsElephant(int i, int Kind, int Order)
        {
            if (Order == 1 && i >= ElefantHigh)
            {
                return true;
            }

            if (Order == -1 && i >= ElefantHigh)
            {
                return true;
            }

            if (ElephantOnTable == null)
            {
                return true;
            }

            if (ElephantOnTable[i] == null)
            {
                return true;
            }

            return false;
        }

        private bool ServeBoundryConditionsHourse(int i, int Kind, int Order)
        {
            if (Order == 1 && i >= HourseMidle)
            {
                return true;
            }

            if (Order == -1 && i >= HourseHight)
            {
                return true;
            }

            if (HoursesOnTable == null)
            {
                return true;
            }

            if (HoursesOnTable[i] == null)
            {
                return true;
            }

            return false;
        }

        private bool ServeBoundryConditionsCastle(int i, int Kind, int Order)
        {
            if (Order == 1 && i >= CastleMidle)
            {
                return true;
            }

            if (Order == -1 && i >= CastleHigh)
            {
                return true;
            }

            if (CastlesOnTable == null)
            {
                return true;
            }

            if (CastlesOnTable[i] == null)
            {
                return true;
            }

            return false;
        }

        private bool ServeBoundryConditionsMinister(int i, int Kind, int Order)
        {
            if (Order == 1 && i >= MinisterMidle)
            {
                return true;
            }

            if (Order == -1 && i >= MinisterHigh)
            {
                return true;
            }

            if (MinisterOnTable == null)
            {
                return true;
            }

            if (MinisterOnTable[i] == null)
            {
                return true;
            }

            return false;
        }

        private bool ServeBoundryConditionsKing(int i, int Kind, int Order)
        {
            if (Order == 1 && i >= KingMidle)
            {
                return true;
            }

            if (Order == -1 && i >= KingHigh)
            {
                return true;
            }

            if (KingOnTable == null)
            {
                return true;
            }

            if (KingOnTable[i] == null)
            {
                return true;
            }

            return false;
        }

        private bool ServeBoundryConditionsCasttling(int i, int Kind, int Order)
        {
            if (Order == 1 && i > 0)
            {
                return true;
            }

            if (Order == -1 && i > 0)
            {
                return true;
            }

            if (CastlingOnTable == null)
            {
                return true;
            }

            if (CastlingOnTable[i] == null)
            {
                return true;
            }

            return false;
        }

        //support of objects by self object regard by values named served
        private void Serve(int Order)
        {
            //Gray
            if (Order == 1)
            {
                //sodier
                for (int i = 0; i < SodierMidle; i++)
                {
                    if (ServeBoundryConditions(i, 1, Order))
                    {
                        continue;
                    }

                    ServeISSup(Order, 1, i);
                }
                //elephant
                for (int i = 0; i < ElefantMidle; i++)
                {
                    if (ServeBoundryConditions(i, 2, Order))
                    {
                        continue;
                    }

                    ServeISSup(Order, 2, i);
                }
                //hourse
                for (int i = 0; i < HourseMidle; i++)
                {
                    if (ServeBoundryConditions(i, 3, Order))
                    {
                        continue;
                    }

                    ServeISSup(Order, 3, i);
                }
                //Castle
                for (int i = 0; i < CastleMidle; i++)
                {
                    if (ServeBoundryConditions(i, 4, Order))
                    {
                        continue;
                    }

                    ServeISSup(Order, 4, i);
                }
                //minister
                for (int i = 0; i < MinisterMidle; i++)
                {
                    if (ServeBoundryConditions(i, 5, Order))
                    {
                        continue;
                    }

                    ServeISSup(Order, 5, i);
                }
                //king
                for (int i = 0; i < KingMidle; i++)
                {
                    if (ServeBoundryConditions(i, 6, Order))
                    {
                        continue;
                    }

                    ServeISSup(Order, 6, i);
                }
                for (int i = 0; i < 1; i++)
                {
                    if (ServeBoundryConditions(i, 7, Order))
                    {
                        continue;
                    }

                    ServeISSup(Order, 7, i);
                }
            }//Brown
            else
            {   //soldier
                for (int i = SodierMidle; i < SodierHigh; i++)
                {
                    if (ServeBoundryConditions(i, 1, Order))
                    {
                        continue;
                    }

                    ServeISSup(Order, 1, i);
                }
                //elephant
                for (int i = ElefantMidle; i < ElefantHigh; i++)
                {
                    if (ServeBoundryConditions(i, 2, Order))
                    {
                        continue;
                    }

                    ServeISSup(Order, 2, i);
                }
                ///hourse
                for (int i = HourseMidle; i < HourseHight; i++)
                {
                    if (ServeBoundryConditions(i, 3, Order))
                    {
                        continue;
                    }

                    ServeISSup(Order, 3, i);
                }
                //Castle
                for (int i = CastleMidle; i < CastleHigh; i++)
                {
                    if (ServeBoundryConditions(i, 4, Order))
                    {
                        continue;
                    }

                    ServeISSup(Order, 4, i);
                }
                //minister
                for (int i = MinisterMidle; i < MinisterHigh; i++)
                {
                    if (ServeBoundryConditions(i, 5, Order))
                    {
                        continue;
                    }

                    ServeISSup(Order, 5, i);
                }
                //king
                for (int i = KingMidle; i < KingHigh; i++)
                {
                    if (ServeBoundryConditions(i, 6, Order))
                    {
                        continue;
                    }

                    ServeISSup(Order, 6, i);
                }
                for (int i = 0; i < 1; i++)
                {
                    if (ServeBoundryConditions(i, -7, Order))
                    {
                        continue;
                    }

                    ServeISSup(Order, -7, i);
                }
            }
        }

        //served mechaisam core
        private void ServeISSup(int Order, int Kind,
                int ii
               )
        {
            //soldoer
            if (Kind == 1)
            {
                ServeISSupSoldier(Order, Kind, ii);
            }
            else if (Kind == 2)//elephant
            {
                ServeISSupElephant(Order, Kind, ii);
            }
            else if (Kind == 3)//hourse
            {
                ServeISSupHourse(Order, Kind, ii);
            }
            else if (Kind == 4)//Castle
            {
                ServeISSupCastle(Order, Kind, ii);
            }
            else//minister
            if (Kind == 5)
            {
                ServeISSupMinister(Order, Kind, ii);
            }
            else
            if (Kind == 6)//king
            {
                ServeISSupKing(Order, Kind, ii);
            }
            else
            if (Kind == 7 || Kind == -7)//king
            {
                ServeISSupCastling(Order, Kind, ii);
            }
        }

        private void ServeISSupSoldier(int Order, int Kind,
                   int ii
                  )
        {
            //soldoer
            if (Kind == 1)
            {
                //Gray
                if (Order == 1)
                {
                    //soldier
                    ServeISSupSoldierGray(Order, Kind, ii);
                }
                else//Brown
                {
                    ServeISSupSoldierBrown(Order, Kind, ii);
                }
            }
        }

        private void ServeISSupSoldierGray(int Order, int Kind,
              int ii
             )
        {
            //soldoer
            if (Kind == 1)
            {
                //soldier
                for (int i = 0; i < SodierMidle; i++)
                {
                    if (SolderesOnTable == null || SolderesOnTable[i] == null)
                    {
                        continue;
                    }

                    for (int j = 0; j < SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder.Count; j++)
                    {
                        if (!(SolderesOnTable[i].SoldierThinkingQuantum[0].IsSup[j]))
                        {
                            continue;
                        }

                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][0] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicAttackValueSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][1] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][2] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicSelfSupportedValueSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][3] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][4] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicReducedSupportSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][5] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicReducedAttackValueSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][6] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicDistributionValueSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][7] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicKingSafeSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][8] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicFromCenterSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][9] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicKingDangourSup;
                    }
                }
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicAttackValueSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicSelfSupportedValueSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicReducedSupportSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicReducedAttackValueSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicDistributionValueSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicKingSafeSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicFromCenterSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicKingDangourSup = 0;
            }
        }

        private void ServeISSupSoldierBrown(int Order, int Kind,
             int ii
            )
        {
            //soldoer
            if (Kind == 1)
            {
                for (int i = SodierMidle; i < SodierHigh; i++)
                {
                    if (SolderesOnTable == null || SolderesOnTable[i] == null)
                    {
                        continue;
                    }

                    for (int j = 0; j < SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder.Count; j++)
                    {
                        if (!(SolderesOnTable[i].SoldierThinkingQuantum[0].IsSup[j]))
                        {
                            continue;
                        }

                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][0] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicAttackValueSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][1] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][2] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicSelfSupportedValueSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][3] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][4] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicReducedSupportSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][5] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicReducedAttackValueSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][6] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicDistributionValueSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][7] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicKingSafeSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][8] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicFromCenterSup;
                        SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder[j][9] += SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicKingDangourSup;
                    }
                }
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicAttackValueSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicSelfSupportedValueSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicReducedSupportSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicReducedAttackValueSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicDistributionValueSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicKingSafeSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicFromCenterSup = 0;
                SolderesOnTable[ii].SoldierThinkingQuantum[0].HeuristicKingDangourSup = 0;
            }
        }

        private void ServeISSupElephant(int Order, int Kind,
              int ii
             )
        {
            //soldoer
            if (Kind == 2)//elephant
            {
                if (Order == 1)//Gray
                {
                    ServeISSupElephantGray(Order, Kind, ii);
                }
                else//Brown
                {
                    //elephant
                    ServeISSupElephantBrown(Order, Kind, ii);
                }
            }
        }

        private void ServeISSupElephantGray(int Order, int Kind,
           int ii
          )
        {
            //soldoer
            if (Kind == 2)//elephant
            {
                for (int i = 0; i < ElefantMidle; i++)
                {
                    if (ElephantOnTable == null || ElephantOnTable[i] == null)
                    {
                        continue;
                    }

                    for (int j = 0; j < ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant.Count; j++)
                    {
                        if (!(ElephantOnTable[i].ElefantThinkingQuantum[0].IsSup[j]))
                        {
                            continue;
                        }

                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][0] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicAttackValueSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][1] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][2] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicSelfSupportedValueSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][3] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][4] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicReducedSupportSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][5] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicReducedAttackValueSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][6] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicDistributionValueSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][7] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicKingSafeSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][8] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicFromCenterSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][9] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicKingDangourSup;
                    }
                }
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicAttackValueSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicSelfSupportedValueSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicReducedSupportSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicReducedAttackValueSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicDistributionValueSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicKingSafeSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicFromCenterSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicKingDangourSup = 0;
            }
        }

        private void ServeISSupElephantBrown(int Order, int Kind,
               int ii
              )
        {
            //soldoer
            if (Kind == 2)//elephant
            {
                for (int i = 0; i < ElefantMidle; i++)
                {
                    if (ElephantOnTable == null || ElephantOnTable[i] == null)
                    {
                        continue;
                    }

                    for (int j = 0; j < ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant.Count; j++)
                    {
                        if (!(ElephantOnTable[i].ElefantThinkingQuantum[0].IsSup[j]))
                        {
                            continue;
                        }

                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][0] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicAttackValueSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][1] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][2] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicSelfSupportedValueSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][3] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][4] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicReducedSupportSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][5] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicReducedAttackValueSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][6] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicDistributionValueSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][7] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicKingSafeSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][8] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicFromCenterSup;
                        ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant[j][9] += ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicKingDangourSup;
                    }
                }
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicAttackValueSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicSelfSupportedValueSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicReducedSupportSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicReducedAttackValueSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicDistributionValueSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicKingSafeSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicFromCenterSup = 0;
                ElephantOnTable[ii].ElefantThinkingQuantum[0].HeuristicKingDangourSup = 0;
            }
        }

        private void ServeISSupHourse(int Order, int Kind,
             int ii
            )
        {
            if (Kind == 3)//hourse
            {
                if (Order == 1)//Gray
                {
                    ServeISSupHourseGray(Order, Kind, ii);
                }
                else//Brown
                {
                    ServeISSupHourseBrown(Order, Kind, ii);
                }
            }
        }

        private void ServeISSupHourseGray(int Order, int Kind,
          int ii
         )
        {
            if (Kind == 3)//hourse
            {
                for (int i = 0; i < HourseMidle; i++)
                {
                    if (HoursesOnTable == null || HoursesOnTable[i] == null)
                    {
                        continue;
                    }

                    for (int j = 0; j < HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse.Count; j++)
                    {
                        if (!(HoursesOnTable[i].HourseThinkingQuantum[0].IsSup[j]))
                        {
                            continue;
                        }

                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][0] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicAttackValueSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][1] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][2] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicSelfSupportedValueSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][3] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][4] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicReducedSupportSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][5] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicReducedAttackValueSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][6] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicDistributionValueSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][7] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicKingSafeSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][8] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicFromCenterSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][9] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicKingDangourSup;
                    }
                }
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicAttackValueSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicSelfSupportedValueSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicReducedSupportSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicReducedAttackValueSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicDistributionValueSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicKingSafeSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicFromCenterSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicKingDangourSup = 0;
            }
        }

        private void ServeISSupHourseBrown(int Order, int Kind,
         int ii
        )
        {
            if (Kind == 3)//hourse
            {
                for (int i = HourseMidle; i < HourseHight; i++)
                {
                    if (HoursesOnTable == null || HoursesOnTable[i] == null)
                    {
                        continue;
                    }

                    for (int j = 0; j < HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse.Count; j++)
                    {
                        if (!(HoursesOnTable[i].HourseThinkingQuantum[0].IsSup[j]))
                        {
                            continue;
                        }

                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][0] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicAttackValueSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][1] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][2] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicSelfSupportedValueSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][3] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][4] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicReducedSupportSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][5] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicReducedAttackValueSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][6] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicDistributionValueSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][7] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicKingSafeSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][8] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicFromCenterSup;
                        HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse[j][9] += HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicKingDangourSup;
                    }
                }
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicAttackValueSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicSelfSupportedValueSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicReducedSupportSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicReducedAttackValueSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicDistributionValueSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicKingSafeSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicFromCenterSup = 0;
                HoursesOnTable[ii].HourseThinkingQuantum[0].HeuristicKingDangourSup = 0;
            }
        }

        private void ServeISSupCastle(int Order, int Kind,
                int ii
               )
        {
            if (Kind == 4)//Castle
            {
                if (Order == 1)//Gray
                {
                    ServeISSupCastleGray(Order, Kind, ii);
                }
                else//Brown
                {
                    ServeISSupCastleBrown(Order, Kind, ii);
                }
            }
        }

        private void ServeISSupCastleGray(int Order, int Kind,
            int ii
           )
        {
            if (Kind == 4)//Castle
            {
                for (int i = 0; i < CastleMidle; i++)
                {
                    if (CastlesOnTable == null || CastlesOnTable[i] == null)
                    {
                        continue;
                    }

                    for (int j = 0; j < CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle.Count; j++)
                    {
                        if (!(CastlesOnTable[i].CastleThinkingQuantum[0].IsSup[j]))
                        {
                            continue;
                        }

                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][0] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicAttackValueSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][1] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][2] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicSelfSupportedValueSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][3] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][4] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicReducedSupportSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][5] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicReducedAttackValueSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][6] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicDistributionValueSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][7] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicKingSafeSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][8] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicFromCenterSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][9] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicKingDangourSup;
                    }
                }
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicAttackValueSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicSelfSupportedValueSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicReducedSupportSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicReducedAttackValueSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicDistributionValueSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicKingSafeSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicFromCenterSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicKingDangourSup = 0;
            }
        }

        private void ServeISSupCastleBrown(int Order, int Kind,
               int ii
              )
        {
            if (Kind == 4)//Castle
            {
                for (int i = CastleMidle; i < CastleHigh; i++)
                {
                    if (CastlesOnTable == null || CastlesOnTable[i] == null)
                    {
                        continue;
                    }

                    for (int j = 0; j < CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle.Count; j++)
                    {
                        if (!(CastlesOnTable[i].CastleThinkingQuantum[0].IsSup[j]))
                        {
                            continue;
                        }

                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][0] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicAttackValueSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][1] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][2] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicSelfSupportedValueSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][3] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][4] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicReducedSupportSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][5] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicReducedAttackValueSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][6] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicDistributionValueSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][7] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicKingSafeSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][8] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicFromCenterSup;
                        CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle[j][9] += CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicKingDangourSup;
                    }
                }
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicAttackValueSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicSelfSupportedValueSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicReducedSupportSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicReducedAttackValueSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicDistributionValueSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicKingSafeSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicFromCenterSup = 0;
                CastlesOnTable[ii].CastleThinkingQuantum[0].HeuristicKingDangourSup = 0;
            }
        }

        private void ServeISSupMinister(int Order, int Kind,
                int ii
               )
        {
            //minister
            if (Kind == 5)
            {
                if (Order == 1)//Gray
                {
                    ServeISSupMinisterGray(Order, Kind, ii);
                }
                else
                {
                    ServeISSupMinisterBrown(Order, Kind, ii);
                }
            }
        }

        private void ServeISSupMinisterGray(int Order, int Kind,
              int ii
             )
        {
            //minister
            if (Kind == 5)
            {
                for (int i = 0; i < MinisterMidle; i++)
                {
                    if (MinisterOnTable == null || MinisterOnTable[i] == null)
                    {
                        continue;
                    }

                    for (int j = 0; j < MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister.Count; j++)
                    {
                        if (!(MinisterOnTable[i].MinisterThinkingQuantum[0].IsSup[j]))
                        {
                            continue;
                        }

                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][0] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicAttackValueSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][1] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][2] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicSelfSupportedValueSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][3] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][4] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicReducedSupportSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][5] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicReducedAttackValueSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][6] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicDistributionValueSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][7] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicKingSafeSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][8] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicFromCenterSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][9] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicKingDangourSup;
                    }
                }
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicAttackValueSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicSelfSupportedValueSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicReducedSupportSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicReducedAttackValueSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicDistributionValueSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicKingSafeSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicFromCenterSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicKingDangourSup = 0;
            }
        }

        private void ServeISSupMinisterBrown(int Order, int Kind,
                int ii
               )
        {
            //minister
            if (Kind == 5)
            {
                for (int i = MinisterMidle; i < MinisterHigh; i++)
                {
                    if (MinisterOnTable == null || MinisterOnTable[i] == null)
                    {
                        continue;
                    }

                    for (int j = 0; j < MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister.Count; j++)
                    {
                        if (!(MinisterOnTable[i].MinisterThinkingQuantum[0].IsSup[j]))
                        {
                            continue;
                        }

                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][0] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicAttackValueSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][1] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][2] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicSelfSupportedValueSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][3] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][4] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicReducedSupportSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][5] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicReducedAttackValueSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][6] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicDistributionValueSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][7] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicKingSafeSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][8] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicFromCenterSup;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister[j][9] += MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicKingDangourSup;
                    }
                }
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicAttackValueSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicSelfSupportedValueSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicReducedSupportSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicReducedAttackValueSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicDistributionValueSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicKingSafeSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicFromCenterSup = 0;
                MinisterOnTable[ii].MinisterThinkingQuantum[0].HeuristicKingDangourSup = 0;
            }
        }

        private void ServeISSupKing(int Order, int Kind,
               int ii
              )
        {
            if (Kind == 6)//king
            {
                if (Order == 1)//Gray
                {
                    ServeISSupKingGray(Order, Kind, ii);
                }
                else//Brown
                {
                    ServeISSupKingBrown(Order, Kind, ii);
                }
            }
        }

        private void ServeISSupKingGray(int Order, int Kind,
             int ii
            )
        {
            if (Kind == 6)//king
            {
                for (int i = 0; i < KingMidle; i++)
                {
                    if (KingOnTable == null || KingOnTable[i] == null)
                    {
                        continue;
                    }

                    for (int j = 0; j < KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing.Count; j++)
                    {
                        if (!(KingOnTable[i].KingThinkingQuantum[0].IsSup[j]))
                        {
                            continue;
                        }

                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][0] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicAttackValueSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][1] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][2] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicSelfSupportedValueSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][3] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][4] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicReducedSupportSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][5] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicReducedAttackValueSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][6] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicDistributionValueSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][7] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicKingSafeSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][8] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicFromCenterSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][9] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicKingDangourSup;
                    }
                }
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicAttackValueSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicSelfSupportedValueSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicReducedSupportSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicReducedAttackValueSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicDistributionValueSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicKingSafeSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicFromCenterSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicKingDangourSup = 0;
            }
        }

        private void ServeISSupKingBrown(int Order, int Kind,
              int ii
             )
        {
            if (Kind == 6)//king
            {
                for (int i = KingMidle; i < KingHigh; i++)
                {
                    if (KingOnTable == null || KingOnTable[i] == null)
                    {
                        continue;
                    }

                    for (int j = 0; j < KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing.Count; j++)
                    {
                        if (!(KingOnTable[i].KingThinkingQuantum[0].IsSup[j]))
                        {
                            continue;
                        }

                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][0] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicAttackValueSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][1] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][2] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicSelfSupportedValueSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][3] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicReducedMovementValueSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][4] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicReducedSupportSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][5] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicReducedAttackValueSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][6] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicDistributionValueSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][7] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicKingSafeSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][8] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicFromCenterSup;
                        KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing[j][9] += KingOnTable[ii].KingThinkingQuantum[0].HeuristicKingDangourSup;
                    }
                }
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicAttackValueSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicSelfSupportedValueSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicReducedMovementValueSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicReducedSupportSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicReducedAttackValueSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicDistributionValueSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicKingSafeSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicFromCenterSup = 0;
                KingOnTable[ii].KingThinkingQuantum[0].HeuristicKingDangourSup = 0;
            }
        }

        private void ServeISSupCastling(int Order, int Kind,
              int ii
             )
        {
            if (Kind == 7 || Kind == -7)//king
            {
                if (Order == 1)//Gray
                {
                    ServeISSupCastlingGray(Order, Kind, ii);
                }
                else//Brown
                {
                    ServeISSupCastlingBrown(Order, Kind, ii);
                }
            }
        }

        private void ServeISSupCastlingGray(int Order, int Kind,
          int ii
         )
        {
            if (Kind == 7 || Kind == -7)//king
            {
                for (int i = 0; i < 1; i++)
                {
                    if (CastlingOnTable == null || CastlingOnTable[i] == null)
                    {
                        continue;
                    }

                    for (int j = 0; j < CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling.Count; j++)
                    {
                        if (!(CastlingOnTable[i].CastlingThinking[0].IsSup[j]))
                        {
                            continue;
                        }

                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][0] += CastlingOnTable[ii].CastlingThinking[0].HeuristicAttackValueSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][1] += CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedMovementValueSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][2] += CastlingOnTable[ii].CastlingThinking[0].HeuristicSelfSupportedValueSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][3] += CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedMovementValueSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][4] += CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedSupportSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][5] += CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedAttackValueSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][6] += CastlingOnTable[ii].CastlingThinking[0].HeuristicDistributionValueSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][7] += CastlingOnTable[ii].CastlingThinking[0].HeuristicKingSafeSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][8] += CastlingOnTable[ii].CastlingThinking[0].HeuristicFromCenterSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][9] += CastlingOnTable[ii].CastlingThinking[0].HeuristicKingDangourSup;
                    }
                }
                CastlingOnTable[ii].CastlingThinking[0].HeuristicAttackValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedMovementValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicSelfSupportedValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedMovementValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedSupportSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedAttackValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicDistributionValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicKingSafeSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicFromCenterSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicKingDangourSup = 0;
            }
        }

        private void ServeISSupCastlingBrown(int Order, int Kind,
              int ii
             )
        {
            if (Kind == 7 || Kind == -7)//king
            {
                for (int i = 0; i < 1; i++)
                {
                    if (CastlingOnTable == null || CastlingOnTable[i] == null)
                    {
                        continue;
                    }

                    for (int j = 0; j < CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling.Count; j++)
                    {
                        if (!(CastlingOnTable[i].CastlingThinking[0].IsSup[j]))
                        {
                            continue;
                        }

                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][0] += CastlingOnTable[ii].CastlingThinking[0].HeuristicAttackValueSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][1] += CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedMovementValueSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][2] += CastlingOnTable[ii].CastlingThinking[0].HeuristicSelfSupportedValueSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][3] += CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedMovementValueSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][4] += CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedSupportSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][5] += CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedAttackValueSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][6] += CastlingOnTable[ii].CastlingThinking[0].HeuristicDistributionValueSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][7] += CastlingOnTable[ii].CastlingThinking[0].HeuristicKingSafeSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][8] += CastlingOnTable[ii].CastlingThinking[0].HeuristicFromCenterSup;
                        CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][9] += CastlingOnTable[ii].CastlingThinking[0].HeuristicKingDangourSup;
                    }
                }
                CastlingOnTable[ii].CastlingThinking[0].HeuristicAttackValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedMovementValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicSelfSupportedValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedMovementValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedSupportSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedAttackValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicDistributionValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicKingSafeSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicFromCenterSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicKingDangourSup = 0;
            }
        }

        //main initiation of soldier Gray
        private AllDraw InitiateAStarGreedytSodlerGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            object oo = new object();
            lock (oo)
            {
                //For Gray Soldeirs Objects.
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(0, SodierMidle, i =>
 {
     Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedytSodler(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
     H.Wait();
     H.Dispose();
 });
            }
            return this;
        }

        private bool InitiateAStarGreedyt(int i, int Kind, int Order)
        {
            object oo = new object();
            lock (oo)
            {
                bool Is = false;
                try
                {
                    /* if (OrderPlateDraw == 1)
                     {
                         if (Wtime != null)
                         {
                             if (Wtime.EndTime)
                                 return true;
                         }
                     }
                     else {
                         if (Btime != null)
                         {
                             if (Btime.EndTime)
                                 return true;
                         }
                     }*/
                    if (
                        /*(MaxAStarGreedy <= CurrentMaxLevel + PlatformHelper.ProcessorCount) &&*/
                        ((MaxAStarGreedy < StoreInitMaxAStarGreedy + PlatformHelper.ProcessorCount
                                                                   ) || (CurrentMaxLevel < StoreInitMaxAStarGreedyEqual && SStopInitMaxAStarGreedy)))// if (MaxAStarGreedy < indexStep * PlatformHelper.ProcessorCount)
                    {
                        MaxAStarGreedy = CurrentMaxLevel;
                    }
                    else
                    {
                        if (CurrentMaxLevel >= MaxAStarGreedy)
                        return true;
                    }

                    if (CalIdle == 2)
                    {
                        return true;
                    }

                    if (Kind == 1)
                    {
                        Is = Is || InitiateAStarGreedytSoldier(i, Kind, Order);
                    }
                    else
     if (Kind == 2)
                    {
                        Is = Is || InitiateAStarGreedytElephant(i, Kind, Order);
                    }
                    else
     if (Kind == 3)
                    {
                        Is = Is || InitiateAStarGreedytHourse(i, Kind, Order);
                    }
                    else
     if (Kind == 4)
                    {
                        Is = Is || InitiateAStarGreedytCastle(i, Kind, Order);
                    }
                    else
     if (Kind == 5)
                    {
                        Is = Is || InitiateAStarGreedytMinidter(i, Kind, Order);
                    }
                    else
     if (Kind == 6)
                    {
                        Is = Is || InitiateAStarGreedytKing(i, Kind, Order);
                    }
                    else
     if (Kind == 7 || Kind == -7)
                    {
                        Is = Is || InitiateAStarGreedytCastling(i, Kind, Order);
                    }
                }
                catch (Exception t)

                {
                    Log(t);
                }
                return Is;
            }
        }

        private bool InitiateAStarGreedytSoldier(int i, int Kind, int Order)
        {
            object oo = new object();
            lock (oo)
            {
                if (Order == 1 && i >= SodierMidle)
                {
                    return false;
                }

                if (Order == -1 && i >= SodierHigh)
                {
                    return false;
                }

                if (SolderesOnTable != null)
                {
                    if (SolderesOnTable[i] != null)
                    {
                        return true;
                    }
                }

                return false;
            }
        }

        private bool InitiateAStarGreedytElephant(int i, int Kind, int Order)
        {
            object oo = new object();
            lock (oo)
            {
                if (Order == 1 && i >= ElefantMidle)
                {
                    return false;
                }

                if (Order == -1 && i >= ElefantHigh)
                {
                    return false;
                }

                if (ElephantOnTable != null)
                {
                    if (ElephantOnTable[i] != null)
                    {
                        return true;
                    }
                }

                return false;
            }
        }

        private bool InitiateAStarGreedytHourse(int i, int Kind, int Order)
        {
            object oo = new object();
            lock (oo)
            {
                if (Order == 1 && i >= HourseMidle)
                {
                    return false;
                }

                if (Order == -1 && i >= HourseHight)
                {
                    return false;
                }

                if (HoursesOnTable != null)
                {
                    if (HoursesOnTable[i] != null)
                    {
                        return true;
                    }
                }

                return false;
            }
        }

        private bool InitiateAStarGreedytCastle(int i, int Kind, int Order)
        {
            object oo = new object();
            lock (oo)
            {
                if (Order == 1 && i >= CastleMidle)
                {
                    return false;
                }

                if (Order == -1 && i >= CastleHigh)
                {
                    return false;
                }

                if (CastlesOnTable != null)
                {
                    if (CastlesOnTable[i] != null)
                    {
                        return true;
                    }
                }

                return false;
            }
        }

        private bool InitiateAStarGreedytMinidter(int i, int Kind, int Order)
        {
            object oo = new object();
            lock (oo)
            {
                if (Order == 1 && i >= MinisterMidle)
                {
                    return false;
                }

                if (Order == -1 && i >= MinisterHigh)
                {
                    return false;
                }

                if (MinisterOnTable != null)
                {
                    if (MinisterOnTable[i] != null)
                    {
                        return true;
                    }
                }

                return false;
            }
        }

        private bool InitiateAStarGreedytKing(int i, int Kind, int Order)
        {
            object oo = new object();
            lock (oo)
            {
                if (Order == 1 && i >= KingMidle)
                {
                    return false;
                }

                if (Order == -1 && i >= KingHigh)
                {
                    return false;
                }

                if (KingOnTable != null)
                {
                    if (KingOnTable[i] != null)
                    {
                        return true;
                    }
                }

                return false;
            }
        }

        private bool InitiateAStarGreedytCastling(int i, int Kind, int Order)
        {
            object oo = new object();
            lock (oo)
            {
                if (Order == 1 && i > 0)
                {
                    return false;
                }

                if (Order == -1 && i > 0)
                {
                    return false;
                }

                if (CastlingOnTable != null)
                {
                    if (CastlingOnTable[i] != null)
                    {
                        return true;
                    }
                }

                return false;
            }
        }

        private AllDraw InitiateAStarGreedytSodler(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
      )
        {
            object oo = new object();
            lock (oo)
            {
                //For Gray Soldeirs Objects.
                object O = new object();
                lock (O)
                {
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //If Solders Not Exist Continue and Traversal Back.
                    if (InitiateAStarGreedyt(i, 1, Order))
                    {
                        AllDraw Th = AStarGreedyString;
                        if (IsAtLeastAllObjectIsNull())
                        {
                            TableList.Clear();
                            TableList.Add(CloneATable(Table));
                            SetRowColumn(0);
                            IsCurrentDraw = true;
                        }
                        AStarGreedyString = Th;

                        //Initiate of Local Variables By Global Objective Gray Current Solder.
                        //int ik = (int)SolderesOnTable[i].Row;
                        //int jk = (int)SolderesOnTable[i].Column;
                        //Construction of Thinking Gray Soldier By Local Variables.
                        //if (SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count == 0)
                        //If There is no Thinking Movments on Current Object
                        if (SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count == 0)
                        {
                            InitiateAStarGreedytSodlerThinking(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                        }
                        else
                        {
                            SolderesOnTable[i].SoldierThinkingQuantum[0].ThinkingBegin = false;
                            SolderesOnTable[i].SoldierThinkingQuantum[0].ThinkingFinished = true;
                        }
                    }
                }
            }
            return this;
        }

        private AllDraw InitiateAStarGreedytSodlerThinking(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
         )
        {
            //For All Movable Gray Solders.
            //Thinking of Gray Solder Operation.
            object OOO = new object();
            lock (OOO)
            {
                SolderesOnTable[i].SoldierThinkingQuantum[0].ThinkingBegin = true;
                SolderesOnTable[i].SoldierThinkingQuantum[0].ThinkingFinished = false;
                Task array = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinkingQuantum[0].Thinking(iAStarGreedy, this, ref SolderesOnTable[i].LoseOcuuredatChiled, ref SolderesOnTable[i].WinOcuuredatChiled));
                array.Wait(); array.Dispose();
                if (SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count != 0)
                {
                    SolderesOnTableMove[i] = true;
                    AllDraw.ChangedInTreeOccured = true;
                }
            }

            return this;
        }

        //main initiation of elephant Gray
        private AllDraw InitiateAStarGreedytElephantGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            object oo = new object();
            lock (oo)
            {
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(0, ElefantMidle, i =>
                 {
                     Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedytElephant(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
                     H.Wait();
                     H.Dispose();
                 });
            }
            return this;
        }

        private AllDraw InitiateAStarGreedytElephant(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
             )
        {
            object oo = new object();
            lock (oo)
            {
                object O = new object();
                lock (O)
                {
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //Ignore of Non Exist Current Elephant Gray Objects.
                    if (InitiateAStarGreedyt(i, 2, Order))
                    {
                        AllDraw Th = AStarGreedyString;
                        if (IsAtLeastAllObjectIsNull())
                        {
                            TableList.Clear();
                            TableList.Add(CloneATable(Table));
                            SetRowColumn(0);
                            IsCurrentDraw = true;
                        }
                        AStarGreedyString = Th;

                        //Inititae Local Varibale By Global Gray Elephant Objects Varibales.
                        //int ik = (int)ElephantOnTable[i].Row;
                        //int jk = (int)ElephantOnTable[i].Column;
                        //Construction of Thinking Objects By Local Varibales.
                        //if (ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count == 0)
                        //If There is Not Thinking Objetive List Elephant Gray.
                        if (ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count == 0)
                        {
                            InitiateAStarGreedytElefantThinking(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                        }
                        else
                        {
                            ElephantOnTable[i].ElefantThinkingQuantum[0].ThinkingBegin = false;
                            ElephantOnTable[i].ElefantThinkingQuantum[0].ThinkingFinished = true;
                        }
                    }
                }
            }
            return this;
        }

        private AllDraw InitiateAStarGreedytElefantThinking(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
         )
        {
            object O = new object();
            lock (O)
            {
                ElephantOnTable[i].ElefantThinkingQuantum[0].ThinkingBegin = true;
                ElephantOnTable[i].ElefantThinkingQuantum[0].ThinkingFinished = false;
                Task array = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinkingQuantum[0].Thinking(iAStarGreedy, this, ref ElephantOnTable[i].LoseOcuuredatChiled, ref ElephantOnTable[i].WinOcuuredatChiled));
                array.Wait(); array.Dispose();
                if (ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count != 0)
                {
                    ElephantOnTableMove[i] = true;
                    AllDraw.ChangedInTreeOccured = true;
                }
            }
            return this;
        }

        //main initiation of hourse Gray
        private AllDraw InitiateAStarGreedythHourseGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            object oo = new object();
            lock (oo)
            {
                //For All Gray Hourse Objects.
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(0, HourseMidle, i =>
                 {
                     Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythHourse(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
                     H.Wait();
                     H.Dispose();
                 });
            }
            return this;
        }

        private AllDraw InitiateAStarGreedythHourse(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            object oo = new object();
            lock (oo)
            {
                //For All Gray Hourse Objects.
                object O = new object();
                lock (O)
                {
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //Ignore of Non Exist Current Gray Hourse Objects.
                    if (InitiateAStarGreedyt(i, 3, Order))
                    {
                        AllDraw Th = AStarGreedyString;
                        if (IsAtLeastAllObjectIsNull())
                        {
                            TableList.Clear();
                            TableList.Add(CloneATable(Table));
                            SetRowColumn(0);
                            IsCurrentDraw = true;
                        }
                        AStarGreedyString = Th;

                        //Initiate of Local Variables By Global Gray Hourse Objectives.
                        //int ik = (int)HoursesOnTable[i].Row;
                        //int jk = (int)HoursesOnTable[i].Column;
                        //Construction of Gray Hourse Thinking Objects..
                        //if (HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count == 0)
                        //When There is Not HourseList Count.
                        if (HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count == 0)
                        {
                            InitiateAStarGreedythHourseThinking(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                        }
                        else
                        {
                            HoursesOnTable[i].HourseThinkingQuantum[0].ThinkingBegin = false;
                            HoursesOnTable[i].HourseThinkingQuantum[0].ThinkingFinished = true;
                        }
                    }
                }
            }
            return this;
        }

        private AllDraw InitiateAStarGreedythHourseThinking(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
        )
        {
            //For All Gray Hourse Objects.
            object O = new object();
            lock (O)
            {
                //For All Possible Movments.

                //Thinking of Gray Hourse Oprational.

                HoursesOnTable[i].HourseThinkingQuantum[0].ThinkingBegin = true;
                HoursesOnTable[i].HourseThinkingQuantum[0].ThinkingFinished = false;
                Task array = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinkingQuantum[0].Thinking(iAStarGreedy, this, ref HoursesOnTable[i].LoseOcuuredatChiled, ref HoursesOnTable[i].WinOcuuredatChiled));
                array.Wait(); array.Dispose();
                if (HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count != 0)
                {
                    HoursesOnTableMove[i] = true;
                    AllDraw.ChangedInTreeOccured = true;
                }

                return this;
            }
        }

        //main initiation of Castle Gray
        private AllDraw InitiateAStarGreedythCastleGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
       )
        {
            object oo = new object();
            lock (oo)
            {
                //For All Possible Gray Castles Objects.
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(0, CastleMidle, i =>
                 {
                     Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythCastle(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
                     H.Wait();
                     H.Dispose();
                 });
            }
            return this;
        }

        private AllDraw InitiateAStarGreedythCastle(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
       )
        {
            object oo = new object();
            lock (oo)
            {
                //For All Possible Gray Castles Objects.
                object O = new object();
                lock (O)
                {
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //When Current Castles Gray Not Exist Continue Traversal Back.
                    if (InitiateAStarGreedyt(i, 4, Order))
                    {
                        AllDraw Th = AStarGreedyString;
                        if (IsAtLeastAllObjectIsNull())
                        {
                            TableList.Clear();
                            TableList.Add(CloneATable(Table));
                            SetRowColumn(0);
                            IsCurrentDraw = true;
                        }
                        AStarGreedyString = Th;

                        //Initaiate of Local Varibales By Global Varoiables.
                        //int ik = (int)CastlesOnTable[i].Row;
                        //int jk = (int)CastlesOnTable[i].Column;
                        //Construction of Thinking Variables By Local Variables.
                        //if (CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count == 0)
                        //When Count of Table Castles of Thinking Not Exist Do Operational.
                        if (CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count == 0)
                        {
                            InitiateAStarGreedythCastleThinking(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                        }
                        else
                        {
                            CastlesOnTable[i].CastleThinkingQuantum[0].ThinkingBegin = false;
                            CastlesOnTable[i].CastleThinkingQuantum[0].ThinkingFinished = true;
                        }
                    }
                }
            }
            return this;
        }

        private AllDraw InitiateAStarGreedythCastleThinking(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
   )
        {
            //For All Possible Movments.

            object OOO = new object();
            lock (OOO)
            {
                //Thinking of Gray Castles Operational.
                CastlesOnTable[i].CastleThinkingQuantum[0].ThinkingBegin = true;
                CastlesOnTable[i].CastleThinkingQuantum[0].ThinkingFinished = false;
                Task array = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinkingQuantum[0].Thinking(iAStarGreedy, this, ref CastlesOnTable[i].LoseOcuuredatChiled, ref CastlesOnTable[i].WinOcuuredatChiled));
                array.Wait(); array.Dispose();

                if (CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count != 0)
                {
                    CastlesOnTableMove[i] = true;
                    AllDraw.ChangedInTreeOccured = true;
                }
            }

            return this;
        }

        //main initiation of minister Gray
        private AllDraw InitiateAStarGreedythMinisterGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            object oo = new object();
            lock (oo)
            {
                //For All Possible Gray Minister Movments.
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(0, MinisterMidle, i =>
                 {
                     Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythMinister(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
                     H.Wait();
                     H.Dispose();
                 });
            }
            return this;
        }

        private AllDraw InitiateAStarGreedythMinister(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            object oo = new object();
            lock (oo)
            {
                //For All Possible Gray Minister Movments.
                object O = new object();
                lock (O)
                {
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //For Each Non Exist Gray Minister Objectives.
                    if (InitiateAStarGreedyt(i, 5, Order))
                    {
                        AllDraw Th = AStarGreedyString;
                        if (IsAtLeastAllObjectIsNull())
                        {
                            TableList.Clear();
                            TableList.Add(CloneATable(Table));
                            SetRowColumn(0);
                            IsCurrentDraw = true;
                        }
                        AStarGreedyString = Th;

                        //Inititate Local Variables By Global Varibales.
                        //int ik = (int)MinisterOnTable[i].Row;
                        //int jk = (int)MinisterOnTable[i].Column;
                        //Construction of Thinking Objects Gray Minister.
                        //if (MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count == 0)
                        //If There is Not Minister Of Gray In The Thinking Table List.
                        if (MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count == 0)
                        {
                            InitiateAStarGreedythMinisterThinking(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                        }
                        else
                        {
                            MinisterOnTable[i].MinisterThinkingQuantum[0].ThinkingBegin = false;
                            MinisterOnTable[i].MinisterThinkingQuantum[0].ThinkingFinished = true;
                        }
                    }
                }
            }
            return this;
        }

        private AllDraw InitiateAStarGreedythMinisterThinking(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
      )
        {
            object oo = new object();
            lock (oo)
            {
                //For All Possible Gray Minister Movments.
                object O = new object();
                lock (O)
                {
                    //For All Possible Movments.

                    //Thinking of Gray Minister Operational.
                    object OOO = new object();
                    lock (OOO)
                    {
                        MinisterOnTable[i].MinisterThinkingQuantum[0].ThinkingBegin = true;
                        MinisterOnTable[i].MinisterThinkingQuantum[0].ThinkingFinished = false;
                        Task array = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinkingQuantum[0].Thinking(iAStarGreedy, this, ref MinisterOnTable[i].LoseOcuuredatChiled, ref MinisterOnTable[i].WinOcuuredatChiled));
                        array.Wait(); array.Dispose();
                        if (MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count != 0)
                        {
                            MinisterOnTableMove[i] = true;
                            AllDraw.ChangedInTreeOccured = true;
                        }
                    }
                }
            }
            return this;
        }

        //main initiation of king Gray
        private AllDraw InitiateAStarGreedythKingGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            object oo = new object();
            lock (oo)
            {
                //For All Possible Gray King Objects.
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(0, KingMidle, i =>
                 {
                     Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythKing(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
                     H.Wait();
                     H.Dispose();
                 });
            }
            return this;
        }

        private AllDraw InitiateAStarGreedythCastlingGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
             )
        {
            object oo = new object();
            lock (oo)
            {
                //For All Possible Gray Castling Objects.
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(0, 1, i =>
                 {
                     Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythCastling(7, i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
                     H.Wait();
                     H.Dispose();
                 });
            }
            return this;
        }

        private AllDraw InitiateAStarGreedythKing(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
             )
        {
            object oo = new object();
            lock (oo)
            {
                //For All Possible Gray King Objects.
                object O = new object();
                lock (O)
                {
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //If There is Not Current Object Continue Traversal Back.
                    if (InitiateAStarGreedyt(i, 6, Order))
                    {
                        AllDraw Th = AStarGreedyString;
                        if (IsAtLeastAllObjectIsNull())
                        {
                            TableList.Clear();
                            TableList.Add(CloneATable(Table));
                            SetRowColumn(0);
                            IsCurrentDraw = true;
                        }
                        AStarGreedyString = Th;

                        //Initiate Local varibale By Global Objective Varibales.
                        //int ik = (int)(int)KingOnTable[i].Row;
                        //int jk = (int)KingOnTable[i].Column;
                        //Construction of Gray King Thinking Objects.
                        //if (KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count == 0)
                        //When There is Not Thinking Table Gray King Movments.
                        if (KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count == 0)
                        {
                            InitiateAStarGreedythKingThinking(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                        }
                        else
                        {
                            KingOnTable[i].KingThinkingQuantum[0].ThinkingBegin = false;
                            KingOnTable[i].KingThinkingQuantum[0].ThinkingFinished = true;
                        }
                    }
                }
            }
            return this;
        }

        private AllDraw InitiateAStarGreedythKingThinking(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
       )
        {
            object oo = new object();
            lock (oo)
            {
                //For All Possible Gray King Movments.

                //Thinking Of Gray King Operatins.
                object OOO = new object();
                lock (OOO)
                {
                    KingOnTable[i].KingThinkingQuantum[0].ThinkingBegin = true;
                    KingOnTable[i].KingThinkingQuantum[0].ThinkingFinished = false;
                    ; Task array = Task.Factory.StartNew(() => KingOnTable[i].KingThinkingQuantum[0].Thinking(iAStarGreedy, this, ref KingOnTable[i].LoseOcuuredatChiled, ref KingOnTable[i].WinOcuuredatChiled));
                    array.Wait(); array.Dispose();
                    if (KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count != 0)
                    {
                        KingOnTableMove[i] = true;
                        AllDraw.ChangedInTreeOccured = true;
                    }
                }
            }
            return this;
        }

        private AllDraw InitiateAStarGreedythCastling(int kin, int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
             )
        {
            object oo = new object();
            lock (oo)
            {
                //For All Possible Gray Castling Objects.
                object O = new object();
                lock (O)
                {
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //If There is Not Current Object Continue Traversal Back.
                    if (InitiateAStarGreedyt(i, kin, Order))
                    {
                        AllDraw Th = AStarGreedyString;
                        if (IsAtLeastAllObjectIsNull())
                        {
                            TableList.Clear();
                            TableList.Add(CloneATable(Table));
                            SetRowColumn(0);
                            IsCurrentDraw = true;
                        }
                        AStarGreedyString = Th;

                        //Initiate Local varibale By Global Objective Varibales.
                        //int ik = (int)(int)CastlingOnTable[i].Row;
                        //int jk = (int)CastlingOnTable[i].Column;
                        //Construction of Gray Castling Thinking Objects.
                        //if (CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count == 0)
                        //When There is Not Thinking Table Gray Castling Movments.
                        if (CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count == 0)
                        {
                            InitiateAStarGreedythCastlingThinking(kin, i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                        }
                        else
                        {
                            CastlingOnTable[i].CastlingThinking[0].ThinkingBegin = false;
                            CastlingOnTable[i].CastlingThinking[0].ThinkingFinished = true;
                        }
                    }
                }
            }
            return this;
        }

        private AllDraw InitiateAStarGreedythCastlingThinking(int kin, int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
           )
        {
            object oo = new object();
            lock (oo)
            {
                //For All Possible Gray Castling Movments.
                //Thinking Of Gray Castling Operatins.
                CastlingOnTable[i].CastlingThinking[0].ThinkingBegin = true;
                CastlingOnTable[i].CastlingThinking[0].ThinkingFinished = false;
                Task array = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].Thinking(iAStarGreedy, this, ref CastlingOnTable[i].LoseOcuuredatChiled, ref CastlingOnTable[i].WinOcuuredatChiled));
                array.Wait(); array.Dispose();
                if (CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count != 0)
                {
                    CastlingOnTableMove[i] = true;
                    AllDraw.ChangedInTreeOccured = true;
                }
            }
            return this;
        }

        //main initiation of soldier Brown
        private AllDraw InitiateAStarGreedythSoldierBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            object oo = new object();
            lock (oo)
            {
                //For Each Objects of Brown Sodiers.
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(SodierMidle, SodierHigh, i =>

 {
     Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedytSodler(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
     H.Wait();
     H.Dispose();
 });
            }

            return this;
        }

        //main initiation of elephant Brown
        private AllDraw InitiateAStarGreedythElephantBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            object oo = new object();
            lock (oo)
            {
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(ElefantMidle, ElefantHigh, i =>

 {
     Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedytElephant(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
     H.Wait();
     H.Dispose();
 });
            }

            return this;
        }

        //main initiation of hourse Brown
        private AllDraw InitiateAStarGreedythHourseBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            object oo = new object();
            lock (oo)
            {
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(HourseMidle, HourseHight, i =>

 {
     Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythHourse(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
     H.Wait();
     H.Dispose();
 });
            }

            return this;
        }

        //main initiation of Castle Brown
        private AllDraw InitiateAStarGreedythCastleBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            object oo = new object();
            lock (oo)
            {
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(CastleMidle, CastleHigh, i =>

 {
     Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythCastle(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
     H.Wait();
     H.Dispose();
 });
            }

            return this;
        }

        //main initiatiob of minister Brown
        private AllDraw InitiateAStarGreedythMinisterBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            object oo = new object();
            lock (oo)
            {
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(MinisterMidle, MinisterHigh, i =>

 {
     Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythMinister(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
     H.Wait();
     H.Dispose();
 });
            }

            return this;
        }

        //main initiation of king Brown
        private AllDraw InitiateAStarGreedythKingBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            object oo = new object();
            lock (oo)
            {
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(KingMidle, KingHigh, i =>

                 {
                     Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythKing(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
                     H.Wait();
                     H.Dispose();
                 });
            }

            return this;
        }

        private AllDraw InitiateAStarGreedythCastlingBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
             )
        {
            object oo = new object();
            lock (oo)
            {
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(0, 1, i =>

                 {
                     Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythCastling(-7, i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
                     H.Wait();
                     H.Dispose();
                 });
            }

            return this;
        }

        //boundry condition determistic method for break
        private bool FullBoundryConditionsSoldierIgnore(int ikk, int Order, int iAStarGreedy)
        {
            object O = new object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (SolderesOnTable == null)
                    {
                        return true;
                    }

                    if (ikk >= SolderesOnTable.Length)
                    {
                        return true;
                    }

                    if (SolderesOnTable[ikk] == null)
                    {
                        return true;
                    }

                    if (SolderesOnTable[ikk].LoseOcuuredatChiled == null)
                    {
                        return true;
                    }

                    if (SolderesOnTable[ikk].SoldierThinkingQuantum == null)
                    {
                        return true;
                    }

                    if (SolderesOnTable[ikk].SoldierThinkingQuantum[0] == null)
                    {
                        return true;
                    }

                    if (SolderesOnTable[ikk].SoldierThinkingQuantum[0].TableListSolder == null)
                    {
                        SolderesOnTable[ikk].SoldierThinkingQuantum[0].TableListSolder = new List<int[,]>();
                        SolderesOnTable[ikk].SoldierThinkingQuantum[0].RowColumnSoldier = new List<int[]>();
                        SolderesOnTable[ikk].SoldierThinkingQuantum[0].HitNumberSoldier = new List<int>();
                        SolderesOnTable[ikk].SoldierThinkingQuantum[0].HeuristicListSolder = new List<double[]>();
                        SolderesOnTable[ikk].SoldierThinkingQuantum[0].PenaltyRegardListSolder = new List<LearningMachine.QuantumAtamata>();
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }

        //boundry condition determistic method for break
        private bool FullBoundryConditionsElephantIgnore(int ikk, int Order, int iAStarGreedy)
        {
            object O = new object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (ElephantOnTable == null)
                    {
                        return true;
                    }

                    if (ikk >= ElephantOnTable.Length)
                    {
                        return true;
                    }

                    if (ElephantOnTable[ikk] == null)
                    {
                        return true;
                    }

                    if (ElephantOnTable[ikk].LoseOcuuredatChiled == null)
                    {
                        return true;
                    }

                    if (ElephantOnTable[ikk].ElefantThinkingQuantum == null)
                    {
                        return true;
                    }

                    if (ElephantOnTable[ikk].ElefantThinkingQuantum[0] == null)
                    {
                        return true;
                    }

                    if (ElephantOnTable[ikk].ElefantThinkingQuantum[0].TableListElefant == null)

                    {
                        ElephantOnTable[ikk].ElefantThinkingQuantum[0].TableListElefant = new List<int[,]>();
                        ElephantOnTable[ikk].ElefantThinkingQuantum[0].RowColumnElefant = new List<int[]>();
                        ElephantOnTable[ikk].ElefantThinkingQuantum[0].HitNumberElefant = new List<int>();
                        ElephantOnTable[ikk].ElefantThinkingQuantum[0].HeuristicListElefant = new List<double[]>();
                        ElephantOnTable[ikk].ElefantThinkingQuantum[0].PenaltyRegardListElefant = new List<LearningMachine.QuantumAtamata>();
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }

        //boundry condition determistic method for break
        private bool FullBoundryConditionsHourseIgnore(int ikk, int Order, int iAStarGreedy)
        {
            object O = new object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (HoursesOnTable == null)
                    {
                        return true;
                    }

                    if (ikk >= HoursesOnTable.Length)
                    {
                        return true;
                    }

                    if (HoursesOnTable[ikk] == null)
                    {
                        return true;
                    }

                    if (HoursesOnTable[ikk].LoseOcuuredatChiled == null)
                    {
                        return true;
                    }

                    if (HoursesOnTable[ikk].HourseThinkingQuantum == null)
                    {
                        return true;
                    }

                    if (HoursesOnTable[ikk].HourseThinkingQuantum[0] == null)
                    {
                        return true;
                    }

                    if (HoursesOnTable[ikk].HourseThinkingQuantum[0].TableListHourse == null)

                    {
                        HoursesOnTable[ikk].HourseThinkingQuantum[0].TableListHourse = new List<int[,]>();
                        HoursesOnTable[ikk].HourseThinkingQuantum[0].RowColumnHourse = new List<int[]>();
                        HoursesOnTable[ikk].HourseThinkingQuantum[0].HitNumberHourse = new List<int>();
                        HoursesOnTable[ikk].HourseThinkingQuantum[0].HeuristicListHourse = new List<double[]>();
                        HoursesOnTable[ikk].HourseThinkingQuantum[0].PenaltyRegardListHourse = new List<LearningMachine.QuantumAtamata>();
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }

        //boundry condition determistic method for break
        private bool FullBoundryConditionsCastleIgnore(int ikk, int Order, int iAStarGreedy)
        {
            object O = new object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (CastlesOnTable == null)
                    {
                        return true;
                    }

                    if (ikk >= CastlesOnTable.Length)
                    {
                        return true;
                    }

                    if (CastlesOnTable[ikk] == null)
                    {
                        return true;
                    }

                    if (CastlesOnTable[ikk].LoseOcuuredatChiled == null)
                    {
                        return true;
                    }

                    if (CastlesOnTable[ikk].CastleThinkingQuantum == null)
                    {
                        return true;
                    }

                    if (CastlesOnTable[ikk].CastleThinkingQuantum[0] == null)
                    {
                        return true;
                    }

                    if (CastlesOnTable[ikk].CastleThinkingQuantum[0].TableListCastle == null)
                    {
                        CastlesOnTable[ikk].CastleThinkingQuantum[0].TableListCastle = new List<int[,]>();
                        CastlesOnTable[ikk].CastleThinkingQuantum[0].RowColumnCastle = new List<int[]>();
                        CastlesOnTable[ikk].CastleThinkingQuantum[0].HitNumberCastle = new List<int>();
                        CastlesOnTable[ikk].CastleThinkingQuantum[0].HeuristicListCastle = new List<double[]>();
                        CastlesOnTable[ikk].CastleThinkingQuantum[0].PenaltyRegardListCastle = new List<LearningMachine.QuantumAtamata>();
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }

        //boundry condition determistic method for break
        private bool FullBoundryConditionsMinisterIgnore(int ikk, int Order, int iAStarGreedy)
        {
            object O = new object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (MinisterOnTable == null)
                    {
                        return true;
                    }

                    if (ikk >= MinisterOnTable.Length)
                    {
                        return true;
                    }

                    if (MinisterOnTable[ikk] == null)
                    {
                        return true;
                    }

                    if (MinisterOnTable[ikk].LoseOcuuredatChiled == null)
                    {
                        return true;
                    }

                    if (MinisterOnTable[ikk].MinisterThinkingQuantum == null)
                    {
                        return true;
                    }

                    if (MinisterOnTable[ikk].MinisterThinkingQuantum[0] == null)
                    {
                        return true;
                    }

                    if (MinisterOnTable[ikk].MinisterThinkingQuantum[0].TableListMinister == null)
                    {
                        MinisterOnTable[ikk].MinisterThinkingQuantum[0].TableListMinister = new List<int[,]>();
                        MinisterOnTable[ikk].MinisterThinkingQuantum[0].RowColumnMinister = new List<int[]>();
                        MinisterOnTable[ikk].MinisterThinkingQuantum[0].HitNumberMinister = new List<int>();
                        MinisterOnTable[ikk].MinisterThinkingQuantum[0].HeuristicListMinister = new List<double[]>();
                        MinisterOnTable[ikk].MinisterThinkingQuantum[0].PenaltyRegardListMinister = new List<LearningMachine.QuantumAtamata>();
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }

        //boundry condition determistic method for break
        private bool FullBoundryConditionsKingIgnore(int ikk, int Order, int iAStarGreedy)
        {
            object O = new object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (KingOnTable == null)
                    {
                        return true;
                    }

                    if (ikk >= KingOnTable.Length)
                    {
                        return true;
                    }

                    if (KingOnTable[ikk] == null)
                    {
                        return true;
                    }

                    if (KingOnTable[ikk].LoseOcuuredatChiled == null)
                    {
                        return true;
                    }

                    if (KingOnTable[ikk].KingThinkingQuantum == null)
                    {
                        return true;
                    }

                    if (KingOnTable[ikk].KingThinkingQuantum[0] == null)
                    {
                        return true;
                    }

                    if (KingOnTable[ikk].KingThinkingQuantum[0].TableListKing == null)
                    {
                        KingOnTable[ikk].KingThinkingQuantum[0].TableListKing = new List<int[,]>();
                        KingOnTable[ikk].KingThinkingQuantum[0].RowColumnKing = new List<int[]>();
                        KingOnTable[ikk].KingThinkingQuantum[0].HitNumberKing = new List<int>();
                        KingOnTable[ikk].KingThinkingQuantum[0].HeuristicListKing = new List<double[]>();
                        KingOnTable[ikk].KingThinkingQuantum[0].PenaltyRegardListKing = new List<LearningMachine.QuantumAtamata>();
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }

        private bool FullBoundryConditionsCastlingIgnore(int ikk, int Order, int iAStarGreedy)
        {
            object O = new object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (CastlingOnTable == null)
                    {
                        return true;
                    }

                    if (ikk >= CastlingOnTable.Length)
                    {
                        return true;
                    }

                    if (CastlingOnTable[ikk] == null)
                    {
                        return true;
                    }

                    if (CastlingOnTable[ikk].LoseOcuuredatChiled == null)
                    {
                        return true;
                    }

                    if (CastlingOnTable[ikk].CastlingThinking == null)
                    {
                        return true;
                    }

                    if (CastlingOnTable[ikk].CastlingThinking[0] == null)
                    {
                        return true;
                    }

                    if (CastlingOnTable[ikk].CastlingThinking[0].TableListCastling == null)
                    {
                        CastlingOnTable[ikk].CastlingThinking[0].TableListCastling = new List<int[,]>();
                        CastlingOnTable[ikk].CastlingThinking[0].RowColumnCastling = new List<int[]>();
                        CastlingOnTable[ikk].CastlingThinking[0].HitNumberCastling = new List<int>();
                        CastlingOnTable[ikk].CastlingThinking[0].HeuristicListCastling = new List<double[]>();
                        CastlingOnTable[ikk].CastlingThinking[0].PenaltyRegardListCastling = new List<LearningMachine.QuantumAtamata>();
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }

        //boundry condition determistic method for break
        private bool FullBoundryConditionsSoldier(int ikk, int Current, int Order, int iAStarGreedy)
        {
            object O = new object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (FullBoundryConditionsSoldierIgnore(ikk, Order, iAStarGreedy))
                    {
                        return false;
                    }

                    if (SolderesOnTable[ikk].LoseOcuuredatChiled[0] < 0 && (!AllowedSupTrue))
                    {
                        IS = true;
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }

        //boundry condition determistic method for break
        private bool FullBoundryConditionsElephant(int ikk, int Current, int Order, int iAStarGreedy)
        {
            object O = new object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (FullBoundryConditionsElephantIgnore(ikk, Order, iAStarGreedy))
                    {
                        return false;
                    }

                    if (ElephantOnTable[ikk].LoseOcuuredatChiled[0] < 0 && (!AllowedSupTrue))
                    {
                        IS = true;
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }

        //boundry condition determistic method for break
        private bool FullBoundryConditionsHourse(int ikk, int Current, int Order, int iAStarGreedy)
        {
            object O = new object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (FullBoundryConditionsHourseIgnore(ikk, Order, iAStarGreedy))
                    {
                        return false;
                    }

                    if (HoursesOnTable[ikk].LoseOcuuredatChiled[0] < 0 && (!AllowedSupTrue))
                    {
                        IS = true;
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }

        //boundry condition determistic method for break
        private bool FullBoundryConditionsCastle(int ikk, int Current, int Order, int iAStarGreedy)
        {
            object O = new object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (FullBoundryConditionsCastleIgnore(ikk, Order, iAStarGreedy))
                    {
                        return false;
                    }

                    if (CastlesOnTable[ikk].LoseOcuuredatChiled[0] < 0 && (!AllowedSupTrue))
                    {
                        IS = true;
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }

        //boundry condition determistic method for break
        private bool FullBoundryConditionsMinister(int ikk, int Current, int Order, int iAStarGreedy)
        {
            object O = new object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (FullBoundryConditionsMinisterIgnore(ikk, Order, iAStarGreedy))
                    {
                        return false;
                    }

                    if (MinisterOnTable[ikk].LoseOcuuredatChiled[0] < 0 && (!AllowedSupTrue))
                    {
                        IS = true;
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }

        //boundry condition determistic method for break
        private bool FullBoundryConditionsKing(int ikk, int Current, int Order, int iAStarGreedy)
        {
            object O = new object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (FullBoundryConditionsKingIgnore(ikk, Order, iAStarGreedy))
                    {
                        return false;
                    }

                    if (KingOnTable[ikk].LoseOcuuredatChiled[0] < 0 && (!AllowedSupTrue))
                    {
                        IS = true;
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }

        private bool FullBoundryConditionsCastling(int ikk, int Current, int Order, int iAStarGreedy)
        {
            object O = new object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (FullBoundryConditionsCastlingIgnore(ikk, Order, iAStarGreedy))
                    {
                        return false;
                    }

                    if (CastlingOnTable[ikk].LoseOcuuredatChiled[0] < 0 && (!AllowedSupTrue))
                    {
                        IS = true;
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }

        //boundry condition determistic method for break
        //boundry condition determistic method for break
        private bool FullBoundryConditions(int Current, int Order, int iAStarGreedy)
        {
            object O = new object();
            lock (O)
            {
                if (CalIdle == 2)
                {
                    return true;
                }

                bool IS = false;
                //if (!CompleteTreeDo)
                {
                    try
                    {
                        //heigth justice math and logic
                        /*   if (MaxAStarGreedy < MaxAStarGreedy + CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy))
                           {
                               MaxAStarGreedy = MaxAStarGreedy + CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy);
                           }
                           */
                        if (
                             /*(MaxAStarGreedy <= CurrentMaxLevel + PlatformHelper.ProcessorCount) &&*/
                             ((MaxAStarGreedy < StoreInitMaxAStarGreedy + PlatformHelper.ProcessorCount) || (CurrentMaxLevel < StoreInitMaxAStarGreedyEqual&&SStopInitMaxAStarGreedy)))// if (MaxAStarGreedy < indexStep * PlatformHelper.ProcessorCount)
                        {
                            MaxAStarGreedy = CurrentMaxLevel;
                        }
                        else
                        {
                            if (CurrentMaxLevel >= MaxAStarGreedy)
                            return true;
                        }

                        object Omm1 = new object();
                        lock (Omm1)
                        {
                            /*if (CurrentMaxLevel >= MaxAStarGreedy)
                                return;
                            else
                            {
                                //if (CurrentMaxLevel < CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy))
                                //CurrentMaxLevel = CurrentMaxLevel + 1;
                                if (CurrentMaxLevel < CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy))
                                     CurrentMaxLevel = CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy);
                            }*/
                            /* if (iAStarGreedy < 0 //&& iAStarGreedy < MaxDuringLevelThinkingCreation
                        )
                             {
                                 IS = true;
                             }*/
                        }
                        //gray
                        if (Order == 1)
                        {
                            IS = IS || FullBoundryConditionsGray(Current, Order, iAStarGreedy);
                            //when vicrory count satisfied
                            if ((ThinkingQuantumChess.FoundFirstMating > (MaxAStarGreedy)) && (!AllowedSupTrue)&&(!SStopInitMaxAStarGreedy)) //|| (SetDeptIgnore))
                            {
                                IS = true;
                            }
                        }
                        else
                        {
                            IS = IS || FullBoundryConditionsBrown(Current, Order, iAStarGreedy);
                            //when victory count satisfied
                            if ((ThinkingQuantumChess.FoundFirstMating > (MaxAStarGreedy)) && (!AllowedSupTrue)&&(!SStopInitMaxAStarGreedy)) //|| (SetDeptIgnore))
                            {
                                IS = true;
                            }
                        }
                        /*
                        //when nu,bers of computational leafs satisfied
                        if (((ThinkingQuantumChess.NumbersOfAllNode - AllDraw.NumberOfLeafComputation) > 100) && AllDraw.NumberOfLeafComputation != -1 && (!AllowedSupTrue))
                        {
                            IS = true;
                        }*/
                    }
                    catch (Exception t) { Log(t); }
                }
                /*else
                {
                    if (ThinkingQuantumChess.NumbersOfAllNode > CompleteNumber)
                    {
                        return true;
                    }

                    if (CompleteTreeCancel)
                    {
                        return true;
                    }
                }*/
                return IS;
            }
        }

        //boundry condition determistic method for break
        private bool FullBoundryConditionsBrown(int Current, int Order, int iAStarGreedy)
        {
            object O = new object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    //soldier
                    for (int ikk = SodierMidle; ikk < SodierHigh; ikk++)
                    {
                        IS = IS || FullBoundryConditionsSoldier(ikk, Current, Order, iAStarGreedy);
                    }
                    //elephant
                    for (int ikk = ElefantMidle; ikk < ElefantHigh; ikk++)
                    {
                        IS = IS || FullBoundryConditionsElephant(ikk, Current, Order, iAStarGreedy);
                    }
                    //hourse
                    for (int ikk = HourseMidle; ikk < HourseHight; ikk++)
                    {
                        IS = IS || FullBoundryConditionsHourse(ikk, Current, Order, iAStarGreedy);
                    }
                    //Castle
                    for (int ikk = CastleMidle; ikk < CastleHigh; ikk++)
                    {
                        IS = IS || FullBoundryConditionsCastle(ikk, Current, Order, iAStarGreedy);
                    }
                    //minister
                    for (int ikk = MinisterMidle; ikk < MinisterHigh; ikk++)
                    {
                        IS = IS || FullBoundryConditionsMinister(ikk, Current, Order, iAStarGreedy);
                    }
                    //king
                    for (int ikk = KingMidle; ikk < KingHigh; ikk++)
                    {
                        IS = IS || FullBoundryConditionsKing(ikk, Current, Order, iAStarGreedy);
                    }
                    for (int ikk = 0; ikk < 1; ikk++)
                    {
                        IS = IS || FullBoundryConditionsCastling(ikk, Current, Order, iAStarGreedy);
                    }
                    //when victory count satisfied
                    if ((ThinkingQuantumChess.FoundFirstMating > (MaxAStarGreedy)) && (!AllowedSupTrue)&&(!SStopInitMaxAStarGreedy)) //|| (SetDeptIgnore))
                    {
                        IS = true;
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }

        //boundry condition determistic method for break
        private bool FullBoundryConditionsGray(int Current, int Order, int iAStarGreedy)
        {
            object O = new object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    //soldier
                    for (int ikk = 0; ikk < SodierMidle; ikk++)
                    {
                        IS = IS || FullBoundryConditionsSoldier(ikk, Current, Order, iAStarGreedy);
                    }
                    //elephant
                    for (int ikk = 0; ikk < ElefantMidle; ikk++)
                    {
                        IS = IS || FullBoundryConditionsElephant(ikk, Current, Order, iAStarGreedy);
                    }
                    //hourse
                    for (int ikk = 0; ikk < HourseMidle; ikk++)
                    {
                        IS = IS || FullBoundryConditionsHourse(ikk, Current, Order, iAStarGreedy);
                    }
                    //Castle
                    for (int ikk = 0; ikk < CastleMidle; ikk++)
                    {
                        IS = IS || FullBoundryConditionsCastle(ikk, Current, Order, iAStarGreedy);
                    }
                    //minister
                    for (int ikk = 0; ikk < MinisterMidle; ikk++)
                    {
                        IS = IS || FullBoundryConditionsMinister(ikk, Current, Order, iAStarGreedy);
                    }
                    //king
                    for (int ikk = 0; ikk < KingMidle; ikk++)
                    {
                        IS = IS || FullBoundryConditionsKing(ikk, Current, Order, iAStarGreedy);
                    }
                    for (int ikk = 0; ikk < 1; ikk++)
                    {
                        IS = IS || FullBoundryConditionsCastling(ikk, Current, Order, iAStarGreedy);
                    }
                    //when vicrory count satisfied
                    if ((ThinkingQuantumChess.FoundFirstMating > (MaxAStarGreedy)) && (!AllowedSupTrue)&&(!SStopInitMaxAStarGreedy)) //|| (SetDeptIgnore))
                    {
                        IS = true;
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }

        //initiation setdrawfounding tow stage computational method
        public bool InitiateAStarGreedytCreationThinking(int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
     )
        {
            object o = new object();
            lock (o)
            {
                if (ThinkingAllowed == null)
                {
                    ThinkingAllowed = new bool[4];
                }

                for (int iii = 0; iii < 14; iii++)
                {
                    ThinkingAllowed[iii] = true;
                }

                int DummyOrder = new int();
                DummyOrder = Order;
                int DummyCurrentOrder = new int();
                DummyCurrentOrder = ChessRules.CurrentOrder;
                //#pragma warning disable CS0219 // The variable 'ik' is assigned but its value is never used
#pragma warning disable CS0219 // The variable 'ik' is assigned but its value is never used
                int i = 0, ik = 0;
#pragma warning restore CS0219 // The variable 'ik' is assigned but its value is never used
                //#pragma warning restore CS0219 // The variable 'ik' is assigned but its value is never used
                int j = 0;
                int[,] Table = new int[8, 8];
                for (int iii = 0; iii < 8; iii++)
                {
                    for (int jjj = 0; jjj < 8; jjj++)
                    {
                        Table[iii, jjj] = Tab[iii, jjj];
                    }
                }

                AllDraw thiB = AStarGreedyString;
                if (IsAtLeastAllObjectIsNull())
                {
                    TableList.Clear();
                    TableList.Add(CloneATable(Table));
                    SetRowColumn(0);
                    IsCurrentDraw = true;
                }
                AStarGreedyString = thiB;
                //If Order is Gray.
                if (Order == 1)
                {
                    Task<bool> array1 = Task.Factory.StartNew(() => InitiateAStarGreedytCreationThinkingGray(DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, j, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));

                    array1.Wait();
                    array1.Dispose();
                }
                else//Brown Order Considarations.
                {
                    Task<bool> array1 = Task.Factory.StartNew(() => InitiateAStarGreedytCreationThinkingBrown(DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, j, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));

                    array1.Wait();
                    array1.Dispose();
                }
            }

            return true;
        }

        public bool InitiateAStarGreedytCreationThinkingGray(int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, int i, int j, Color a, int[,] Table, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
)
        {
            object o = new object();
            lock (o)
            {
                int i1 = i, j1 = j;
                int[,] Tabl = CloneATable(Table);
                int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                bool TB1 = TB;
                Color aa = a;
                Task output = Task.Factory.StartNew(() =>
                {
                    //if (!feedCancellationTokenSource.IsCancellationRequested)
                    {
                        ParallelOptions po = new ParallelOptions
                        {
                            MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                        }; Parallel.Invoke(() =>
 {
     //For All Gray Soldier Objects.
     object O = new object();
     lock (O)
     {
         Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedytSodlerGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     //For All Gray Elephant Objects.
     object O = new object();
     lock (O)
     {
         Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedytElephantGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     //For All Gray Hourse Objects.
     object O = new object();
     lock (O)
     {
         Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythHourseGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     object O = new object();
     lock (O)
     {
         Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythCastleGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     object O = new object();
     lock (O)
     {
         Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythMinisterGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }
 , () =>
 {
     object O = new object();
     lock (O)
     {
         Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythKingGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     object O = new object();
     lock (O)
     {
         Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythCastlingGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 });
                    }
                });
                output.Wait(); output.Dispose();
            }
            return true;
        }

        public bool InitiateAStarGreedytCreationThinkingBrown(int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, int i, int j, Color a, int[,] Table, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
)
        {
            object o = new object();
            lock (o)
            {
                int i1 = i, j1 = j;
                int[,] Tabl = CloneATable(Table);
                int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                bool TB1 = TB;
                Color aa = a;
                //If Order is Gray.
                Task output = Task.Factory.StartNew(() =>
                {
                    //if (!feedCancellationTokenSource.IsCancellationRequested)
                    {
                        ParallelOptions po = new ParallelOptions
                        {
                            MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                        }; Parallel.Invoke(() =>
 {
     //For All Gray Soldier Objects.
     object O = new object();
     lock (O)
     {
         Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythSoldierBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     //For All Gray Elephant Objects.
     object O = new object();
     lock (O)
     {
         Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythElephantBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     //For All Gray Hourse Objects.
     object O = new object();
     lock (O)
     {
         Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythHourseBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     object O = new object();
     lock (O)
     {
         Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythCastleBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     object O = new object();
     lock (O)
     {
         Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythMinisterBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     object O = new object();
     lock (O)
     {
         Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythKingBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     object O = new object();
     lock (O)
     {
         Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedythCastlingBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 });
                    }
                });
                output.Wait(); output.Dispose();
            }
            return true;
        }

        public bool BlitzNotValidFullGameThinkingTreePartFour(int ik, int Order, int kind, ThinkingQuantumChess obj, int j)
        {
            object oo = new object();
            lock (oo)
            {
                bool Act = false;
                //soldier
                if (kind == 1)
                {
                    //when valid
                    Act = BlitzNotValidFullGameThinkingTreePartFourSoldier(ik, Order, obj, j);
                }
                else if (kind == 2)//elephant
                {
                    //when valid

                    Act = BlitzNotValidFullGameThinkingTreePartFourElephant(ik, Order, obj, j);
                }
                else if (kind == 3)//hourse
                {
                    //when valid

                    Act = BlitzNotValidFullGameThinkingTreePartFourHourse(ik, Order, obj, j);
                }
                else if (kind == 4)//Castle
                {
                    //when valid

                    Act = BlitzNotValidFullGameThinkingTreePartFourCastle(ik, Order, obj, j);
                }
                else if (kind == 5)//minister
                {
                    //when valid ThinkingChess

                    Act = BlitzNotValidFullGameThinkingTreePartFourMinister(ik, Order, obj, j);
                }
                else if (kind == 6)//king
                {
                    //when valid

                    Act = BlitzNotValidFullGameThinkingTreePartFourKing(ik, Order, obj, j);
                }
                else if (kind == 7 || kind == -7)//king
                {
                    //when valid
                    Act = BlitzNotValidFullGameThinkingTreePartFourCastling(ik, Order, obj, j);
                }
                return Act;
            }
        }

        private bool BlitzNotValidFullGameThinkingTreePartFourSoldier(int ik, int Order, ThinkingQuantumChess obj, int j)
        {
            object oo = new object();
            lock (oo)
            {
                bool Act = false;
                if (obj.HeuristicListSolder[j].Length != 10)
                {
                    return Act;
                }
                //when valid
                SolderesOnTable[ik].SoldierThinkingQuantum[0].TableListSolder.Add(obj.TableListSolder[j]);
                SolderesOnTable[ik].SoldierThinkingQuantum[0].HeuristicListSolder.Add(obj.HeuristicListSolder[j]);
                SolderesOnTable[ik].SoldierThinkingQuantum[0].RowColumnSoldier.Add(obj.RowColumnSoldier[j]);
                SolderesOnTable[ik].SoldierThinkingQuantum[0].HitNumberSoldier.Add(obj.HitNumberSoldier[j]);
                SolderesOnTable[ik].SoldierThinkingQuantum[0].PenaltyRegardListSolder.Add(obj.PenaltyRegardListSolder[j]);
                SolderesOnTable[ik].SoldierThinkingQuantum[0].KishSelf.Add(obj.KishSelf[j]);
                SolderesOnTable[ik].SoldierThinkingQuantum[0].KishEnemy.Add(obj.KishEnemy[j]);
                SolderesOnTable[ik].SoldierThinkingQuantum[0].LoseChiled.Add(obj.LoseChiled[j]);
                SolderesOnTable[ik].SoldierThinkingQuantum[0].WinChiled.Add(obj.WinChiled[j]);
                SolderesOnTable[ik].SoldierThinkingQuantum[0].IsSup.Add(obj.IsSup[j]);
                SolderesOnTable[ik].SoldierThinkingQuantum[0].IsSupHu.Add(obj.IsSupHu[j]);
                SolderesOnTable[ik].SoldierThinkingQuantum[0].IsThereCheckOfEnemy.Add(obj.IsThereCheckOfEnemy[j]);
                SolderesOnTable[ik].SoldierThinkingQuantum[0].IsThereCheckOfSelf.Add(obj.IsThereCheckOfSelf[j]);
                SolderesOnTable[ik].SoldierThinkingQuantum[0].IsThereMateOfEnemy.Add(obj.IsThereMateOfEnemy[j]);
                SolderesOnTable[ik].SoldierThinkingQuantum[0].IsThereMateOfSelf.Add(obj.IsThereMateOfSelf[j]);
                Act = true;

                return Act;
            }
        }

        private bool BlitzNotValidFullGameThinkingTreePartFourElephant(int ik, int Order, ThinkingQuantumChess obj, int j)
        {
            object oo = new object();
            lock (oo)
            {
                bool Act = false;

                if (obj.HeuristicListElefant[j].Length != 10)
                {
                    return Act;
                }
                //when valid

                ElephantOnTable[ik].ElefantThinkingQuantum[0].TableListElefant.Add(obj.TableListElefant[j]);
                ElephantOnTable[ik].ElefantThinkingQuantum[0].HeuristicListElefant.Add(obj.HeuristicListElefant[j]);
                ElephantOnTable[ik].ElefantThinkingQuantum[0].RowColumnElefant.Add(obj.RowColumnElefant[j]);
                ElephantOnTable[ik].ElefantThinkingQuantum[0].HitNumberElefant.Add(obj.HitNumberElefant[j]);
                ElephantOnTable[ik].ElefantThinkingQuantum[0].PenaltyRegardListElefant.Add(obj.PenaltyRegardListElefant[j]);
                ElephantOnTable[ik].ElefantThinkingQuantum[0].KishSelf.Add(obj.KishSelf[j]);
                ElephantOnTable[ik].ElefantThinkingQuantum[0].KishEnemy.Add(obj.KishEnemy[j]);
                ElephantOnTable[ik].ElefantThinkingQuantum[0].LoseChiled.Add(obj.LoseChiled[j]);
                ElephantOnTable[ik].ElefantThinkingQuantum[0].WinChiled.Add(obj.WinChiled[j]);
                ElephantOnTable[ik].ElefantThinkingQuantum[0].IsSup.Add(obj.IsSup[j]);
                ElephantOnTable[ik].ElefantThinkingQuantum[0].IsSupHu.Add(obj.IsSupHu[j]);
                ElephantOnTable[ik].ElefantThinkingQuantum[0].IsThereCheckOfEnemy.Add(obj.IsThereCheckOfEnemy[j]);
                ElephantOnTable[ik].ElefantThinkingQuantum[0].IsThereCheckOfSelf.Add(obj.IsThereCheckOfSelf[j]);
                ElephantOnTable[ik].ElefantThinkingQuantum[0].IsThereMateOfEnemy.Add(obj.IsThereMateOfEnemy[j]);
                ElephantOnTable[ik].ElefantThinkingQuantum[0].IsThereMateOfSelf.Add(obj.IsThereMateOfSelf[j]);

                Act = true;

                return Act;
            }
        }

        private bool BlitzNotValidFullGameThinkingTreePartFourHourse(int ik, int Order, ThinkingQuantumChess obj, int j)
        {
            object oo = new object();
            lock (oo)
            {
                bool Act = false;

                if (obj.HeuristicListHourse[j].Length != 10)
                {
                    return Act;
                }
                //when valid

                HoursesOnTable[ik].HourseThinkingQuantum[0].TableListHourse.Add(obj.TableListHourse[j]);
                HoursesOnTable[ik].HourseThinkingQuantum[0].HeuristicListHourse.Add(obj.HeuristicListHourse[j]);
                HoursesOnTable[ik].HourseThinkingQuantum[0].RowColumnHourse.Add(obj.RowColumnHourse[j]);
                HoursesOnTable[ik].HourseThinkingQuantum[0].HitNumberHourse.Add(obj.HitNumberHourse[j]);
                HoursesOnTable[ik].HourseThinkingQuantum[0].PenaltyRegardListHourse.Add(obj.PenaltyRegardListHourse[j]);
                HoursesOnTable[ik].HourseThinkingQuantum[0].KishSelf.Add(obj.KishSelf[j]);
                HoursesOnTable[ik].HourseThinkingQuantum[0].KishEnemy.Add(obj.KishEnemy[j]);
                HoursesOnTable[ik].HourseThinkingQuantum[0].LoseChiled.Add(obj.LoseChiled[j]);
                HoursesOnTable[ik].HourseThinkingQuantum[0].WinChiled.Add(obj.WinChiled[j]);
                HoursesOnTable[ik].HourseThinkingQuantum[0].IsSup.Add(obj.IsSup[j]);
                HoursesOnTable[ik].HourseThinkingQuantum[0].IsSupHu.Add(obj.IsSupHu[j]);
                HoursesOnTable[ik].HourseThinkingQuantum[0].IsThereCheckOfEnemy.Add(obj.IsThereCheckOfEnemy[j]);
                HoursesOnTable[ik].HourseThinkingQuantum[0].IsThereCheckOfSelf.Add(obj.IsThereCheckOfSelf[j]);
                HoursesOnTable[ik].HourseThinkingQuantum[0].IsThereMateOfEnemy.Add(obj.IsThereMateOfEnemy[j]);
                HoursesOnTable[ik].HourseThinkingQuantum[0].IsThereMateOfSelf.Add(obj.IsThereMateOfSelf[j]);
                Act = true;
                return Act;
            }
        }

        private bool BlitzNotValidFullGameThinkingTreePartFourCastle(int ik, int Order, ThinkingQuantumChess obj, int j)
        {
            object oo = new object();
            lock (oo)
            {
                bool Act = false;

                if (obj.HeuristicListCastle[j].Length != 10)
                {
                    return Act;
                }
                //when valid

                CastlesOnTable[ik].CastleThinkingQuantum[0].TableListCastle.Add(obj.TableListCastle[j]);
                CastlesOnTable[ik].CastleThinkingQuantum[0].HeuristicListCastle.Add(obj.HeuristicListCastle[j]);
                CastlesOnTable[ik].CastleThinkingQuantum[0].RowColumnCastle.Add(obj.RowColumnCastle[j]);
                CastlesOnTable[ik].CastleThinkingQuantum[0].HitNumberCastle.Add(obj.HitNumberMinister[j]);
                CastlesOnTable[ik].CastleThinkingQuantum[0].PenaltyRegardListCastle.Add(obj.PenaltyRegardListCastle[j]);
                CastlesOnTable[ik].CastleThinkingQuantum[0].KishSelf.Add(obj.KishSelf[j]);
                CastlesOnTable[ik].CastleThinkingQuantum[0].KishEnemy.Add(obj.KishEnemy[j]);
                CastlesOnTable[ik].CastleThinkingQuantum[0].LoseChiled.Add(obj.LoseChiled[j]);
                CastlesOnTable[ik].CastleThinkingQuantum[0].WinChiled.Add(obj.WinChiled[j]);
                CastlesOnTable[ik].CastleThinkingQuantum[0].IsSup.Add(obj.IsSup[j]);
                CastlesOnTable[ik].CastleThinkingQuantum[0].IsSupHu.Add(obj.IsSupHu[j]);
                CastlesOnTable[ik].CastleThinkingQuantum[0].IsThereCheckOfEnemy.Add(obj.IsThereCheckOfEnemy[j]);
                CastlesOnTable[ik].CastleThinkingQuantum[0].IsThereCheckOfSelf.Add(obj.IsThereCheckOfSelf[j]);
                CastlesOnTable[ik].CastleThinkingQuantum[0].IsThereMateOfEnemy.Add(obj.IsThereMateOfEnemy[j]);
                CastlesOnTable[ik].CastleThinkingQuantum[0].IsThereMateOfSelf.Add(obj.IsThereMateOfSelf[j]);
                Act = true;

                return Act;
            }
        }

        private bool BlitzNotValidFullGameThinkingTreePartFourMinister(int ik, int Order, ThinkingQuantumChess obj, int j)
        {
            object oo = new object();
            lock (oo)
            {
                bool Act = false;

                if (obj.HeuristicListMinister[j].Length != 10)
                {
                    return Act;
                }
                //when valid

                MinisterOnTable[ik].MinisterThinkingQuantum[0].TableListMinister.Add(obj.TableListCastling[j]);
                MinisterOnTable[ik].MinisterThinkingQuantum[0].HeuristicListMinister.Add(obj.HeuristicListMinister[j]);
                MinisterOnTable[ik].MinisterThinkingQuantum[0].RowColumnMinister.Add(obj.RowColumnMinister[j]);
                MinisterOnTable[ik].MinisterThinkingQuantum[0].HitNumberMinister.Add(obj.HitNumberMinister[j]);
                MinisterOnTable[ik].MinisterThinkingQuantum[0].PenaltyRegardListMinister.Add(obj.PenaltyRegardListMinister[j]);
                MinisterOnTable[ik].MinisterThinkingQuantum[0].KishSelf.Add(obj.KishSelf[j]);
                MinisterOnTable[ik].MinisterThinkingQuantum[0].KishEnemy.Add(obj.KishEnemy[j]);
                MinisterOnTable[ik].MinisterThinkingQuantum[0].LoseChiled.Add(obj.LoseChiled[j]);
                MinisterOnTable[ik].MinisterThinkingQuantum[0].WinChiled.Add(obj.WinChiled[j]);
                MinisterOnTable[ik].MinisterThinkingQuantum[0].IsSup.Add(obj.IsSup[j]);
                MinisterOnTable[ik].MinisterThinkingQuantum[0].IsSupHu.Add(obj.IsSupHu[j]);
                MinisterOnTable[ik].MinisterThinkingQuantum[0].IsThereCheckOfEnemy.Add(obj.IsThereCheckOfEnemy[j]);
                MinisterOnTable[ik].MinisterThinkingQuantum[0].IsThereCheckOfSelf.Add(obj.IsThereCheckOfSelf[j]);
                MinisterOnTable[ik].MinisterThinkingQuantum[0].IsThereMateOfEnemy.Add(obj.IsThereMateOfEnemy[j]);
                MinisterOnTable[ik].MinisterThinkingQuantum[0].IsThereMateOfSelf.Add(obj.IsThereMateOfSelf[j]);
                Act = true;

                return Act;
            }
        }

        private bool BlitzNotValidFullGameThinkingTreePartFourKing(int ik, int Order, ThinkingQuantumChess obj, int j)
        {
            object oo = new object();
            lock (oo)
            {
                bool Act = false;

                if (obj.HeuristicListKing[j].Length != 10)
                {
                    return Act;
                }
                //when valid

                KingOnTable[ik].KingThinkingQuantum[0].TableListKing.Add(obj.TableListKing[j]);
                KingOnTable[ik].KingThinkingQuantum[0].HeuristicListKing.Add(obj.HeuristicListKing[j]);
                KingOnTable[ik].KingThinkingQuantum[0].RowColumnKing.Add(obj.RowColumnKing[j]);
                KingOnTable[ik].KingThinkingQuantum[0].HitNumberKing.Add(obj.HitNumberKing[j]);
                KingOnTable[ik].KingThinkingQuantum[0].PenaltyRegardListKing.Add(obj.PenaltyRegardListKing[j]);
                KingOnTable[ik].KingThinkingQuantum[0].KishSelf.Add(obj.KishSelf[j]);
                KingOnTable[ik].KingThinkingQuantum[0].KishEnemy.Add(obj.KishEnemy[j]);
                KingOnTable[ik].KingThinkingQuantum[0].LoseChiled.Add(obj.LoseChiled[j]);
                KingOnTable[ik].KingThinkingQuantum[0].WinChiled.Add(obj.WinChiled[j]);
                KingOnTable[ik].KingThinkingQuantum[0].IsSup.Add(obj.IsSup[j]);
                KingOnTable[ik].KingThinkingQuantum[0].IsSupHu.Add(obj.IsSupHu[j]);
                KingOnTable[ik].KingThinkingQuantum[0].IsThereCheckOfEnemy.Add(obj.IsThereCheckOfEnemy[j]);
                KingOnTable[ik].KingThinkingQuantum[0].IsThereCheckOfSelf.Add(obj.IsThereCheckOfSelf[j]);
                KingOnTable[ik].KingThinkingQuantum[0].IsThereMateOfEnemy.Add(obj.IsThereMateOfEnemy[j]);
                KingOnTable[ik].KingThinkingQuantum[0].IsThereMateOfSelf.Add(obj.IsThereMateOfSelf[j]);
                Act = true;

                return Act;
            }
        }

        private bool BlitzNotValidFullGameThinkingTreePartFourCastling(int ik, int Order, ThinkingQuantumChess obj, int j)
        {
            object oo = new object();
            lock (oo)
            {
                bool Act = false;

                if (obj.HeuristicListCastling[j].Length != 10)
                {
                    return Act;
                }
                //when valid

                CastlingOnTable[ik].CastlingThinking[0].TableListCastling.Add(obj.TableListCastling[j]);
                CastlingOnTable[ik].CastlingThinking[0].HeuristicListCastling.Add(obj.HeuristicListCastling[j]);
                CastlingOnTable[ik].CastlingThinking[0].RowColumnCastling.Add(obj.RowColumnCastling[j]);
                CastlingOnTable[ik].CastlingThinking[0].HitNumberCastling.Add(obj.HitNumberCastling[j]);
                CastlingOnTable[ik].CastlingThinking[0].PenaltyRegardListCastling.Add(obj.PenaltyRegardListCastling[j]);
                CastlingOnTable[ik].CastlingThinking[0].KishSelf.Add(obj.KishSelf[j]);
                CastlingOnTable[ik].CastlingThinking[0].KishEnemy.Add(obj.KishEnemy[j]);
                CastlingOnTable[ik].CastlingThinking[0].LoseChiled.Add(obj.LoseChiled[j]);
                CastlingOnTable[ik].CastlingThinking[0].WinChiled.Add(obj.WinChiled[j]);
                CastlingOnTable[ik].CastlingThinking[0].IsSup.Add(obj.IsSup[j]);
                CastlingOnTable[ik].CastlingThinking[0].IsSupHu.Add(obj.IsSupHu[j]);
                CastlingOnTable[ik].CastlingThinking[0].IsThereCheckOfEnemy.Add(obj.IsThereCheckOfEnemy[j]);
                CastlingOnTable[ik].CastlingThinking[0].IsThereCheckOfSelf.Add(obj.IsThereCheckOfSelf[j]);
                CastlingOnTable[ik].CastlingThinking[0].IsThereMateOfEnemy.Add(obj.IsThereMateOfEnemy[j]);
                CastlingOnTable[ik].CastlingThinking[0].IsThereMateOfSelf.Add(obj.IsThereMateOfSelf[j]);
                Act = true;
                return Act;
            }
        }

        public bool MergeJungleTree(AllDraw jungle)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                Task output = Task.Factory.StartNew(() =>
                {
                    ParallelOptions po = new ParallelOptions
                    {
                        MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                    }; Parallel.Invoke(() =>
                     {
                         object o = new object();
                         lock (o)
                         {
                             ParallelOptions poo = new ParallelOptions
                             {
                                 MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                             }; Parallel.For(0, jungle.SodierHigh, p =>
                             {
                                 Act = Act || MergeJungleTreeSoldier(jungle, p);
                             });
                         }
                     },
                     () =>
                     {
                         object o = new object();
                         lock (o)
                         {
                             ParallelOptions poo = new ParallelOptions
                             {
                                 MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                             }; Parallel.For(0, jungle.ElefantHigh, p =>
                             {
                                 Act = Act || MergeJungleTreeElephant(jungle, p);
                             });
                         }
                     },
                     () =>
                     {
                         object o = new object();
                         lock (o)
                         {
                             ParallelOptions poo = new ParallelOptions
                             {
                                 MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                             }; Parallel.For(0, jungle.HourseHight, p =>
                             {
                                 Act = Act || MergeJungleTreeHhourse(jungle, p);
                             });
                         }
                     }, () =>
                     {
                         object o = new object();
                         lock (o)
                         {
                             ParallelOptions poo = new ParallelOptions
                             {
                                 MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                             }; Parallel.For(0, jungle.CastleHigh, p =>
                             {
                                 Act = Act || MergeJungleTreeCastle(jungle, p);
                             });
                         }
                     },
                     () =>
                     {
                         object o = new object();
                         lock (o)
                         {
                             ParallelOptions poo = new ParallelOptions
                             {
                                 MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                             }; Parallel.For(0, jungle.MinisterHigh, p =>
                             {
                                 Act = Act || MergeJungleTreeMinister(jungle, p);
                             });
                         }
                     }, () =>
                     {
                         object o = new object();
                         lock (o)
                         {
                             ParallelOptions poo = new ParallelOptions
                             {
                                 MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                             }; Parallel.For(0, jungle.KingHigh, p =>
                             {
                                 Act = Act || MergeJungleTreeKing(jungle, p);
                             });
                         }
                     },
                     () =>
                     {
                         object o = new object();
                         lock (o)
                         {
                             ParallelOptions poo = new ParallelOptions
                             {
                                 MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                             }; Parallel.For(0, 1, p =>
                             {
                                 Act = Act || MergeJungleTreeCastling(jungle, p);
                             });
                         }
                     });
                });
                output.Wait();
                output.Dispose();
            }
            return Act;
        }

        public bool MergeJungleTreeSoldier(AllDraw jungle, int p)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                if (jungle.SolderesOnTable != null)
                {
                    if (jungle.SolderesOnTable[p] != null)
                    {
                        if (jungle.SolderesOnTable[p].SoldierThinkingQuantum != null)
                        {
                            if (jungle.SolderesOnTable[p].SoldierThinkingQuantum[0] != null)
                            {
                                if (jungle.SolderesOnTable[p].SoldierThinkingQuantum[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < jungle.SolderesOnTable[p].SoldierThinkingQuantum[0].AStarGreedy.Count; k++)
                                    {
                                        Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || MergeJungleTree(jungle, p, k, 1));
                                        outputH.Wait();
                                        outputH.Dispose();
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }
            }
            return Act;
        }

        public bool MergeJungleTreeElephant(AllDraw jungle, int p)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                if (jungle.ElephantOnTable != null)
                {
                    if (jungle.ElephantOnTable[p] != null)
                    {
                        if (jungle.ElephantOnTable[p].ElefantThinkingQuantum != null)
                        {
                            if (jungle.ElephantOnTable[p].ElefantThinkingQuantum[0] != null)
                            {
                                if (jungle.ElephantOnTable[p].ElefantThinkingQuantum[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < jungle.ElephantOnTable[p].ElefantThinkingQuantum[0].AStarGreedy.Count; k++)
                                    {
                                        Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || MergeJungleTree(jungle, p, k, 2));
                                        outputH.Wait();
                                        outputH.Dispose();
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }
            }
            return Act;
        }

        public bool MergeJungleTreeHhourse(AllDraw jungle, int p)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                if (jungle.HoursesOnTable != null)
                {
                    if (jungle.HoursesOnTable[p] != null)
                    {
                        if (jungle.HoursesOnTable[p].HourseThinkingQuantum != null)
                        {
                            if (jungle.HoursesOnTable[p].HourseThinkingQuantum[0] != null)
                            {
                                if (jungle.HoursesOnTable[p].HourseThinkingQuantum[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < jungle.HoursesOnTable[p].HourseThinkingQuantum[0].AStarGreedy.Count; k++)
                                    {
                                        Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || MergeJungleTree(jungle, p, k, 3));
                                        outputH.Wait();
                                        outputH.Dispose();
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }
            }
            return Act;
        }

        public bool MergeJungleTreeCastle(AllDraw jungle, int p)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                if (jungle.CastlesOnTable != null)
                {
                    if (jungle.CastlesOnTable[p] != null)
                    {
                        if (jungle.CastlesOnTable[p].CastleThinkingQuantum != null)
                        {
                            if (jungle.CastlesOnTable[p].CastleThinkingQuantum[0] != null)
                            {
                                if (jungle.CastlesOnTable[p].CastleThinkingQuantum[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < jungle.CastlesOnTable[p].CastleThinkingQuantum[0].AStarGreedy.Count; k++)
                                    {
                                        Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || MergeJungleTree(jungle, p, k, 4));
                                        outputH.Wait();
                                        outputH.Dispose();
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }
            }
            return Act;
        }

        public bool MergeJungleTreeMinister(AllDraw jungle, int p)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                if (jungle.MinisterOnTable != null)
                {
                    if (jungle.MinisterOnTable[p] != null)
                    {
                        if (jungle.MinisterOnTable[p].MinisterThinkingQuantum != null)
                        {
                            if (jungle.MinisterOnTable[p].MinisterThinkingQuantum[0] != null)
                            {
                                if (jungle.MinisterOnTable[p].MinisterThinkingQuantum[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < jungle.MinisterOnTable[p].MinisterThinkingQuantum[0].AStarGreedy.Count; k++)
                                    {
                                        Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || MergeJungleTree(jungle, p, k, 5));
                                        outputH.Wait();
                                        outputH.Dispose();
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }
            }
            return Act;
        }

        public bool MergeJungleTreeKing(AllDraw jungle, int p)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                if (jungle.KingOnTable != null)
                {
                    if (jungle.KingOnTable[p] != null)
                    {
                        if (jungle.KingOnTable[p].KingThinkingQuantum != null)
                        {
                            if (jungle.KingOnTable[p].KingThinkingQuantum[0] != null)
                            {
                                if (jungle.KingOnTable[p].KingThinkingQuantum[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < jungle.KingOnTable[p].KingThinkingQuantum[0].AStarGreedy.Count; k++)
                                    {
                                        Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || MergeJungleTree(jungle, p, k, 6));
                                        outputH.Wait();
                                        outputH.Dispose();
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }
            }
            return Act;
        }

        public bool MergeJungleTreeCastling(AllDraw jungle, int p)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                if (jungle.CastlingOnTable != null)
                {
                    if (jungle.CastlingOnTable[p] != null)
                    {
                        if (jungle.CastlingOnTable[p].CastlingThinking != null)
                        {
                            if (jungle.CastlingOnTable[p].CastlingThinking[0] != null)
                            {
                                if (jungle.CastlingOnTable[p].CastlingThinking[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < jungle.CastlingOnTable[p].CastlingThinking[0].AStarGreedy.Count; k++)
                                    {
                                        Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || MergeJungleTree(jungle, p, k, 7));
                                        outputH.Wait();
                                        outputH.Dispose();
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }
            }
            return Act;
        }

        private bool MergeJungleTree(AllDraw jungle, int i, int j, int kindA)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                if (kindA == 1)
                {
                    Act = Act || MergeJungleTreeSoldier(jungle, i, j);
                }
                else
              if (kindA == 2)
                {
                    Act = Act || MergeJungleTreeElephant(jungle, i, j);
                }
                else
                if (kindA == 3)
                {
                    Act = Act || MergeJungleTreeHourse(jungle, i, j);
                }
                else
                     if (kindA == 4)
                {
                    Act = Act || MergeJungleTreeCastle(jungle, i, j);
                }
                else
                if (kindA == 5)
                {
                    Act = Act || MergeJungleTreeMinister(jungle, i, j);
                }
                else
                if (kindA == 6)
                {
                    Act = Act || MergeJungleTreeKing(jungle, i, j);
                }
                else
                if (kindA == 7 || kindA == -7)
                {
                    Act = Act || MergeJungleTreeCastling(jungle, i, j);
                }
            }

            Task output = Task.Factory.StartNew(() =>
            {
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.Invoke(() =>
                 {
                     object o = new object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions
                         {
                             MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                         }; Parallel.For(0, SodierHigh, p =>
                         {
                             if (SolderesOnTable != null)
                             {
                                 if (SolderesOnTable[p] != null)
                                 {
                                     if (SolderesOnTable[p].SoldierThinkingQuantum != null)
                                     {
                                         if (SolderesOnTable[p].SoldierThinkingQuantum[0] != null)
                                         {
                                             if (SolderesOnTable[p].SoldierThinkingQuantum[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < SolderesOnTable[p].SoldierThinkingQuantum[0].AStarGreedy.Count; k++)
                                                 {
                                                     Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || SolderesOnTable[p].SoldierThinkingQuantum[0].AStarGreedy[k].MergeJungleTree(jungle.SolderesOnTable[p].SoldierThinkingQuantum[0].AStarGreedy[k], p, k, 1));
                                                     outputH.Wait();
                                                     outputH.Dispose();
                                                 }
                                             }
                                             else
                                             {
                                                 return;
                                             }
                                         }
                                         else
                                         {
                                             return;
                                         }
                                     }
                                     else
                                     {
                                         return;
                                     }
                                 }
                                 else
                                 {
                                     return;
                                 }
                             }
                             else
                             {
                                 return;
                             }
                         });
                     }
                 },
                 () =>
                 {
                     object o = new object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions
                         {
                             MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                         }; Parallel.For(0, ElefantHigh, p =>
                         {
                             if (ElephantOnTable != null)
                             {
                                 if (ElephantOnTable[p] != null)
                                 {
                                     if (ElephantOnTable[p].ElefantThinkingQuantum != null)
                                     {
                                         if (ElephantOnTable[p].ElefantThinkingQuantum[0] != null)
                                         {
                                             if (ElephantOnTable[p].ElefantThinkingQuantum[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < ElephantOnTable[p].ElefantThinkingQuantum[0].AStarGreedy.Count; k++)
                                                 {
                                                     Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || ElephantOnTable[p].ElefantThinkingQuantum[0].AStarGreedy[k].MergeJungleTree(jungle.ElephantOnTable[p].ElefantThinkingQuantum[0].AStarGreedy[k], p, k, 2));
                                                     outputH.Wait();
                                                     outputH.Dispose();
                                                 }
                                             }
                                             else
                                             {
                                                 return;
                                             }
                                         }
                                         else
                                         {
                                             return;
                                         }
                                     }
                                     else
                                     {
                                         return;
                                     }
                                 }
                                 else
                                 {
                                     return;
                                 }
                             }
                             else
                             {
                                 return;
                             }
                         });
                     }
                 },
                 () =>
                 {
                     object o = new object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions
                         {
                             MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                         }; Parallel.For(0, HourseHight, p =>
                         {
                             if (HoursesOnTable != null)
                             {
                                 if (HoursesOnTable[p] != null)
                                 {
                                     if (HoursesOnTable[p].HourseThinkingQuantum != null)
                                     {
                                         if (HoursesOnTable[p].HourseThinkingQuantum[0] != null)
                                         {
                                             if (HoursesOnTable[p].HourseThinkingQuantum[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < HoursesOnTable[p].HourseThinkingQuantum[0].AStarGreedy.Count; k++)
                                                 {
                                                     Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || HoursesOnTable[p].HourseThinkingQuantum[0].AStarGreedy[k].MergeJungleTree(jungle.HoursesOnTable[p].HourseThinkingQuantum[0].AStarGreedy[k], p, k, 3));
                                                     outputH.Wait();
                                                     outputH.Dispose();
                                                 }
                                             }
                                             else
                                             {
                                                 return;
                                             }
                                         }
                                         else
                                         {
                                             return;
                                         }
                                     }
                                     else
                                     {
                                         return;
                                     }
                                 }
                                 else
                                 {
                                     return;
                                 }
                             }
                             else
                             {
                                 return;
                             }
                         });
                     }
                 }, () =>
                 {
                     object o = new object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions
                         {
                             MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                         }; Parallel.For(0, CastleHigh, p =>
                         {
                             if (CastlesOnTable != null)
                             {
                                 if (CastlesOnTable[p] != null)
                                 {
                                     if (CastlesOnTable[p].CastleThinkingQuantum != null)
                                     {
                                         if (CastlesOnTable[p].CastleThinkingQuantum[0] != null)
                                         {
                                             if (CastlesOnTable[p].CastleThinkingQuantum[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < CastlesOnTable[p].CastleThinkingQuantum[0].AStarGreedy.Count; k++)
                                                 {
                                                     Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || CastlesOnTable[p].CastleThinkingQuantum[0].AStarGreedy[k].MergeJungleTree(jungle.CastlesOnTable[p].CastleThinkingQuantum[0].AStarGreedy[k], p, k, 4));
                                                     outputH.Wait();
                                                     outputH.Dispose();
                                                 }
                                             }
                                             else
                                             {
                                                 return;
                                             }
                                         }
                                         else
                                         {
                                             return;
                                         }
                                     }
                                     else
                                     {
                                         return;
                                     }
                                 }
                                 else
                                 {
                                     return;
                                 }
                             }
                             else
                             {
                                 return;
                             }
                         });
                     }
                 },
                 () =>
                 {
                     object o = new object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions
                         {
                             MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                         }; Parallel.For(0, MinisterHigh, p =>
                         {
                             if (MinisterOnTable != null)
                             {
                                 if (MinisterOnTable[p] != null)
                                 {
                                     if (MinisterOnTable[p].MinisterThinkingQuantum != null)
                                     {
                                         if (MinisterOnTable[p].MinisterThinkingQuantum[0] != null)
                                         {
                                             if (MinisterOnTable[p].MinisterThinkingQuantum[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < MinisterOnTable[p].MinisterThinkingQuantum[0].AStarGreedy.Count; k++)
                                                 {
                                                     Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || MinisterOnTable[p].MinisterThinkingQuantum[0].AStarGreedy[k].MergeJungleTree(jungle.MinisterOnTable[p].MinisterThinkingQuantum[0].AStarGreedy[k], p, k, 5));
                                                     outputH.Wait();
                                                     outputH.Dispose();
                                                 }
                                             }
                                             else
                                             {
                                                 return;
                                             }
                                         }
                                         else
                                         {
                                             return;
                                         }
                                     }
                                     else
                                     {
                                         return;
                                     }
                                 }
                                 else
                                 {
                                     return;
                                 }
                             }
                             else
                             {
                                 return;
                             }
                         });
                     }
                 }, () =>
                 {
                     object o = new object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions
                         {
                             MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                         }; Parallel.For(0, KingHigh, p =>
                         {
                             if (KingOnTable != null)
                             {
                                 if (KingOnTable[p] != null)
                                 {
                                     if (KingOnTable[p].KingThinkingQuantum != null)
                                     {
                                         if (KingOnTable[p].KingThinkingQuantum[0] != null)
                                         {
                                             if (KingOnTable[p].KingThinkingQuantum[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < KingOnTable[p].KingThinkingQuantum[0].AStarGreedy.Count; k++)
                                                 {
                                                     Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || KingOnTable[p].KingThinkingQuantum[0].AStarGreedy[k].MergeJungleTree(jungle.KingOnTable[p].KingThinkingQuantum[0].AStarGreedy[k], p, k, 6));
                                                     outputH.Wait();
                                                     outputH.Dispose();
                                                 }
                                             }
                                             else
                                             {
                                                 return;
                                             }
                                         }
                                         else
                                         {
                                             return;
                                         }
                                     }
                                     else
                                     {
                                         return;
                                     }
                                 }
                                 else
                                 {
                                     return;
                                 }
                             }
                             else
                             {
                                 return;
                             }
                         });
                     }
                 },
                 () =>
                 {
                     object o = new object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions
                         {
                             MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                         }; Parallel.For(0, 1, p =>
                         {
                             if (CastlingOnTable != null)
                             {
                                 if (CastlingOnTable[p] != null)
                                 {
                                     if (CastlingOnTable[p].CastlingThinking != null)
                                     {
                                         if (CastlingOnTable[p].CastlingThinking[0] != null)
                                         {
                                             if (CastlingOnTable[p].CastlingThinking[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < CastlingOnTable[p].CastlingThinking[0].AStarGreedy.Count; k++)
                                                 {
                                                     Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || CastlingOnTable[p].CastlingThinking[0].AStarGreedy[k].MergeJungleTree(jungle.CastlingOnTable[p].CastlingThinking[0].AStarGreedy[k], p, k, 7));
                                                     outputH.Wait();
                                                     outputH.Dispose();
                                                 }
                                             }
                                             else
                                             {
                                                 return;
                                             }
                                         }
                                         else
                                         {
                                             return;
                                         }
                                     }
                                     else
                                     {
                                         return;
                                     }
                                 }
                                 else
                                 {
                                     return;
                                 }
                             }
                             else
                             {
                                 return;
                             }
                         });
                     }
                 });
            });
            output.Wait();
            output.Dispose();
            return Act;
        }

        private bool MergeJungleTreeSoldier(AllDraw jungle, int i, int j)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                if (SolderesOnTable != null)
                {
                    if (SolderesOnTable[i] != null)
                    {
                        if (SolderesOnTable[i].SoldierThinkingQuantum != null)
                        {
                            if (SolderesOnTable[i].SoldierThinkingQuantum[0] != null)
                            {
                                if (SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy == null)
                                {
                                    if (SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy == null)
                                    {
                                        SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                                    }

                                    SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].RowColumnSoldier.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].HitNumberSoldier.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].PenaltyRegardListSolder.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].KishSelf.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].KishEnemy.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].LoseChiled.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].WinChiled.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].IsSup.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].IsSupHu.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].IsThereCheckOfEnemy.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].IsThereCheckOfSelf.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].IsThereMateOfEnemy.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].IsThereMateOfSelf.Clear();
                                    object ooo = new object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; h++)
                                        {
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 1, jungle.SolderesOnTable[i].SoldierThinkingQuantum[0], h);
                                        }

                                        for (int h = 0; h < jungle.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; h++)
                                        {
                                            SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Add(jungle.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[h]);
                                            SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                }
                                else
                                if (SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count < jungle.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count)
                                {
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].HeuristicListSolder.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].RowColumnSoldier.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].HitNumberSoldier.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].PenaltyRegardListSolder.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].KishSelf.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].KishEnemy.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].LoseChiled.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].WinChiled.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].IsSup.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].IsSupHu.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].IsThereCheckOfEnemy.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].IsThereCheckOfSelf.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].IsThereMateOfEnemy.Clear();
                                    SolderesOnTable[i].SoldierThinkingQuantum[0].IsThereMateOfSelf.Clear();
                                    object ooo = new object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; h++)
                                        {
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 1, jungle.SolderesOnTable[i].SoldierThinkingQuantum[0], h);
                                        }

                                        for (int h = 0; h < jungle.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; h++)
                                        {
                                            SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Add(jungle.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[h]);
                                            SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }
            }
            return Act;
        }

        private bool MergeJungleTreeElephant(AllDraw jungle, int i, int j)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                if (ElephantOnTable != null)
                {
                    if (ElephantOnTable[i] != null)
                    {
                        if (ElephantOnTable[i].ElefantThinkingQuantum != null)
                        {
                            if (ElephantOnTable[i].ElefantThinkingQuantum[0] != null)
                            {
                                if (ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy == null)
                                {
                                    if (ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy == null)
                                    {
                                        ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                                    }

                                    ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].RowColumnElefant.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].HitNumberElefant.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].PenaltyRegardListElefant.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].KishSelf.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].KishEnemy.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].LoseChiled.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].WinChiled.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].IsSup.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].IsSupHu.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].IsThereCheckOfEnemy.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].IsThereCheckOfSelf.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].IsThereMateOfEnemy.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].IsThereMateOfSelf.Clear();
                                    object ooo = new object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; h++)
                                        {
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 2, jungle.ElephantOnTable[i].ElefantThinkingQuantum[0], h);
                                        }

                                        for (int h = 0; h < jungle.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; h++)
                                        {
                                            ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Add(jungle.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[h]);
                                            ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                }
                                else
                                if (ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count < jungle.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count)
                                {
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].HeuristicListElefant.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].RowColumnElefant.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].HitNumberElefant.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].PenaltyRegardListElefant.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].KishSelf.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].KishEnemy.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].LoseChiled.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].WinChiled.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].IsSup.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].IsSupHu.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].IsThereCheckOfEnemy.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].IsThereCheckOfSelf.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].IsThereMateOfEnemy.Clear();
                                    ElephantOnTable[i].ElefantThinkingQuantum[0].IsThereMateOfSelf.Clear();
                                    object ooo = new object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; h++)
                                        {
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 2, jungle.ElephantOnTable[i].ElefantThinkingQuantum[0], h);
                                        }

                                        for (int h = 0; h < jungle.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; h++)
                                        {
                                            ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Add(jungle.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[h]);
                                            ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }
            }

            return Act;
        }

        private bool MergeJungleTreeHourse(AllDraw jungle, int i, int j)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                if (HoursesOnTable != null)
                {
                    if (HoursesOnTable[i] != null)
                    {
                        if (HoursesOnTable[i].HourseThinkingQuantum != null)
                        {
                            if (HoursesOnTable[i].HourseThinkingQuantum[0] != null)
                            {
                                if (HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy == null)
                                {
                                    if (HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy == null)
                                    {
                                        HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                                    }

                                    HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].RowColumnHourse.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].HitNumberHourse.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].PenaltyRegardListHourse.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].KishSelf.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].KishEnemy.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].LoseChiled.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].WinChiled.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].IsSup.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].IsSupHu.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].IsThereCheckOfEnemy.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].IsThereCheckOfSelf.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].IsThereMateOfEnemy.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].IsThereMateOfSelf.Clear();
                                    object ooo = new object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; h++)
                                        {
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 3, jungle.HoursesOnTable[i].HourseThinkingQuantum[0], h);
                                        }

                                        for (int h = 0; h < jungle.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; h++)
                                        {
                                            HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Add(jungle.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[h]);
                                            HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                }
                                else
                                if (HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count < jungle.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count)
                                {
                                    HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].HeuristicListHourse.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].RowColumnHourse.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].HitNumberHourse.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].PenaltyRegardListHourse.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].KishSelf.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].KishEnemy.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].LoseChiled.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].WinChiled.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].IsSup.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].IsSupHu.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].IsThereCheckOfEnemy.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].IsThereCheckOfSelf.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].IsThereMateOfEnemy.Clear();
                                    HoursesOnTable[i].HourseThinkingQuantum[0].IsThereMateOfSelf.Clear();
                                    object ooo = new object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; h++)
                                        {
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 3, jungle.HoursesOnTable[i].HourseThinkingQuantum[0], h);
                                        }

                                        for (int h = 0; h < jungle.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; h++)
                                        {
                                            HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Add(jungle.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[h]);
                                            HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }
            }

            return Act;
        }

        private bool MergeJungleTreeCastle(AllDraw jungle, int i, int j)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                if (CastlesOnTable != null)
                {
                    if (CastlesOnTable[i] != null)
                    {
                        if (CastlesOnTable[i].CastleThinkingQuantum != null)
                        {
                            if (CastlesOnTable[i].CastleThinkingQuantum[0] != null)
                            {
                                if (CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy == null)
                                {
                                    if (CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy == null)
                                    {
                                        CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                                    }

                                    CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].RowColumnCastle.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].HitNumberCastle.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].PenaltyRegardListCastle.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].KishSelf.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].KishEnemy.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].LoseChiled.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].IsSup.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].IsSupHu.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].IsThereCheckOfEnemy.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].IsThereCheckOfSelf.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].IsThereMateOfEnemy.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].IsThereMateOfSelf.Clear();
                                    object ooo = new object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; h++)
                                        {
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 4, jungle.CastlesOnTable[i].CastleThinkingQuantum[0], h);
                                        }

                                        for (int h = 0; h < jungle.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; h++)
                                        {
                                            CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Add(jungle.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[h]);
                                            CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                }
                                else
                                if (CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count < jungle.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count)
                                {
                                    CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].HeuristicListCastle.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].RowColumnCastle.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].HitNumberCastle.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].PenaltyRegardListCastle.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].KishSelf.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].KishEnemy.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].LoseChiled.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].IsSup.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].IsSupHu.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].IsThereCheckOfEnemy.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].IsThereCheckOfSelf.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].IsThereMateOfEnemy.Clear();
                                    CastlesOnTable[i].CastleThinkingQuantum[0].IsThereMateOfSelf.Clear();
                                    object ooo = new object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; h++)
                                        {
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 4, jungle.CastlesOnTable[i].CastleThinkingQuantum[0], h);
                                        }

                                        for (int h = 0; h < jungle.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; h++)
                                        {
                                            CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Add(jungle.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[h]);
                                            CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }
            }

            return Act;
        }

        private bool MergeJungleTreeMinister(AllDraw jungle, int i, int j)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                if (MinisterOnTable != null)
                {
                    if (MinisterOnTable[i] != null)
                    {
                        if (MinisterOnTable[i].MinisterThinkingQuantum != null)
                        {
                            if (MinisterOnTable[i].MinisterThinkingQuantum[0] != null)
                            {
                                if (MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy == null)
                                {
                                    if (MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy == null)
                                    {
                                        MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                                    }

                                    MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].RowColumnMinister.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].HitNumberMinister.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].PenaltyRegardListMinister.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].KishSelf.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].KishEnemy.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].WinChiled.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].IsSup.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].IsSupHu.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].IsThereCheckOfEnemy.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].IsThereCheckOfSelf.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].IsThereMateOfEnemy.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].IsThereMateOfSelf.Clear();
                                    object ooo = new object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; h++)
                                        {
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 5, jungle.MinisterOnTable[i].MinisterThinkingQuantum[0], h);
                                        }

                                        for (int h = 0; h < jungle.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; h++)
                                        {
                                            MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Add(jungle.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[h]);
                                            MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                }
                                else
                                 if (MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count < jungle.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count)
                                {
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].HeuristicListMinister.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].RowColumnMinister.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].HitNumberMinister.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].PenaltyRegardListMinister.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].KishSelf.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].KishEnemy.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].WinChiled.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].IsSup.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].IsSupHu.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].IsThereCheckOfEnemy.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].IsThereCheckOfSelf.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].IsThereMateOfEnemy.Clear();
                                    MinisterOnTable[i].MinisterThinkingQuantum[0].IsThereMateOfSelf.Clear();
                                    object ooo = new object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; h++)
                                        {
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 5, jungle.MinisterOnTable[i].MinisterThinkingQuantum[0], h);
                                        }

                                        for (int h = 0; h < jungle.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; h++)
                                        {
                                            MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Add(jungle.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[h]);
                                            MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }
            }

            return Act;
        }

        private bool MergeJungleTreeKing(AllDraw jungle, int i, int j)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                if (KingOnTable != null)
                {
                    if (KingOnTable[i] != null)
                    {
                        if (KingOnTable[i].KingThinkingQuantum != null)
                        {
                            if (KingOnTable[i].KingThinkingQuantum[0] != null)
                            {
                                if (KingOnTable[i].KingThinkingQuantum[0].AStarGreedy == null)
                                {
                                    if (KingOnTable[i].KingThinkingQuantum[0].AStarGreedy == null)
                                    {
                                        KingOnTable[i].KingThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                                    }

                                    KingOnTable[i].KingThinkingQuantum[0].TableListKing.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].RowColumnKing.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].HitNumberKing.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].PenaltyRegardListKing.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].KishSelf.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].KishEnemy.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].LoseChiled.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].WinChiled.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].IsSup.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].IsSupHu.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].IsThereCheckOfEnemy.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].IsThereCheckOfSelf.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].IsThereMateOfEnemy.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].IsThereMateOfSelf.Clear();
                                    object ooo = new object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; h++)
                                        {
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 6, jungle.KingOnTable[i].KingThinkingQuantum[0], h);
                                        }

                                        for (int h = 0; h < jungle.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; h++)
                                        {
                                            KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Add(jungle.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[h]);
                                            KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                }
                                else
                                    if (KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count)
                                {
                                    KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].TableListKing.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].HeuristicListKing.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].RowColumnKing.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].HitNumberKing.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].PenaltyRegardListKing.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].KishSelf.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].KishEnemy.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].LoseChiled.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].WinChiled.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].IsSup.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].IsSupHu.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].IsThereCheckOfEnemy.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].IsThereCheckOfSelf.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].IsThereMateOfEnemy.Clear();
                                    KingOnTable[i].KingThinkingQuantum[0].IsThereMateOfSelf.Clear();
                                    object ooo = new object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; h++)
                                        {
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 6, jungle.KingOnTable[i].KingThinkingQuantum[0], h);
                                        }

                                        for (int h = 0; h < jungle.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; h++)
                                        {
                                            KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Add(jungle.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[h]);
                                            KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }
            }

            return Act;
        }

        private bool MergeJungleTreeCastling(AllDraw jungle, int i, int j)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                if (CastlingOnTable != null)
                {
                    if (CastlingOnTable[i] != null)
                    {
                        if (CastlingOnTable[i].CastlingThinking != null)
                        {
                            if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy == null)
                            {
                                if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy == null)
                                {
                                    CastlingOnTable[i].CastlingThinking[0].AStarGreedy = new List<AllDraw>();
                                }

                                CastlingOnTable[i].CastlingThinking[0].TableListCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].RowColumnCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].HitNumberCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].KishSelf.Clear();
                                CastlingOnTable[i].CastlingThinking[0].KishEnemy.Clear();
                                CastlingOnTable[i].CastlingThinking[0].LoseChiled.Clear();
                                CastlingOnTable[i].CastlingThinking[0].WinChiled.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsSup.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsSupHu.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsThereCheckOfEnemy.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsThereCheckOfSelf.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsThereMateOfEnemy.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsThereMateOfSelf.Clear();
                                object ooo = new object();
                                lock (ooo)
                                {
                                    ////HarasAct = true; Act = true;
                                    for (int h = 0; h < jungle.CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; h++)
                                    {
                                        Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 7, jungle.CastlingOnTable[i].CastlingThinking[0], h);
                                    }

                                    for (int h = 0; h < jungle.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; h++)
                                    {
                                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Add(jungle.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h]);
                                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy[CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                    }
                                }
                            }
                            else
                                if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count < jungle.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count)
                            {
                                CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Clear();
                                CastlingOnTable[i].CastlingThinking[0].TableListCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].RowColumnCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].HitNumberCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].KishSelf.Clear();
                                CastlingOnTable[i].CastlingThinking[0].KishEnemy.Clear();
                                CastlingOnTable[i].CastlingThinking[0].LoseChiled.Clear();
                                CastlingOnTable[i].CastlingThinking[0].WinChiled.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsSup.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsSupHu.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsThereCheckOfEnemy.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsThereCheckOfSelf.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsThereMateOfEnemy.Clear();

                                object ooo = new object();
                                lock (ooo)
                                {
                                    ////HarasAct = true; Act = true;
                                    for (int h = 0; h < jungle.CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; h++)
                                    {
                                        Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 7, jungle.CastlingOnTable[i].CastlingThinking[0], h);
                                    }

                                    for (int h = 0; h < jungle.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; h++)
                                    {
                                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Add(jungle.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h]);
                                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy[CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                    }
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }
            }

            return Act;
        }

        public bool HarasAlphaBeta(int i, int j, int kindA)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                if (CurrentMaxLevel >= 2)
                {
                    if (kindA == 1)
                    {
                        Act = Act || HarasAlphaBetaCS(i, j, kindA);
                    }
                    else
                    if (kindA == 2)
                    {
                        Act = Act || HarasAlphaBetaCE(i, j, kindA);
                    }
                    else
                    if (kindA == 3)
                    {
                        Act = Act || HarasAlphaBetaCH(i, j, kindA);
                    }
                    else
                         if (kindA == 4)
                    {
                        Act = Act || HarasAlphaBetaCC(i, j, kindA);
                    }
                    else
                    if (kindA == 5)
                    {
                        Act = Act || HarasAlphaBetaCM(i, j, kindA);
                    }
                    else
                    if (kindA == 6)
                    {
                        Act = Act || HarasAlphaBetaCK(i, j, kindA);
                    }
                    else
                    if (kindA == 7 || kindA == -7)
                    {
                        Act = Act || HarasAlphaBetaCA(i, j, kindA);
                    }
                }
            }
            Task output = Task.Factory.StartNew(() =>
            {
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.Invoke(() =>
                {
                    object o = new object();
                    lock (o)
                    {
                        ParallelOptions poo = new ParallelOptions
                        {
                            MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                        }; Parallel.For(0, SodierHigh, p =>
                        {
                            Act = Act || HarasAlphaBetaS(i, j, kindA,p);
                        });
                    }
                },
                 () =>
                 {
                     object o = new object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions
                         {
                             MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                         }; Parallel.For(0, ElefantHigh, p =>
                         {
                             Act = Act || HarasAlphaBetaE(i, j, kindA,p);
                         });
                     }
                 },
                 () =>
                 {
                     object o = new object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions
                         {
                             MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                         }; Parallel.For(0, HourseHight, p =>
                         {
                             Act = Act || HarasAlphaBetaH(i, j, kindA,p);
                         });
                     }
                 }, () =>
                 {
                     object o = new object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions
                         {
                             MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                         }; Parallel.For(0, CastleHigh, p =>
                         {
                             Act = Act || HarasAlphaBetaC(i, j, kindA,p);
                         });
                     }
                 },
                 () =>
                 {
                     object o = new object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions
                         {
                             MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                         }; Parallel.For(0, MinisterHigh, p =>
                         {
                             Act = Act || HarasAlphaBetaM(i, j, kindA,p);
                         });
                     }
                 }, () =>
                 {
                     object o = new object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions
                         {
                             MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                         }; Parallel.For(0, KingHigh, p =>
                         {
                             Act = Act || HarasAlphaBetaK(i, j, kindA,p);
                         });
                     }
                 },
                 () =>
                 {
                     object o = new object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions
                         {
                             MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                         }; Parallel.For(0, 1, p =>
                         {
                             Act = Act || HarasAlphaBetaA(i, j, kindA, p);
                         });
                     }
                 });
            });
            output.Wait();
            output.Dispose();
            return Act;
        }
        public bool HarasAlphaBetaCS(int i, int j, int kindA)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                try
                {
                    if (SolderesOnTable != null)
                    {
                        if (SolderesOnTable[i] != null)
                        {
                            if (SolderesOnTable[i].SoldierThinkingQuantum != null)
                            {
                                if (SolderesOnTable[i].SoldierThinkingQuantum[0] != null)
                                {
                                    if (SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null)
                                    {
                                        if (SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count > j)
                                        {
                                            if (SolderesOnTable[i].LoseOcuuredatChiled[0] < 0 || SolderesOnTable[i].SoldierThinkingQuantum[0].LoseChiled[j] < 0)
                                            {
                                                object ooo = new object();
                                                lock (ooo)
                                                {
                                                    HarasAct = true; Act = true;
                                                    SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].Dispose();
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        return Act;
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                catch (Exception t) { Log(t); }
            }
            return Act;
        }
        public bool HarasAlphaBetaCE(int i, int j, int kindA)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {

                try
                {

                    if (ElephantOnTable != null)
                    {
                        if (ElephantOnTable[i] != null)
                        {
                            if (ElephantOnTable[i].ElefantThinkingQuantum != null)
                            {
                                if (ElephantOnTable[i].ElefantThinkingQuantum[0] != null)
                                {
                                    if (ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null)
                                    {
                                        if (ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count > j)
                                        {
                                            if (ElephantOnTable[i].LoseOcuuredatChiled[0] < 0 || ElephantOnTable[i].ElefantThinkingQuantum[0].LoseChiled[j] < 0)
                                            {
                                                object ooo = new object();
                                                lock (ooo)
                                                {
                                                    HarasAct = true; Act = true;
                                                    ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].Dispose();
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        return Act;
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }

                }
                catch (Exception t) { Log(t); }

            }
            return Act;
        }
        public bool HarasAlphaBetaCH(int i, int j, int kindA)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {

                try
                {
                    if (HoursesOnTable != null)
                    {
                        if (HoursesOnTable[i] != null)
                        {
                            if (HoursesOnTable[i].HourseThinkingQuantum != null)
                            {
                                if (HoursesOnTable[i].HourseThinkingQuantum[0] != null)
                                {
                                    if (HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null)
                                    {
                                        if (HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count > j)
                                        {
                                            if (HoursesOnTable[i].LoseOcuuredatChiled[0] < 0 || HoursesOnTable[i].HourseThinkingQuantum[0].LoseChiled[j] < 0)
                                            {
                                                object ooo = new object();
                                                lock (ooo)
                                                {
                                                    HarasAct = true; Act = true;
                                                    HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].Dispose();
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        return Act;
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                catch (Exception t) { Log(t); }
            }
            return Act;
        }
        public bool HarasAlphaBetaCC(int i, int j, int kindA)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                try
                {

                    if (CastlesOnTable != null)
                    {
                        if (CastlesOnTable[i] != null)
                        {
                            if (CastlesOnTable[i].CastleThinkingQuantum != null)
                            {
                                if (CastlesOnTable[i].CastleThinkingQuantum[0] != null)
                                {
                                    if (CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null)
                                    {
                                        if (CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count > j)
                                        {
                                            if (CastlesOnTable[i].LoseOcuuredatChiled[0] < 0 || CastlesOnTable[i].CastleThinkingQuantum[0].LoseChiled[j] < 0)
                                            {
                                                object ooo = new object();
                                                lock (ooo)
                                                {
                                                    HarasAct = true; Act = true;
                                                    CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].Dispose();
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        return Act;
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                catch (Exception t) { Log(t); }

            }
            return Act;
        }
        public bool HarasAlphaBetaCM(int i, int j, int kindA)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                try
                {

                    if (MinisterOnTable != null)
                    {
                        if (MinisterOnTable[i] != null)
                        {
                            if (MinisterOnTable[i].MinisterThinkingQuantum != null)
                            {
                                if (MinisterOnTable[i].MinisterThinkingQuantum[0] != null)
                                {
                                    if (MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null)
                                    {
                                        if (MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count > j)
                                        {
                                            if (MinisterOnTable[i].LoseOcuuredatChiled[0] < 0 || MinisterOnTable[i].MinisterThinkingQuantum[0].LoseChiled[j] < 0)
                                            {
                                                object ooo = new object();
                                                lock (ooo)
                                                {
                                                    HarasAct = true; Act = true;
                                                    MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].Dispose();
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        return Act;
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                catch (Exception t) { Log(t); }


            }
            return Act;
        }
        public bool HarasAlphaBetaCK(int i, int j, int kindA)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {
                try
                {

                    if (KingOnTable != null)
                    {
                        if (KingOnTable[i] != null)
                        {
                            if (KingOnTable[i].KingThinkingQuantum != null)
                            {
                                if (KingOnTable[i].KingThinkingQuantum[0] != null)
                                {
                                    if (KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null)
                                    {
                                        if (KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count > j)
                                        {
                                            if (KingOnTable[i].LoseOcuuredatChiled[0] < 0 || KingOnTable[i].KingThinkingQuantum[0].LoseChiled[j] < 0)
                                            {
                                                object ooo = new object();
                                                lock (ooo)
                                                {
                                                    HarasAct = true; Act = true;
                                                    KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].Dispose();
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        return Act;
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                catch (Exception t) { Log(t); }

            }

            return Act;
        }
        public bool HarasAlphaBetaCA(int i, int j, int kindA)
        {
            bool Act = false;
            object oo = new object();
            lock (oo)
            {

                try
                {
                    if (CastlingOnTable != null)
                    {
                        if (CastlingOnTable[i] != null)
                        {
                            if (CastlingOnTable[i].CastlingThinking != null)
                            {
                                if (CastlingOnTable[i].CastlingThinking[0] != null)
                                {
                                    if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null)
                                    {
                                        if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j)
                                        {
                                            if (CastlingOnTable[i].LoseOcuuredatChiled[0] < 0 || CastlingOnTable[i].CastlingThinking[0].LoseChiled[j] < 0)
                                            {
                                                object ooo = new object();
                                                lock (ooo)
                                                {
                                                    HarasAct = true; Act = true;
                                                    CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].Dispose();
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        return Act;
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }

                }
                catch (Exception t) { Log(t); }

            }

            return Act;
        }

        public bool HarasAlphaBetaS(int i, int j, int kindA, int p)
        {
            bool Act = false;

            try
            {
                if (SolderesOnTable != null)
                {
                    if (SolderesOnTable[p] != null)
                    {
                        if (SolderesOnTable[p].SoldierThinkingQuantum != null)
                        {
                            if (SolderesOnTable[p].SoldierThinkingQuantum[0] != null)
                            {
                                if (SolderesOnTable[p].SoldierThinkingQuantum[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < SolderesOnTable[p].SoldierThinkingQuantum[0].AStarGreedy.Count; k++)
                                    {
                                        Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || SolderesOnTable[p].SoldierThinkingQuantum[0].AStarGreedy[k].HarasAlphaBeta(p, k, 1));
                                        outputH.Wait();
                                        outputH.Dispose();
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }
            }
            catch (Exception t) { Log(t); }

            return Act;
        }
        public bool HarasAlphaBetaE(int i, int j, int kindA, int p)
        {
            bool Act = false;
            try
            {
                if (ElephantOnTable != null)
                {
                    if (ElephantOnTable[p] != null)
                    {
                        if (ElephantOnTable[p].ElefantThinkingQuantum != null)
                        {
                            if (ElephantOnTable[p].ElefantThinkingQuantum[0] != null)
                            {
                                if (ElephantOnTable[p].ElefantThinkingQuantum[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < ElephantOnTable[p].ElefantThinkingQuantum[0].AStarGreedy.Count; k++)
                                    {
                                        Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || ElephantOnTable[p].ElefantThinkingQuantum[0].AStarGreedy[k].HarasAlphaBeta(p, k, 2));
                                        outputH.Wait();
                                        outputH.Dispose();
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }

            }
            catch (Exception t) { Log(t); }
            return Act;
        }
        public bool HarasAlphaBetaH(int i, int j, int kindA, int p)
        {
            bool Act = false;

            try
            {
                if (HoursesOnTable != null)
                {
                    if (HoursesOnTable[p] != null)
                    {
                        if (HoursesOnTable[p].HourseThinkingQuantum != null)
                        {
                            if (HoursesOnTable[p].HourseThinkingQuantum[0] != null)
                            {
                                if (HoursesOnTable[p].HourseThinkingQuantum[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < HoursesOnTable[p].HourseThinkingQuantum[0].AStarGreedy.Count; k++)
                                    {
                                        Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || HoursesOnTable[p].HourseThinkingQuantum[0].AStarGreedy[k].HarasAlphaBeta(p, k, 3));
                                        outputH.Wait();
                                        outputH.Dispose();
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }

            }
            catch (Exception t) { Log(t); }
            return Act;
        }
        public bool HarasAlphaBetaC(int i, int j, int kindA, int p)
        {
            bool Act = false;

            try
            {
                if (CastlesOnTable != null)
                {
                    if (CastlesOnTable[p] != null)
                    {
                        if (CastlesOnTable[p].CastleThinkingQuantum != null)
                        {
                            if (CastlesOnTable[p].CastleThinkingQuantum[0] != null)
                            {
                                if (CastlesOnTable[p].CastleThinkingQuantum[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < CastlesOnTable[p].CastleThinkingQuantum[0].AStarGreedy.Count; k++)
                                    {
                                        Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || CastlesOnTable[p].CastleThinkingQuantum[0].AStarGreedy[k].HarasAlphaBeta(p, k, 4));
                                        outputH.Wait();
                                        outputH.Dispose();
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }

            }
            catch (Exception t) { Log(t); }
            return Act;
        }
        public bool HarasAlphaBetaM(int i, int j, int kindA,int p)
        {
            bool Act = false;
            try
            {
            
                if (MinisterOnTable != null)
                {
                    if (MinisterOnTable[p] != null)
                    {
                        if (MinisterOnTable[p].MinisterThinkingQuantum != null)
                        {
                            if (MinisterOnTable[p].MinisterThinkingQuantum[0] != null)
                            {
                                if (MinisterOnTable[p].MinisterThinkingQuantum[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < MinisterOnTable[p].MinisterThinkingQuantum[0].AStarGreedy.Count; k++)
                                    {
                                        Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || MinisterOnTable[p].MinisterThinkingQuantum[0].AStarGreedy[k].HarasAlphaBeta(p, k, 5));
                                        outputH.Wait();
                                        outputH.Dispose();
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }
            }
            catch (Exception t) { Log(t); }
            return Act;
        }
        public bool HarasAlphaBetaK(int i, int j, int kindA, int p)
        {
            bool Act = false;
            try
            {
                if (KingOnTable != null)
                {
                    if (KingOnTable[p] != null)
                    {
                        if (KingOnTable[p].KingThinkingQuantum != null)
                        {
                            if (KingOnTable[p].KingThinkingQuantum[0] != null)
                            {
                                if (KingOnTable[p].KingThinkingQuantum[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < KingOnTable[p].KingThinkingQuantum[0].AStarGreedy.Count; k++)
                                    {
                                        Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || KingOnTable[p].KingThinkingQuantum[0].AStarGreedy[k].HarasAlphaBeta(p, k, 6));
                                        outputH.Wait();
                                        outputH.Dispose();
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }

            }
            catch (Exception t) { Log(t); }
            return Act;
        }
        public bool HarasAlphaBetaA(int i, int j, int kindA, int p)
        {
            bool Act = false;

            try
            {
                if (CastlingOnTable != null)
                {
                    if (CastlingOnTable[p] != null)
                    {
                        if (CastlingOnTable[p].CastlingThinking != null)
                        {
                            if (CastlingOnTable[p].CastlingThinking[0] != null)
                            {
                                if (CastlingOnTable[p].CastlingThinking[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < CastlingOnTable[p].CastlingThinking[0].AStarGreedy.Count; k++)
                                    {
                                        Task<bool> outputH = Task.Factory.StartNew(() => Act = Act || CastlingOnTable[p].CastlingThinking[0].AStarGreedy[k].HarasAlphaBeta(p, k, 7));
                                        outputH.Wait();
                                        outputH.Dispose();
                                    }
                                }
                                else
                                {
                                    return Act;
                                }
                            }
                            else
                            {
                                return Act;
                            }
                        }
                        else
                        {
                            return Act;
                        }
                    }
                    else
                    {
                        return Act;
                    }
                }
                else
                {
                    return Act;
                }
            }
            catch (Exception t) { Log(t); }

            return Act;
        }
        //computational initiation
        public AllDraw InitiateAStarGreedyt(int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            if (iAStarGreedy <= 0 && (!SStopInitMaxAStarGreedy))
            {
                return this;
            }

            ThinkingRunInBothSide = true;
            OrderP = Order;
            SetObjectNumbers(Tab);
            int[,] Table = new int[8, 8];
            for (int iii = 0; iii < 8; iii++)
            {
                for (int jjj = 0; jjj < 8; jjj++)
                {
                    Table[iii, jjj] = Tab[iii, jjj];
                }
            }

            object oo = new object();
            lock (oo)
            {
                ThinkingQuantumChess.BeginThread = 0;
                ThinkingQuantumChess.EndThread = 0;
            }
            //Initiate of global Variables Byte Local Variables.
            int DummyOrder = new int();
            DummyOrder = Order;
            int DummyCurrentOrder = new int();
            DummyCurrentOrder = ChessRules.CurrentOrder;
            //#pragma warning disable CS0219 // The variable 'i' is assigned but its value is never used
#pragma warning disable CS0219 // The variable 'i' is assigned but its value is never used
            int i = 0, ik = 0;
#pragma warning restore CS0219 // The variable 'i' is assigned but its value is never used
            //#pragma warning restore CS0219 // The variable 'i' is assigned but its value is never used
            int[,] TablInit = new int[8, 8];
            if (Order == 1)
            {
                a = Color.Gray;
            }
            else
            {
                a = Color.Brown;
            }

            int j = 0;
            //Fairness conditions for perposive astar greedy search.
            object Omm = new object();
            lock (Omm)
            {
                object OOOO = new object();
                lock (OOOO)
                {
                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                    {
                        return null;
                    }

                    if (LeafSemaphoreIndex)
                    {
                        LeafAStarGreedy++;
                    }
                }
                CurrentAStarGredyMax = AStarGreedyiLevelMax - iAStarGreedy;
            }
            bool Do = false;
            if (iAStarGreedy >= 0 && iAStarGreedy < MaxDuringLevelThinkingCreation)
            {
                MaxDuringLevelThinkingCreation = iAStarGreedy;
                object O = new object();
                DepthIterative++;
                lock (O)
                {
                }
            }

            if (tH == null)
            {
                tH = new List<Task>();
            }

            if (!FOUND)
            {
                //Initiate Of Local Variables.
                object o = new object();
                lock (o)
                {
                    Task<bool> array1 = Task.Factory.StartNew(() => InitiateAStarGreedytCreationThinking(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));

                    array1.Wait();
                    array1.Dispose();
                }
            }
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            Task array = Task.Factory.StartNew(() => Serve(Order));
            array.Wait();
            array.Dispose();

            if (FOUND)
            {
                object O = new object();
                lock (O)
                {
                    FOUND = false;
                    QuantumRefrigiz.AllDraw Leaf = null;
                    Tabl = CloneATable(Table);
                    int LeafDeep = 0;// MaxAStarGreedy;
                    Task<AllDraw> array1 = Task.Factory.StartNew(() => FoundOfLeafDepenOfKind(ref Leaf, ref FOUND, Order, LeafDeep, 0, 0, 0, 0));

                    array1.Wait();
                    array1.Dispose();
                    Task<int> array11 = Task.Factory.StartNew(() => FullGameThinkingTreeWin(Order));
                    array11.Wait();
                    array11.Dispose();
                    array11 = Task.Factory.StartNew(() => FullGameThinkingTreeLose(Order));
                    array11.Wait();
                    array11.Dispose();
                }
            }
            else
            {
                if (!Deeperthandeeper || ThinkingQuantumChess.FullGameAllow || AllDraw.SStopInitMaxAStarGreedy)
                {
                    object O = new object();
                    lock (O)
                    {
                        NumberOfnewMove = 0;
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        int Ord = Order, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, ik1 = ik, j1 = j;

                        Task<bool> array1 = Task.Factory.StartNew(() => Do = FullGameThinkingTree(Ord, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii1, jj1, ik1, j1, false, LeafAStarGreedy));

                        array1.Wait();
                        array1.Dispose();
                        if (NumberOfnewMove == 0)
                        {
                            UsedRestrictedMoveBlitzAndFull = false;
                            array1 = Task.Factory.StartNew(() => Do = FullGameThinkingTree(Ord, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii1, jj1, ik1, j1, false, LeafAStarGreedy));
                            array1.Wait();
                            array1.Dispose();
                        }
                        Task<int> array11 = Task.Factory.StartNew(() => FullGameThinkingTreeWin(Order));
                        array11.Wait();
                        array11.Dispose();
                        array11 = Task.Factory.StartNew(() => FullGameThinkingTreeLose(Order));
                        array11.Wait();
                        array11.Dispose();
                    }
                }
            }
            object Om = new object();
            lock (Om)
            {
                if (!Do)
                {
                    if (iAStarGreedy < MinThinkingTreeDepth)
                    {
                        MinThinkingTreeDepth = iAStarGreedy;
                    }
                }
            }
            tH.Clear();

            return this;
        }

        //computational second object
        /*     public AllDraw InitiateAStarGreedytObject(int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
                 )
             {
                 bool Do = false;
                 {
                     OrderP = Order;
                     SetObjectNumbers(Tab);
                     int[,] Table = new int[8, 8];
                     for (var iii = 0; iii < 8; iii++)
                         for (var jjj = 0; jjj < 8; jjj++)
                             Table[iii, jjj] = Tab[iii, jjj];
                     Object oo = new Object();
                     lock (oo)
                     {
                         ThinkingQuantumChess.BeginThread = 0;
                         ThinkingQuantumChess.EndThread = 0;
                     }
                     //Initiate of global Variables Byte Local Variables.
                     int DummyOrder = new int();
                     DummyOrder = Order;
                     int DummyCurrentOrder = new int();
                     DummyCurrentOrder = ChessRules.CurrentOrder;
                     List<Task> ThB = new List<Task>();
                     int i = 0, ik = 0;
                     int[,] TablInit = new int[8, 8];
                     if (Order == 1)
                         a = Color.Gray;
                     else
                         a = Color.Brown;
                     var j = 0;
                     //if (iAStarGreedy>=0)

                     Object OOOO = new Object();
                     lock (OOOO)
                     {
                         //if (iAStarGreedy <= 0&&(!SStopInitMaxAStarGreedy))
                         {
                             //when search finished stop and return
                             if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                 return null;
                         }
                     }
                     CurrentAStarGredyMax = AStarGreedyiLevelMax - iAStarGreedy;

                     if (iAStarGreedy >= 0 && iAStarGreedy < MaxDuringLevelThinkingCreation)
                     {
                         MaxDuringLevelThinkingCreation = iAStarGreedy;
                         Object O = new Object();
                         DepthIterative++;
                         lock (O)
                         {
                         }
                     }

                     if (!FOUND)
                     {
                         Object o = new Object();
                         lock (o)
                         {
                             if (Order == 1)
                                 this.InitiateAStarGreedytObjectGray(i, j, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy);
                             else
                                 this.InitiateAStarGreedytObjectBrown(i, j, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy);
                         }
                     }
                     if (FOUND)
                     {
                         Object O = new Object();
                         lock (O)
                         {
                             Tabl = CloneATable(Table);
                             FoundOfLeafDepenOfKindFullGame(Tabl, Order, iAStarGreedy - 1, ii, jj, ik, j, FOUND, LeafAStarGreedy);
                         }
                     }
                     else
                     {
                         Object O = new Object();
                         lock (O)
                         {
                             Order = DummyOrder;
                             ChessRules.CurrentOrder = DummyCurrentOrder;
                             int Ord = Order, iAStarGreedy1 = iAStarGreedy - 1, ii1 = ii, jj1 = jj, ik1 = ik, j1 = j;

                             //ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.Invoke(() =>
                             {
                                 Do |= this.FullGameThinkingTree((Ord, , PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii1, jj1, ik1, j1, false, LeafAStarGreedy);
                             }
                         }
                     }
                     Object Om = new Object();
                     lock (Om)
                     {
                         if (!Do)
                             if (iAStarGreedy < MinThinkingTreeDepth)
                                 MinThinkingTreeDepth = iAStarGreedy;
                     }

                     return this;
                 }
             }
       */      //determistic of checked blitz game

        //always by calling empty deeper
        private void ClearAStarGreadyWhenListsAreEmpy(int Kind, int i)
        {
            //soldier
            if (Kind == 1 && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count > 0)
            {
                SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Clear();
            }
            else//elephant
if (Kind == 2 && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count > 0)
            {
                ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Clear();
            }
            else//hourse
                if (Kind == 3 && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count > 0)
            {
                HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Clear();
            }
            else//Castle
                if (Kind == 4 && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count > 0)
            {
                CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Clear();
            }
            else//minister
                if (Kind == 5 && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count > 0)
            {
                MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Clear();
            }
            else//king
                if (Kind == 6 && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count > 0)
            {
                KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Clear();
            }
            else//king
                if ((Kind == 7 || Kind == -7) && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > 0)
            {
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Clear();
            }
        }

        //deterministic of calculated computational deeper
        private bool IsThereCalculatedAStarGreedyNode()
        {
            bool Is = false;
            //soldier
            for (int i = 0; i < SodierHigh; i++)
            {
                if (SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder != null)
                {
                    if (SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count > 0)
                    {
                        Is = true;
                        break;
                    }
                    else
                    {
                        ClearAStarGreadyWhenListsAreEmpy(1, i);
                    }
                }
            }
            if (!Is)
            {
                //elephant
                for (int i = 0; i < ElefantHigh; i++)
                {
                    if (ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant != null)
                    {
                        if (ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                        {
                            ClearAStarGreadyWhenListsAreEmpy(2, i);
                        }
                    }
                }
            }
            if (!Is)
            {
                //hourse
                for (int i = 0; i < HourseHight; i++)
                {
                    if (HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse != null)
                    {
                        if (HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                        {
                            ClearAStarGreadyWhenListsAreEmpy(3, i);
                        }
                    }
                }
            }
            if (!Is)
            {
                //Castle
                for (int i = 0; i < CastleHigh; i++)
                {
                    if (CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle != null)
                    {
                        if (CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                        {
                            ClearAStarGreadyWhenListsAreEmpy(4, i);
                        }
                    }
                }
            }
            if (!Is)
            {
                //minister
                for (int i = 0; i < MinisterHigh; i++)
                {
                    if (MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister != null)
                    {
                        if (MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                        {
                            ClearAStarGreadyWhenListsAreEmpy(5, i);
                        }
                    }
                }
            }
            if (!Is)
            {
                //king
                for (int i = 0; i < KingHigh; i++)
                {
                    if (KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum != null && KingOnTable[i].KingThinkingQuantum[0] != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing != null)
                    {
                        if (KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                        {
                            ClearAStarGreadyWhenListsAreEmpy(6, i);
                        }
                    }
                }
            }
            if (!Is)
            {
                //king
                for (int i = 0; i < 1; i++)
                {
                    if (CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null)
                    {
                        if (CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                        {
                            ClearAStarGreadyWhenListsAreEmpy(7, i);
                        }
                    }
                }
            }
            return Is;
        }

        //when there is index notified deeper computational node
        private bool IsThereCalculatedAStarGreedyNode(int i, int Kind)
        {
            bool Is = false;
            //soldier
            if (Kind == 1)
            {
                if (SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder != null)
                {
                    if (SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count > 0)
                    {
                        Is = true;
                    }
                    else
                    {
                        ClearAStarGreadyWhenListsAreEmpy(1, i);
                    }
                }
            }
            else
            if (Kind == 2)
            {
                //elephant
                if (ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant != null)
                {
                    if (ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count > 0)
                    {
                        Is = true;
                    }
                    else
                    {
                        ClearAStarGreadyWhenListsAreEmpy(2, i);
                    }
                }
            }
            else
            if (Kind == 3)
            {
                //hourse
                if (HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse != null)
                {
                    if (HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count > 0)
                    {
                        Is = true;
                    }
                    else
                    {
                        ClearAStarGreadyWhenListsAreEmpy(3, i);
                    }
                }
            }
            else
            if (Kind == 4)
            {
                //Castle
                if (CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle != null)
                {
                    if (CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count > 0)
                    {
                        Is = true;
                    }
                    else
                    {
                        ClearAStarGreadyWhenListsAreEmpy(4, i);
                    }
                }
            }
            else
            if (Kind == 5)
            {
                //minister
                if (MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister != null)
                {
                    if (MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count > 0)
                    {
                        Is = true;
                    }
                    else
                    {
                        ClearAStarGreadyWhenListsAreEmpy(5, i);
                    }
                }
            }
            else
            if (Kind == 6)
            {
                //king
                if (KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum != null && KingOnTable[i].KingThinkingQuantum[0] != null && KingOnTable[i].KingThinkingQuantum[0].TableListKing != null)
                {
                    if (KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count > 0)
                    {
                        Is = true;
                    }
                    else
                    {
                        ClearAStarGreadyWhenListsAreEmpy(6, i);
                    }
                }
            }
            else
            if (Kind == 7 || Kind == -7)
            {
                if (CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null)
                {
                    if (CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > 0)
                    {
                        Is = true;
                    }
                    else
                    {
                        ClearAStarGreadyWhenListsAreEmpy(7, i);
                    }
                }
            }

            return Is;
        }

        //when there is all deeper computational nodes return true else return false
        private bool IsThereNotAllOfEmptyOrNonCalculatedAStarGreedyNode(int Order, int Kind, int i)
        {
            bool Is = true;

        
            //soldier
            if (Kind == 1)
            {
                if (SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null)
                {
                    for (int j = 0; j < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; j++)
                    {
                        Is = Is && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                    }
                }
            }
            else//elephant
                if (Kind == 2)
            {
                if (ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null)
                {
                    for (int j = 0; j < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; j++)
                    {
                        Is = Is && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                    }
                }
            }
            else//hourse
                if (Kind == 3)
            {
                if (HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null)
                {
                    for (int j = 0; j < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; j++)
                    {
                        Is = Is && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                    }
                }
            }
            else//Castle
                if (Kind == 4)
            {
                if (CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null)
                {
                    for (int j = 0; j < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; j++)
                    {
                        Is = Is && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                    }
                }
            }
            else//minister
                if (Kind == 5)
            {
                if (MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null)
                {
                    for (int j = 0; j < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; j++)
                    {
                        Is = Is && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                    }
                }
            }
            else//king
            if (Kind == 6)
            {
                if (KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum != null && KingOnTable[i].KingThinkingQuantum[0] != null && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null)
                {
                    for (int j = 0; j < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; j++)
                    {
                        Is = Is && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                    }
                }
            }
            else//king
            if (Kind == 7 || Kind == -7)
            {
                if (CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; j++)
                    {
                        Is = Is && CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                    }
                }
            }
            return Is;
        }

        //when there is at least one non compuational deeper determined NON existence of deeper computational indexed deeper node
        private bool IsThereEmptyOrNonCalculatedAStarGreedyNode(int Order, int Kind, int i, int j)
        {
            bool Is = false;

            //clear first
            ClearAllTablesHeuristicsAndMore(Order);

            if (!IsThereNotAllOfEmptyOrNonCalculatedAStarGreedyNode(Order, Kind, i))
            {
                //soldier
                if (Kind == 1)
                {
                    if (SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinkingQuantum != null && SolderesOnTable[i].SoldierThinkingQuantum[0] != null && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count > j)
                    {
                        Is = !SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                    }
                }
                else//elephant
                    if (Kind == 2)
                {
                    if (ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinkingQuantum != null && ElephantOnTable[i].ElefantThinkingQuantum[0] != null && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count > j)
                    {
                        Is = !ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                    }
                }
                else//hourse
                    if (Kind == 3)
                {
                    if (HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinkingQuantum != null && HoursesOnTable[i].HourseThinkingQuantum[0] != null && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count > j)
                    {
                        Is = !HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                    }
                }
                else//Castle
                    if (Kind == 4)
                {
                    if (CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinkingQuantum != null && CastlesOnTable[i].CastleThinkingQuantum[0] != null && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count > j)
                    {
                        Is = !CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                    }
                }
                else//minister
                    if (Kind == 5)
                {
                    if (MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinkingQuantum != null && MinisterOnTable[i].MinisterThinkingQuantum[0] != null && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count > j)
                    {
                        Is = !MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                    }
                }
                else//king
                if (Kind == 6)
                {
                    if (KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinkingQuantum != null && KingOnTable[i].KingThinkingQuantum[0] != null && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count > j)
                    {
                        Is = !KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                    }
                }
                else//king
                if (Kind == 7 || Kind == -7)
                {
                    if (CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j)
                    {
                        Is = !CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                    }
                }
            }
            return (!Is);
        }

        private bool BlitzGameThinkingTreeBoundryConditions(int ik, int Kind)
        {
            if (Kind == 1)
            {
                if (SolderesOnTable == null)
                {
                    return true;
                }

                if (SolderesOnTable[ik] == null)
                {
                    return true;
                }

                if (SolderesOnTable[ik].SoldierThinkingQuantum == null)
                {
                    return true;
                }

                if (SolderesOnTable[ik].SoldierThinkingQuantum[0] == null)
                {
                    return true;
                }

                if (SolderesOnTable[ik].SoldierThinkingQuantum[0].HeuristicListSolder == null)
                {
                    return true;
                }
            }
            else
            if (Kind == 2)
            {
                if (ElephantOnTable == null)
                {
                    return true;
                }

                if (ElephantOnTable[ik] == null)
                {
                    return true;
                }

                if (ElephantOnTable[ik].ElefantThinkingQuantum == null)
                {
                    return true;
                }

                if (ElephantOnTable[ik].ElefantThinkingQuantum[0] == null)
                {
                    return true;
                }

                if (ElephantOnTable[ik].ElefantThinkingQuantum[0].HeuristicListElefant == null)
                {
                    return true;
                }
            }
            else
            if (Kind == 3)
            {
                if (HoursesOnTable == null)
                {
                    return true;
                }

                if (HoursesOnTable[ik] == null)
                {
                    return true;
                }

                if (HoursesOnTable[ik].HourseThinkingQuantum == null)
                {
                    return true;
                }

                if (HoursesOnTable[ik].HourseThinkingQuantum[0] == null)
                {
                    return true;
                }

                if (HoursesOnTable[ik].HourseThinkingQuantum[0].HeuristicListHourse == null)
                {
                    return true;
                }
            }
            else
            if (Kind == 4)
            {
                if (CastlesOnTable == null)
                {
                    return true;
                }

                if (CastlesOnTable[ik] == null)
                {
                    return true;
                }

                if (CastlesOnTable[ik].CastleThinkingQuantum == null)
                {
                    return true;
                }

                if (CastlesOnTable[ik].CastleThinkingQuantum[0] == null)
                {
                    return true;
                }

                if (CastlesOnTable[ik].CastleThinkingQuantum[0].HeuristicListCastle == null)
                {
                    return true;
                }
            }
            else
            if (Kind == 5)
            {
                if (MinisterOnTable == null)
                {
                    return true;
                }

                if (MinisterOnTable[ik] == null)
                {
                    return true;
                }

                if (MinisterOnTable[ik].MinisterThinkingQuantum == null)
                {
                    return true;
                }

                if (MinisterOnTable[ik].MinisterThinkingQuantum[0] == null)
                {
                    return true;
                }

                if (MinisterOnTable[ik].MinisterThinkingQuantum[0].HeuristicListMinister == null)
                {
                    return true;
                }
            }
            else
            if (Kind == 6)
            {
                if (KingOnTable == null)
                {
                    return true;
                }

                if (KingOnTable[ik] == null)
                {
                    return true;
                }

                if (KingOnTable[ik].KingThinkingQuantum == null)
                {
                    return true;
                }

                if (KingOnTable[ik].KingThinkingQuantum[0] == null)
                {
                    return true;
                }

                if (KingOnTable[ik].KingThinkingQuantum[0].HeuristicListKing == null)
                {
                    return true;
                }
            }
            else
            if (Kind == 7 || Kind == -7)
            {
                if (CastlingOnTable == null)
                {
                    return true;
                }

                if (CastlingOnTable[ik] == null)
                {
                    return true;
                }

                if (CastlingOnTable[ik].CastlingThinking == null)
                {
                    return true;
                }

                if (CastlingOnTable[ik].CastlingThinking[0] == null)
                {
                    return true;
                }

                if (CastlingOnTable[ik].CastlingThinking[0].HeuristicListCastling == null)
                {
                    return true;
                }
            }
            return false;
        }

        private bool UsedRestrictedBlitzMoveAstarGreedy(int Kind, int ik, int j)
        {
            if (Kind == 1)
            {
                if (SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedyMove.Count > j)
                {
                    if ((SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedyMove[j] && UsedRestrictedMoveBlitzAndFull))
                    {
                        return true;
                    }
                }
            }
            else
            if (Kind == 2)
            {
                if (ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedyMove.Count > j)
                {
                    if ((ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedyMove[j] && UsedRestrictedMoveBlitzAndFull))
                    {
                        return true;
                    }
                }
            }
            else
            if (Kind == 3)
            {
                if (HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedyMove.Count > j)
                {
                    if ((HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedyMove[j] && UsedRestrictedMoveBlitzAndFull))
                    {
                        return true;
                    }
                }
            }
            else
            if (Kind == 4)
            {
                if (CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedyMove.Count > j)
                {
                    if ((CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedyMove[j] && UsedRestrictedMoveBlitzAndFull))
                    {
                        return true;
                    }
                }
            }
            else
            if (Kind == 5)
            {
                if (MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedyMove.Count > j)
                {
                    if ((MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedyMove[j] && UsedRestrictedMoveBlitzAndFull))
                    {
                        return true;
                    }
                }
            }
            else
            if (Kind == 6)
            {
                if (KingOnTable[ik].KingThinkingQuantum[0].AStarGreedyMove.Count > j)
                {
                    if ((KingOnTable[ik].KingThinkingQuantum[0].AStarGreedyMove[j] && UsedRestrictedMoveBlitzAndFull))
                    {
                        return true;
                    }
                }
            }
            else
            if (Kind == 7 || Kind == -7)
            {
                if (CastlingOnTable[ik].CastlingThinking[0].AStarGreedyMove.Count > j)
                {
                    if ((CastlingOnTable[ik].CastlingThinking[0].AStarGreedyMove[j] && UsedRestrictedMoveBlitzAndFull))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        //blitz for determination about best movment of every objects
        private void BlitzGameThinkingTreeSolderGray(ref double PreviousLessS, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Soldeir
            for (ik = 0; ik < SodierMidle; ik++)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 1));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    continue;
                }
                //when there is computational lists
                for (j = 0; j < SolderesOnTable[ik].SoldierThinkingQuantum[0].HeuristicListSolder.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 1)
                      )
                    {
                        continue;
                    }

                    object O = new object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 1, ik, j));
                        ah1.Wait();
                        ah1.Dispose();
                        if (!ac)
                        {
                            continue;
                        }
                        //when node have kings dangoures ignore and continue.
                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(SolderesOnTable[ik].SoldierThinkingQuantum[0].TableListSolder[j]), Order,1));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                        {
                            continue;
                        }
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(1, ik, j) || SolderesOnTable[ik].SoldierThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessS || (SolderesOnTable[ik].SoldierThinkingQuantum[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[0] = ik;
                                jIndex[0] = j;
                                int Hav = HaveKilled;
                                double pre = PreviousLessS;
                                Task<double> ah3 = Task.Factory.StartNew(() => pre = SolderesOnTable[ik].SoldierThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessS = pre;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is greater than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(1, ik, j) || SolderesOnTable[ik].SoldierThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessS || (SolderesOnTable[ik].SoldierThinkingQuantum[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[0] = ik;
                                jIndex[0] = j;
                                int Hav = HaveKilled;
                                double pre = PreviousLessS;
                                Task<double> ah3 = Task.Factory.StartNew(() => pre = SolderesOnTable[ik].SoldierThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessS = pre;
                            }
                        }
                    }
                }
                //Elephant
            }
        }

        //blitz for determination about best movment of every objects
        private void BlitzGameThinkingTreeElephantGray(ref double PreviousLessE, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Elephant
            for (ik = 0; ik < ElefantMidle; ik++)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 2));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    continue;
                }
                //when there is computational lists
                for (j = 0; j < ElephantOnTable[ik].ElefantThinkingQuantum[0].HeuristicListElefant.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 2)
               )
                    {
                        continue;
                    }

                    object O = new object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 2, ik, j));
                        ah1.Wait();
                        ah1.Dispose();
                        if (!ac)
                        {
                            continue;
                        }
                        //when node have kings dangoures ignore and continue.
                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(ElephantOnTable[ik].ElefantThinkingQuantum[0].TableListElefant[j]), Order,2));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                        {
                            continue;
                        }
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(2, ik, j) || ElephantOnTable[ik].ElefantThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessE || (ElephantOnTable[ik].ElefantThinkingQuantum[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[1] = ik;
                                jIndex[1] = j;
                                int Hav = HaveKilled;
                                double pre = PreviousLessE;
                                Task<double> ah3 = Task.Factory.StartNew(() => pre = ElephantOnTable[ik].ElefantThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessE = pre;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is greater than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(2, ik, j) || ElephantOnTable[ik].ElefantThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessE || (ElephantOnTable[ik].ElefantThinkingQuantum[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[1] = ik;
                                jIndex[1] = j;
                                int Hav = HaveKilled;
                                double pre = PreviousLessE;
                                Task<double> ah3 = Task.Factory.StartNew(() => pre = ElephantOnTable[ik].ElefantThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessE = pre;
                            }
                        }
                    }
                }
            }
        }

        //blitz for determination about best movment of every objects
        private void BlitzGameThinkingTreeHourseGray(ref double PreviousLessH, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Hourse.
            for (ik = 0; ik < HourseMidle; ik++)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 3));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    continue;
                }
                //when there is computational lists
                for (j = 0; j < HoursesOnTable[ik].HourseThinkingQuantum[0].HeuristicListHourse.Count; j++)
                {
                    //when node is serving node continue
                    if (HoursesOnTable[ik].HourseThinkingQuantum[0].IsSupHu[j]
                  )
                    {
                        continue;
                    }

                    object O = new object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 3, ik, j));
                        ah1.Wait();
                        ah1.Dispose();
                        if (!ac)
                        {
                            continue;
                        }
                        //when node have kings dangoures ignore and continue.
                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(HoursesOnTable[ik].HourseThinkingQuantum[0].TableListHourse[j]), Order,3));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                        {
                            continue;
                        }
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(3, ik, j) || HoursesOnTable[ik].HourseThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessH || (HoursesOnTable[ik].HourseThinkingQuantum[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[2] = ik;
                                jIndex[2] = j;
                                int Hav = HaveKilled;
                                double pre = PreviousLessH;
                                Task<double> ah3 = Task.Factory.StartNew(() => pre = HoursesOnTable[ik].HourseThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessH = pre;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is greater than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(3, ik, j) || HoursesOnTable[ik].HourseThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessH || (HoursesOnTable[ik].HourseThinkingQuantum[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[2] = ik;
                                jIndex[2] = j;
                                int Hav = HaveKilled;
                                double pre = PreviousLessH;
                                Task<double> ah3 = Task.Factory.StartNew(() => pre = HoursesOnTable[ik].HourseThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessH = pre;
                            }
                        }
                    }
                }
            }
        }

        //blitz for determination about best movment of every objects
        private void BlitzGameThinkingTreeCastleGray(ref double PreviousLessB, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Castle.
            for (ik = 0; ik < CastleMidle; ik++)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 4));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    continue;
                }
                //when there is computational lists
                for (j = 0; j < CastlesOnTable[ik].CastleThinkingQuantum[0].HeuristicListCastle.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 4)
                 )
                    {
                        continue;
                    }

                    object O = new object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 4, ik, j));
                        ah1.Wait();
                        ah1.Dispose();
                        if (!ac)
                        {
                            continue;
                        }
                        //when node have kings dangoures ignore and continue.
                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(CastlesOnTable[ik].CastleThinkingQuantum[0].TableListCastle[j]), Order,4));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                        {
                            continue;
                        }
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(4, ik, j) || CastlesOnTable[ik].CastleThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessB || (CastlesOnTable[ik].CastleThinkingQuantum[0].PenaltyRegardListCastle[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[3] = ik;
                                jIndex[3] = j;
                                int Hav = HaveKilled;
                                double pre = PreviousLessB;
                                Task<double> ah3 = Task.Factory.StartNew(() => pre = CastlesOnTable[ik].CastleThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessB = pre;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is greater than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(4, ik, j) || CastlesOnTable[ik].CastleThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessB || (CastlesOnTable[ik].CastleThinkingQuantum[0].PenaltyRegardListCastle[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[3] = ik;
                                jIndex[3] = j;
                                int Hav = HaveKilled;
                                double pre = PreviousLessB;
                                Task<double> ah3 = Task.Factory.StartNew(() => pre = CastlesOnTable[ik].CastleThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessB = pre;
                            }
                        }
                    }
                }
            }
        }

        //blitz for determination about best movment of every objects
        private void BlitzGameThinkingTreeMinisterGray(ref double PreviousLessM, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Minister.
            for (ik = 0; ik < MinisterMidle; ik++)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 5));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    continue;
                }
                //when there is computational lists
                for (j = 0; j < MinisterOnTable[ik].MinisterThinkingQuantum[0].HeuristicListMinister.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 5)
                      )
                    {
                        continue;
                    }
                    //when node is empty deeper and there is not computatiional node continue
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 5, ik, j));
                    ah1.Wait();
                    ah1.Dispose();
                    if (!ac)
                    {
                        continue;
                    }
                    //when node have kings dangoures ignore and continue.
                    Task<bool> ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(MinisterOnTable[ik].MinisterThinkingQuantum[0].TableListMinister[j]), Order,5));
                    ah2.Wait();
                    ah2.Dispose();
                    if (!ac)
                    {
                        continue;
                    }

                    object O = new object();
                    lock (O)
                    {
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(5, ik, j) || MinisterOnTable[ik].MinisterThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessM || (MinisterOnTable[ik].MinisterThinkingQuantum[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[4] = ik;
                                jIndex[4] = j;
                                int Hav = HaveKilled;
                                double pre = PreviousLessM;
                                Task<double> ah3 = Task.Factory.StartNew(() => pre = MinisterOnTable[ik].MinisterThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessM = pre;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is greater than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(5, ik, j) || MinisterOnTable[ik].MinisterThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessM || (MinisterOnTable[ik].MinisterThinkingQuantum[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[4] = ik;
                                jIndex[4] = j;
                                int Hav = HaveKilled;
                                double pre = PreviousLessM;
                                Task<double> ah3 = Task.Factory.StartNew(() => pre = MinisterOnTable[ik].MinisterThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessM = pre;
                            }
                        }
                    }
                }
            }
        }

        //blitz for determination about best movment of every objects
        private void BlitzGameThinkingTreeKingGray(ref double PreviousLessK, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //King.
            for (ik = 0; ik < KingMidle; ik++)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 6));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    continue;
                }
                //when there is computational lists
                for (j = 0; j < KingOnTable[ik].KingThinkingQuantum[0].HeuristicListKing.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 6)
                      )
                    {
                        continue;
                    }

                    object O = new object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 6, ik, j));
                        ah1.Wait();
                        ah1.Dispose();
                        if (!ac)
                        {
                            continue;
                        }
                        //when node have kings dangoures ignore and continue.
                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(KingOnTable[ik].KingThinkingQuantum[0].TableListKing[j]), Order,6));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                        {
                            continue;
                        }
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(6, ik, j) || KingOnTable[ik].KingThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessK || (KingOnTable[ik].KingThinkingQuantum[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[5] = ik;
                                jIndex[5] = j;
                                int Hav = HaveKilled;
                                double pre = PreviousLessK;
                                Task<double> ah3 = Task.Factory.StartNew(() => pre = KingOnTable[ik].KingThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessK = pre;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(6, ik, j) || KingOnTable[ik].KingThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessK || (KingOnTable[ik].KingThinkingQuantum[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[5] = ik;
                                jIndex[5] = j;
                                int Hav = HaveKilled;
                                double pre = PreviousLessK;
                                Task<double> ah3 = Task.Factory.StartNew(() => pre = KingOnTable[ik].KingThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessK = pre;
                            }
                        }
                    }
                }
            }
        }

        //blitz for determination about best movment of every objects
        private void BlitzGameThinkingTreeCastlingGray(ref double PreviousLessCa, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Castling.
            for (ik = 0; ik < 1; ik++)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 7));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    continue;
                }
                //when there is computational lists
                for (j = 0; j < CastlingOnTable[ik].CastlingThinking[0].HeuristicListCastling.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 7)
                      )
                    {
                        continue;
                    }

                    object O = new object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 7, ik, j));
                        ah1.Wait();
                        ah1.Dispose();
                        if (!ac)
                        {
                            continue;
                        }
                        //when node have Castlings dangoures ignore and continue.
                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(CastlingOnTable[ik].CastlingThinking[0].TableListCastling[j]), Order,7));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                        {
                            continue;
                        }
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(7, ik, j) || CastlingOnTable[ik].CastlingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessCa || (CastlingOnTable[ik].CastlingThinking[0].PenaltyRegardListCastling[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[6] = ik;
                                jIndex[6] = j;
                                int Hav = HaveKilled;
                                double pre = PreviousLessCa;
                                Task<double> ah3 = Task.Factory.StartNew(() => pre = CastlingOnTable[ik].CastlingThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessCa = pre;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(6, ik, j) || CastlingOnTable[ik].CastlingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessCa || (CastlingOnTable[ik].CastlingThinking[0].PenaltyRegardListCastling[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[6] = ik;
                                jIndex[6] = j;
                                int Hav = HaveKilled;
                                double pre = PreviousLessCa;
                                Task<double> ah3 = Task.Factory.StartNew(() => pre = CastlingOnTable[ik].CastlingThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessCa = pre;
                            }
                        }
                    }
                }
            }
        }

        //blitz for determination about best movment of every objects
        private void BlitzGameThinkingTreeSolderBrown(ref double PreviousLessS, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            for (ik = SodierMidle; ik < SodierHigh; ik++)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 1));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    continue;
                }
                //Soldier.
                //when there is computational lists
                for (j = 0; j < SolderesOnTable[ik].SoldierThinkingQuantum[0].HeuristicListSolder.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 1)
                   )
                    {
                        continue;
                    }
                    //when node is empty deeper and there is not computatiional node continue
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 1, ik, j));
                    ah1.Wait();
                    ah1.Dispose();
                    if (!ac)
                    {
                        continue;
                    }
                    //when node have kings dangoures ignore and continue.
                    Task<bool> ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(SolderesOnTable[ik].SoldierThinkingQuantum[0].TableListSolder[j]), Order,1));
                    ah2.Wait();
                    ah2.Dispose();
                    if (!ac)
                    {
                        continue;
                    }
                    //when is self
                    if (Order != AllDraw.OrderPlateDraw)
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(1, ik, j) || SolderesOnTable[ik].SoldierThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessS || (SolderesOnTable[ik].SoldierThinkingQuantum[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[0] = ik;
                            jIndex[0] = j;
                            int Hav = HaveKilled;
                            double pre = PreviousLessS;
                            Task<double> ah3 = Task.Factory.StartNew(() => pre = SolderesOnTable[ik].SoldierThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessS = pre;
                        }
                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(1, ik, j) || SolderesOnTable[ik].SoldierThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessS || (SolderesOnTable[ik].SoldierThinkingQuantum[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[0] = ik;
                            jIndex[0] = j;
                            int Hav = HaveKilled;
                            double pre = PreviousLessS;
                            Task<double> ah3 = Task.Factory.StartNew(() => pre = SolderesOnTable[ik].SoldierThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessS = pre;
                        }
                    }
                }
            }
        }

        //blitz for determination about best movment of every objects
        private void BlitzGameThinkingTreeElephantBrown(ref double PreviousLessE, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Elephant
            for (ik = ElefantMidle; ik < ElefantHigh; ik++)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 2));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    continue;
                }
                //when there is computational lists
                for (j = 0; j < ElephantOnTable[ik].ElefantThinkingQuantum[0].HeuristicListElefant.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 2)
                 )
                    {
                        continue;
                    }
                    //when node is empty deeper and there is not computatiional node continue
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 2, ik, j));
                    ah1.Wait();
                    ah1.Dispose();
                    if (!ac)
                    {
                        continue;
                    }
                    //when node have kings dangoures ignore and continue.
                    Task<bool> ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(ElephantOnTable[ik].ElefantThinkingQuantum[0].TableListElefant[j]), Order,2));
                    ah2.Wait();
                    ah2.Dispose();
                    if (!ac)
                    {
                        continue;
                    }
                    //when is self
                    if (Order != AllDraw.OrderPlateDraw)
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(2, ik, j) || ElephantOnTable[ik].ElefantThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessE || (ElephantOnTable[ik].ElefantThinkingQuantum[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[1] = ik;
                            jIndex[1] = j;
                            int Hav = HaveKilled;
                            double pre = PreviousLessE;
                            Task<double> ah3 = Task.Factory.StartNew(() => pre = ElephantOnTable[ik].ElefantThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessE = pre;
                        }
                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(2, ik, j) || ElephantOnTable[ik].ElefantThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessE || (ElephantOnTable[ik].ElefantThinkingQuantum[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[1] = ik;
                            jIndex[1] = j;
                            int Hav = HaveKilled;
                            double pre = PreviousLessE;
                            Task<double> ah3 = Task.Factory.StartNew(() => pre = ElephantOnTable[ik].ElefantThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessE = pre;
                        }
                    }
                }
            }
        }

        //blitz for determination about best movment of every objects
        private void BlitzGameThinkingTreeHourseBrown(ref double PreviousLessH, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Hourse.
            for (ik = HourseMidle; ik < HourseHight; ik++)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 3));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    continue;
                }
                //when there is computational lists
                for (j = 0; j < HoursesOnTable[ik].HourseThinkingQuantum[0].HeuristicListHourse.Count; j++)
                {
                    //when node is serving node continue
                    if (HoursesOnTable[ik].HourseThinkingQuantum[0].IsSupHu[j]
                    )
                    {
                        continue;
                    }
                    //when node is empty deeper and there is not computatiional node continue
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 3, ik, j));
                    ah1.Wait();
                    ah1.Dispose();
                    if (!ac)
                    {
                        continue;
                    }
                    //when node have kings dangoures ignore and continue.
                    Task<bool> ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(HoursesOnTable[ik].HourseThinkingQuantum[0].TableListHourse[j]), Order,3));
                    ah2.Wait();
                    ah2.Dispose();
                    if (!ac)
                    {
                        continue;
                    }
                    //when is self
                    if (Order != AllDraw.OrderPlateDraw)
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(3, ik, j) || HoursesOnTable[ik].HourseThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessH || (HoursesOnTable[ik].HourseThinkingQuantum[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[2] = ik;
                            jIndex[2] = j;
                            int Hav = HaveKilled;
                            double pre = PreviousLessH;
                            Task<double> ah3 = Task.Factory.StartNew(() => pre = HoursesOnTable[ik].HourseThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessH = pre;
                        }
                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(3, ik, j) || HoursesOnTable[ik].HourseThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessH || (HoursesOnTable[ik].HourseThinkingQuantum[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[2] = ik;
                            jIndex[2] = j;
                            int Hav = HaveKilled;
                            double pre = PreviousLessH;
                            Task<double> ah3 = Task.Factory.StartNew(() => pre = HoursesOnTable[ik].HourseThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessH = pre;
                        }
                    }
                }
            }
        }

        private bool AllIndexIsNull(int[] iIndex)
        {
            bool Is = true;
            for (int i = 0; i < 6; i++)
            {
                if (iIndex[i] != -1)
                {
                    Is = false;
                }
            }
            return Is;
        }

        //main blitz for determination about best movment of every objects
        public int FullGameMakimgBlitz(ref int[] Index, ref int[] jIndex, int Order, int LeafAStarGreedy)
        {
            int Kind = -1;
            double PS = double.MinValue, PE = double.MinValue, PH = double.MinValue, PB = double.MinValue, PM = double.MinValue, PK = double.MinValue, PA = double.MinValue;
            if (Order != AllDraw.OrderPlateDraw)
            {
                PS = double.MaxValue;
                PE = double.MaxValue;
                PH = double.MaxValue;
                PB = double.MaxValue;
                PM = double.MaxValue;
                PK = double.MaxValue;
                PA = double.MaxValue;
            }
            int[] index = { -1, -1, -1, -1, -1, -1, -1 };
            int[] jindex = { -1, -1, -1, -1, -1, -1, -1 };
            if (Order == 1)
            {
                object O = new object();
                lock (O)
                {
                    BlitzGameThinkingTreeSolderGray(ref PS, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeElephantGray(ref PE, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeHourseGray(ref PH, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeCastleGray(ref PB, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeMinisterGray(ref PM, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeKingGray(ref PK, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeCastlingGray(ref PA, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);

                    if (AllIndexIsNull(index))
                    {
                        Kind = -1;
                        PS = int.MinValue; PE = int.MinValue; PH = int.MinValue; PB = int.MinValue; PM = int.MinValue; PK = int.MinValue; PA = int.MinValue;
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            PS = double.MaxValue;
                            PE = double.MaxValue;
                            PH = double.MaxValue;
                            PB = double.MaxValue;
                            PM = double.MaxValue;
                            PK = double.MaxValue;
                            PA = double.MaxValue;
                        }
                        for (int h = 0; h < 7; h++)
                        {
                            index[h] = -1;
                            jindex[h] = -1;
                        }
                        UsedRestrictedMoveBlitzAndFull = false;
                        BlitzGameThinkingTreeSolderGray(ref PS, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeElephantGray(ref PE, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeHourseGray(ref PH, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeCastleGray(ref PB, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeMinisterGray(ref PM, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeKingGray(ref PK, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeCastlingGray(ref PA, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    }
                }
            }
            else
            {
                object O = new object();
                lock (O)
                {
                    BlitzGameThinkingTreeSolderBrown(ref PS, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeElephantBrown(ref PE, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeHourseBrown(ref PH, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeCastleBrown(ref PB, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeMinisterBrown(ref PM, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeKingBrown(ref PK, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeCastlingBrown(ref PA, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    if (AllIndexIsNull(index))
                    {
                        Kind = -1;
                        PS = int.MinValue; PE = int.MinValue; PH = int.MinValue; PB = int.MinValue; PM = int.MinValue; PK = int.MinValue; PA = int.MinValue;
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            PS = double.MaxValue;
                            PE = double.MaxValue;
                            PH = double.MaxValue;
                            PB = double.MaxValue;
                            PM = double.MaxValue;
                            PK = double.MaxValue;
                            PA = double.MaxValue;
                        }
                        for (int h = 0; h < 7; h++)
                        {
                            index[h] = -1;
                            jindex[h] = -1;
                        }
                        UsedRestrictedMoveBlitzAndFull = false;
                        BlitzGameThinkingTreeSolderBrown(ref PS, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeElephantBrown(ref PE, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeHourseBrown(ref PH, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeCastleBrown(ref PB, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeMinisterBrown(ref PM, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeKingBrown(ref PK, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeCastlingBrown(ref PA, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    }
                }
            }
            double JI = -1;
            object O1 = new object();
            lock (O1)
            {
                if (Order == OrderPlate)
                {
                    JI = MaxOfSixHeuristic(PS, PE, PH, PB, PM, PK, PA);
                }
                else
                {
                    JI = MinOfSixHeuristic(PS, PE, PH, PB, PM, PK, PA);
                }
            }
            if (JI != -1)
            {
                Kind = (int)JI;
                for (int i = 0; i < 7; i++)
                {
                    object O = new object();
                    lock (O)
                    {
                        Index[i] = index[i];
                        jIndex[i] = jindex[i];
                    }
                }
            }
            return System.Math.Abs(Kind);
        }

        //blitz for determination about best movment of every objects
        private void BlitzGameThinkingTreeCastleBrown(ref double PreviousLessB, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Castles.
            for (ik = CastleMidle; ik < CastleHigh; ik++)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 4));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    continue;
                }
                //when there is computational lists
                for (j = 0; j < CastlesOnTable[ik].CastleThinkingQuantum[0].HeuristicListCastle.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 4)
                    )
                    {
                        continue;
                    }
                    //when node is empty deeper and there is not computatiional node continue
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 4, ik, j));
                    ah1.Wait();
                    ah1.Dispose();
                    if (!ac)
                    {
                        continue;
                    }
                    //when node have kings dangoures ignore and continue.
                    Task<bool> ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(CastlesOnTable[ik].CastleThinkingQuantum[0].TableListCastle[j]), Order,4));
                    ah2.Wait();
                    ah2.Dispose();
                    if (!ac)
                    {
                        continue;
                    }
                    //when is self
                    if (Order != AllDraw.OrderPlateDraw)
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(4, ik, j) || CastlesOnTable[ik].CastleThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessB || (CastlesOnTable[ik].CastleThinkingQuantum[0].PenaltyRegardListCastle[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[3] = ik;
                            jIndex[3] = j;
                            int Hav = HaveKilled;
                            double pre = PreviousLessB;

                            Task<double> ah3 = Task.Factory.StartNew(() => pre = CastlesOnTable[ik].CastleThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessB = pre;
                        }
                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(4, ik, j) || CastlesOnTable[ik].CastleThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessB || (CastlesOnTable[ik].CastleThinkingQuantum[0].PenaltyRegardListCastle[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[3] = ik;
                            jIndex[3] = j;
                            int Hav = HaveKilled;
                            double pre = PreviousLessB;
                            Task<double> ah3 = Task.Factory.StartNew(() => pre = CastlesOnTable[ik].CastleThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessB = pre;
                        }
                    }
                }
            }
        }

        //blitz for determination about best movment of every objects
        private void BlitzGameThinkingTreeMinisterBrown(ref double PreviousLessM, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Minister.
            for (ik = MinisterMidle; ik < MinisterHigh; ik++)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 5));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    continue;
                }
                //when there is computational lists
                for (j = 0; j < MinisterOnTable[ik].MinisterThinkingQuantum[0].HeuristicListMinister.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 5)
                      )
                    {
                        continue;
                    }
                    //when node is empty deeper and there is not computatiional node continue
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 5, ik, j));
                    ah1.Wait();
                    ah1.Dispose();
                    if (!ac)
                    {
                        continue;
                    }
                    //when node have kings dangoures ignore and continue.
                    Task<bool> ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(MinisterOnTable[ik].MinisterThinkingQuantum[0].TableListMinister[j]), Order,5));
                    ah2.Wait();
                    ah2.Dispose();
                    if (!ac)
                    {
                        continue;
                    }
                    //when is self
                    if (Order != AllDraw.OrderPlateDraw)
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(5, ik, j) || MinisterOnTable[ik].MinisterThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessM || (MinisterOnTable[ik].MinisterThinkingQuantum[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        //if (KingDan(MinisterOnTable[ik].MinisterThinkingQuantum[0].TableListMinister[j], Order))
                        {
                            Index[4] = ik;
                            jIndex[4] = j;
                            int Hav = HaveKilled;
                            double pre = PreviousLessM;
                            Task<double> ah3 = Task.Factory.StartNew(() => pre = MinisterOnTable[ik].MinisterThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessM = pre;
                        }
                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(5, ik, j) || MinisterOnTable[ik].MinisterThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessM || (MinisterOnTable[ik].MinisterThinkingQuantum[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        //if (KingDan(MinisterOnTable[ik].MinisterThinkingQuantum[0].TableListMinister[j], Order))
                        {
                            Index[4] = ik;
                            jIndex[4] = j;
                            int Hav = HaveKilled;
                            double pre = PreviousLessM;
                            Task<double> ah3 = Task.Factory.StartNew(() => pre = MinisterOnTable[ik].MinisterThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessM = pre;
                        }
                    }
                }
            }
        }

        //blitz for determination about best movment of every objects
        private void BlitzGameThinkingTreeKingBrown(ref double PreviousLessK, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //King.
            for (ik = KingMidle; ik < KingHigh; ik++)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 6));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    continue;
                }
                //when there is computational lists
                for (j = 0; j < KingOnTable[ik].KingThinkingQuantum[0].HeuristicListKing.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 6)
                     )
                    {
                        continue;
                    }
                    //when node is empty deeper and there is not computatiional node continue
                    Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 6, ik, j));
                    ah1.Wait();
                    ah1.Dispose();
                    if (!ac)
                    {
                        continue;
                    }
                    //when node have kings dangoures ignore and continue.
                    Task<bool> ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(KingOnTable[ik].KingThinkingQuantum[0].TableListKing[j]), Order,6));
                    ah2.Wait();
                    ah2.Dispose();
                    if (!ac)
                    {
                        continue;
                    }
                    //when is self
                    if (Order != AllDraw.OrderPlateDraw)
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(6, ik, j) || KingOnTable[ik].KingThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessK || (KingOnTable[ik].KingThinkingQuantum[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[5] = ik;
                            jIndex[5] = j;
                            int Hav = HaveKilled;
                            double pre = PreviousLessK;
                            Task<double> ah3 = Task.Factory.StartNew(() => pre = KingOnTable[ik].KingThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessK = pre;
                        }
                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(6, ik, j) || KingOnTable[ik].KingThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessK || (KingOnTable[ik].KingThinkingQuantum[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[5] = ik;
                            jIndex[5] = j;
                            int Hav = HaveKilled;
                            double pre = PreviousLessK;
                            Task<double> ah3 = Task.Factory.StartNew(() => pre = KingOnTable[ik].KingThinkingQuantum[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessK = pre;
                        }
                    }
                }
            }
        }

        //blitz for determination about best movment of every objects
        private void BlitzGameThinkingTreeCastlingBrown(ref double PreviousLessK, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Castling.
            for (ik = 0; ik < 1; ik++)
            {
                bool ac = false;
                Task<bool> ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, -7));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    continue;
                }
                //when there is computational lists
                for (j = 0; j < CastlingOnTable[ik].CastlingThinking[0].HeuristicListCastling.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 7)
                      )
                    {
                        continue;
                    }

                    object O = new object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        Task<bool> ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 7, ik, j));
                        ah1.Wait();
                        ah1.Dispose();
                        if (!ac)
                        {
                            continue;
                        }
                        //when node have Castlings dangoures ignore and continue.
                        Task<bool> ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(CastlingOnTable[ik].CastlingThinking[0].TableListCastling[j]), Order,7));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                        {
                            continue;
                        }
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(7, ik, j) || CastlingOnTable[ik].CastlingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessK || (CastlingOnTable[ik].CastlingThinking[0].PenaltyRegardListCastling[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[6] = ik;
                                jIndex[6] = j;
                                int Hav = HaveKilled;
                                double pre = PreviousLessK;
                                Task<double> ah3 = Task.Factory.StartNew(() => pre = CastlingOnTable[ik].CastlingThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessK = pre;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(6, ik, j) || CastlingOnTable[ik].CastlingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessK || (CastlingOnTable[ik].CastlingThinking[0].PenaltyRegardListCastling[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[6] = ik;
                                jIndex[6] = j;
                                int Hav = HaveKilled;
                                double pre = PreviousLessK;
                                Task<double> ah3 = Task.Factory.StartNew(() => pre = CastlingOnTable[ik].CastlingThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessK = pre;
                            }
                        }
                    }
                }
            }
        }

        //calculate statistic Move
        private string Alphabet(int RowRealesed)
        {
            string A = "";
            if (RowRealesed == 0)
            {
                A = "a";
            }
            else
                if (RowRealesed == 1)
            {
                A = "b";
            }
            else
                    if (RowRealesed == 2)
            {
                A = "c";
            }
            else
                        if (RowRealesed == 3)
            {
                A = "d";
            }
            else
                            if (RowRealesed == 4)
            {
                A = "e";
            }
            else
                                if (RowRealesed == 5)
            {
                A = "f";
            }
            else
                                    if (RowRealesed == 6)
            {
                A = "g";
            }
            else
                                        if (RowRealesed == 7)
            {
                A = "h";
            }

            return A;
        }

        //calculate statistic Move
        private string Number(int ColumnRealeased)
        {
            string A = "";
            if (ColumnRealeased == 7)
            {
                A = "0";
            }
            else
                if (ColumnRealeased == 6)
            {
                A = "1";
            }
            else
                    if (ColumnRealeased == 5)
            {
                A = "2";
            }
            else
                        if (ColumnRealeased == 4)
            {
                A = "3";
            }
            else
                            if (ColumnRealeased == 3)
            {
                A = "4";
            }
            else
                                if (ColumnRealeased == 2)
            {
                A = "5";
            }
            else
                                    if (ColumnRealeased == 1)
            {
                A = "6";
            }
            else
                                        if (ColumnRealeased == 0)
            {
                A = "7";
            }

            return A;
        }

        //number of bounry object
        private int SumOfObjects(AllDraw A, int Order)
        {
            int Sum = 0;
            if (A == null)
            {
                return Sum;
            }

            if (Order == 1)
            {
                for (int i = 0; i < A.SodierMidle; i++)
                {
                    Sum += SumOfObjectsS(i, A, Order);
                }
                for (int i = 0; i < A.ElefantMidle; i++)
                {
                    Sum += SumOfObjectsE(i, A, Order);
                }
                for (int i = 0; i < A.HourseMidle; i++)
                {
                    Sum += SumOfObjectsH(i, A, Order);
                }
                for (int i = 0; i < A.CastleMidle; i++)
                {
                    Sum += SumOfObjectsC(i, A, Order);
                }
                for (int i = 0; i < A.MinisterMidle; i++)
                {
                    Sum += SumOfObjectsM(i, A, Order);
                }
                for (int i = 0; i < A.KingMidle; i++)
                {
                    Sum += SumOfObjectsK(i, A, Order);
                }
                for (int i = 0; i < 1; i++)
                {
                    Sum += SumOfObjectsA(i, A, Order);
                }
            }
            else
            {
                for (int i = A.SodierMidle; i < A.SodierHigh; i++)
                {
                    Sum += SumOfObjectsS(i, A, Order);
                }
                for (int i = A.ElefantMidle; i < A.ElefantHigh; i++)
                {
                    Sum += SumOfObjectsE(i, A, Order);
                }
                for (int i = A.HourseMidle; i < A.HourseHight; i++)
                {
                    Sum += SumOfObjectsH(i, A, Order);
                }
                for (int i = A.CastleMidle; i < A.CastleHigh; i++)
                {
                    Sum += SumOfObjectsC(i, A, Order);
                }
                for (int i = A.MinisterMidle; i < A.MinisterHigh; i++)
                {
                    Sum += SumOfObjectsM(i, A, Order);
                }
                for (int i = A.KingMidle; i < A.KingHigh; i++)
                {
                    Sum += SumOfObjectsK(i, A, Order);
                }
                for (int i = 0; i < 1; i++)
                {
                    Sum += SumOfObjectsA(i, A, Order);
                }
            }

            return Sum;
        }

        private int SumOfObjectsS(int i, AllDraw A, int Order)
        {
            int Sum = 0;
            if (A == null)
            {
                return Sum;
            }

            try
            {

                if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null)
                {
                    Sum += A.SolderesOnTable[i].WinOcuuredatChiled;
                }


            }
            catch (Exception t) { Log(t); }
            return Sum;
        }
        private int SumOfObjectsE(int i, AllDraw A, int Order)
        {
            int Sum = 0;
            if (A == null)
            {
                return Sum;
            }

            try
            {
                if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null)
                {
                    Sum += A.ElephantOnTable[i].WinOcuuredatChiled;
                }

            }
            catch (Exception t) { Log(t); }

            return Sum;
        }
        private int SumOfObjectsH(int i, AllDraw A, int Order)
        {
            int Sum = 0;
            if (A == null)
            {
                return Sum;
            }

            try
            {
                if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null)
                {
                    Sum += A.HoursesOnTable[i].WinOcuuredatChiled;
                }
            }
            catch (Exception t) { Log(t); }


            return Sum;
        }
        private int SumOfObjectsC(int i, AllDraw A, int Order)
        {
            int Sum = 0;
            if (A == null)
            {
                return Sum;
            }

            try
            {
                if (A.CastlesOnTable != null && A.CastlesOnTable[i] != null)
                {
                    Sum += A.CastlesOnTable[i].WinOcuuredatChiled;
                }
            }
            catch (Exception t) { Log(t); }


            return Sum;
        }
        private int SumOfObjectsM(int i, AllDraw A, int Order)
        {
            int Sum = 0;
            if (A == null)
            {
                return Sum;
            }

            try
            {
                if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null)
                {
                    Sum += A.MinisterOnTable[i].WinOcuuredatChiled;
                }
            }
            catch (Exception t) { Log(t); }


            return Sum;
        }
        private int SumOfObjectsK(int i, AllDraw A, int Order)
        {
            int Sum = 0;
            if (A == null)
            {
                return Sum;
            }

            try
            {
                if (A.KingOnTable != null && A.KingOnTable[i] != null)
                {
                    Sum += A.KingOnTable[i].WinOcuuredatChiled;
                }
            }
            catch (Exception t) { Log(t); }


            return Sum;
        }
        private int SumOfObjectsA(int i, AllDraw A, int Order)
        {
            int Sum = 0;
            if (A == null)
            {
                return Sum;
            }

            try
            {
                if (A.CastlingOnTable != null && A.CastlingOnTable[i] != null)
                {
                    Sum += A.CastlingOnTable[i].WinOcuuredatChiled;
                }
            }
            catch (Exception t) { Log(t); }


            return Sum;
        }
        private bool IsAtleastAWin(AllDraw A, int Order)
        {
            bool Sum = false;
            if (A == null)
            {
                return Sum;
            }

            if (Order == 1)
            {
                for (int i = 0; i < A.SodierMidle; i++)
                {
                    if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null)
                    {
                        if (A.SolderesOnTable[i].WinOcuuredatChiled != 0)
                        {
                            Sum = true;
                        }
                    }
                }
                for (int i = 0; i < A.ElefantMidle; i++)
                {
                    if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null)
                    {
                        if (A.ElephantOnTable[i].WinOcuuredatChiled != 0)
                        {
                            Sum = true;
                        }
                    }
                }
                for (int i = 0; i < A.HourseMidle; i++)
                {
                    if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null)
                    {
                        if (A.HoursesOnTable[i].WinOcuuredatChiled != 0)
                        {
                            Sum = true;
                        }
                    }
                }
                for (int i = 0; i < A.CastleMidle; i++)
                {
                    if (A.CastlesOnTable != null && A.CastlesOnTable[i] != null)
                    {
                        if (A.CastlesOnTable[i].WinOcuuredatChiled != 0)
                        {
                            Sum = true;
                        }
                    }
                }
                for (int i = 0; i < A.MinisterMidle; i++)
                {
                    if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null)
                    {
                        if (A.MinisterOnTable[i].WinOcuuredatChiled != 0)
                        {
                            Sum = true;
                        }
                    }
                }
                for (int i = 0; i < A.KingMidle; i++)
                {
                    if (A.KingOnTable != null && A.KingOnTable[i] != null)
                    {
                        if (A.KingOnTable[i].WinOcuuredatChiled != 0)
                        {
                            Sum = true;
                        }
                    }
                }
                for (int i = 0; i < 1; i++)
                {
                    if (A.CastlingOnTable != null && A.CastlingOnTable[i] != null)
                    {
                        if (A.CastlingOnTable[i].WinOcuuredatChiled != 0)
                        {
                            Sum = true;
                        }
                    }
                }
            }
            else
            {
                for (int i = A.SodierMidle; i < A.SodierHigh; i++)
                {
                    if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null)
                    {
                        if (A.SolderesOnTable[i].WinOcuuredatChiled != 0)
                        {
                            Sum = true;
                        }
                    }
                }
                for (int i = A.ElefantMidle; i < A.ElefantHigh; i++)
                {
                    if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null)
                    {
                        if (A.ElephantOnTable[i].WinOcuuredatChiled != 0)
                        {
                            Sum = true;
                        }
                    }
                }
                for (int i = A.HourseMidle; i < A.HourseHight; i++)
                {
                    if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null)
                    {
                        if (A.HoursesOnTable[i].WinOcuuredatChiled != 0)
                        {
                            Sum = true;
                        }
                    }
                }
                for (int i = A.CastleMidle; i < A.CastleHigh; i++)
                {
                    if (A.CastlesOnTable != null && A.CastlesOnTable[i] != null)
                    {
                        if (A.CastlesOnTable[i].WinOcuuredatChiled != 0)
                        {
                            Sum = true;
                        }
                    }
                }
                for (int i = A.MinisterMidle; i < A.MinisterHigh; i++)
                {
                    if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null)
                    {
                        if (A.MinisterOnTable[i].WinOcuuredatChiled != 0)
                        {
                            Sum = true;
                        }
                    }
                }
                for (int i = A.KingMidle; i < A.KingHigh; i++)
                {
                    if (A.KingOnTable != null && A.KingOnTable[i] != null)
                    {
                        if (A.KingOnTable[i].WinOcuuredatChiled != 0)
                        {
                            Sum = true;
                        }
                    }
                }
                for (int i = 0; i < 1; i++)
                {
                    if (A.CastlingOnTable != null && A.CastlingOnTable[i] != null)
                    {
                        if (A.CastlingOnTable[i].WinOcuuredatChiled != 0)
                        {
                            Sum = true;
                        }
                    }
                }
            }
            return Sum;
        }

        //victome transfer leafs to rooots chiled
        private int SumMinusOfObjects(AllDraw A, int Order)
        {
            int Sum = 0;
            if (!IsAtleastAWin(A, Order))
            {
                if (A == null)
                {
                    return Sum;
                }

                if (Order == 1)
                {
                    for (int i = 0; i < A.SodierMidle; i++)
                    {
                        Sum += SumMinusOfObjectsS(i, A, Order);
                    }
                    for (int i = 0; i < A.ElefantMidle; i++)
                    {
                        Sum += SumMinusOfObjectsE(i, A, Order);
                    }
                    for (int i = 0; i < A.HourseMidle; i++)
                    {
                        Sum += SumMinusOfObjectsH(i, A, Order);
                    }
                    for (int i = 0; i < A.CastleMidle; i++)
                    {
                        Sum += SumMinusOfObjectsC(i, A, Order);
                    }
                    for (int i = 0; i < A.MinisterMidle; i++)
                    {
                        Sum += SumMinusOfObjectsM(i, A, Order);
                    }
                    for (int i = 0; i < A.KingMidle; i++)
                    {
                        Sum += SumMinusOfObjectsK(i, A, Order);
                    }
                    for (int i = 0; i < 1; i++)
                    {
                        Sum += SumMinusOfObjectsA(i, A, Order);
                    }
                }
                else
                {
                    for (int i = A.SodierMidle; i < A.SodierHigh; i++)
                    {
                        Sum += SumMinusOfObjectsS(i, A, Order);
                    }
                    for (int i = A.ElefantMidle; i < A.ElefantHigh; i++)
                    {
                        Sum += SumMinusOfObjectsE(i, A, Order);
                    }
                    for (int i = A.HourseMidle; i < A.HourseHight; i++)
                    {
                        Sum += SumMinusOfObjectsH(i, A, Order);
                    }
                    for (int i = A.CastleMidle; i < A.CastleHigh; i++)
                    {
                        Sum += SumMinusOfObjectsC(i, A, Order);
                    }
                    for (int i = A.MinisterMidle; i < A.MinisterHigh; i++)
                    {
                        Sum += SumMinusOfObjectsM(i, A, Order);
                    }
                    for (int i = A.KingMidle; i < A.KingHigh; i++)
                    {
                        Sum += SumMinusOfObjectsK(i, A, Order);
                    }
                    for (int i = 0; i < 1; i++)
                    {
                        Sum += SumMinusOfObjectsA(i, A, Order);
                    }
                }
            }
            return Sum;
        }

        private int SumMinusOfObjectsS(int i, AllDraw A, int Order)
        {
            int Sum = 0;
            if (!IsAtleastAWin(A, Order))
            {
                if (A == null)
                {
                    return Sum;
                }

                try
                {
                    if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null && A.SolderesOnTable[i].LoseOcuuredatChiled[0] <= 0)
                    {
                        Sum += A.SolderesOnTable[i].LoseOcuuredatChiled[0];
                    }
                    else if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null && A.SolderesOnTable[i].LoseOcuuredatChiled[0] == 5)
                    {
                        Sum = A.SolderesOnTable[i].LoseOcuuredatChiled[0];
                    }

                    if (Sum == 5)
                    {
                        if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 1, Order, i))
                        {
                            A.SolderesOnTable[i].WinOcuuredatChiled = Sum = 5;
                            return Sum;
                        }
                    }
                }
                catch (Exception t) { Log(t); }
            }
            return Sum;
        }
        private int SumMinusOfObjectsE(int i, AllDraw A, int Order)
        {
            int Sum = 0;
            if (!IsAtleastAWin(A, Order))
            {
                if (A == null)
                {
                    return Sum;
                }

                try
                {
                    if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null && A.ElephantOnTable[i].LoseOcuuredatChiled[0] <= 0)
                    {
                        Sum += A.ElephantOnTable[i].LoseOcuuredatChiled[0];
                    }
                    else if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null && A.ElephantOnTable[i].LoseOcuuredatChiled[0] == 5)
                    {
                        Sum = A.ElephantOnTable[i].LoseOcuuredatChiled[0];
                    }

                    if (Sum == 5)
                    {
                        if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 2, Order, i))
                        {
                            A.ElephantOnTable[i].WinOcuuredatChiled = Sum = 5;
                            return Sum;
                        }
                    }
                }
                catch (Exception t) { Log(t); }

            }
            return Sum;
        }
        private int SumMinusOfObjectsH(int i, AllDraw A, int Order)
        {
            int Sum = 0;
            if (!IsAtleastAWin(A, Order))
            {
                if (A == null)
                {
                    return Sum;
                }

                try
                {
                    if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null && A.HoursesOnTable[i].LoseOcuuredatChiled[0] <= 0)
                    {
                        Sum += A.HoursesOnTable[i].LoseOcuuredatChiled[0];
                    }
                    else if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null && A.HoursesOnTable[i].LoseOcuuredatChiled[0] == 5)
                    {
                        Sum = A.HoursesOnTable[i].LoseOcuuredatChiled[0];
                    }

                    if (Sum == 5)
                    {
                        if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 3, Order, i))
                        {
                            A.SolderesOnTable[i].WinOcuuredatChiled = Sum = 5;
                            return Sum;
                        }
                    }
                }
                catch (Exception t) { Log(t); }

            }
            return Sum;
        }
        private int SumMinusOfObjectsC(int i, AllDraw A, int Order)
        {
            int Sum = 0;
            if (!IsAtleastAWin(A, Order))
            {
                if (A == null)
                {
                    return Sum;
                }

                try
                {
                    if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null && A.HoursesOnTable[i].LoseOcuuredatChiled[0] <= 0)
                    {
                        Sum += A.HoursesOnTable[i].LoseOcuuredatChiled[0];
                    }
                    else if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null && A.HoursesOnTable[i].LoseOcuuredatChiled[0] == 5)
                    {
                        Sum = A.HoursesOnTable[i].LoseOcuuredatChiled[0];
                    }

                    if (Sum == 5)
                    {
                        if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 4, Order, i))
                        {
                            A.HoursesOnTable[i].WinOcuuredatChiled = Sum = 5;
                            return Sum;
                        }
                    }
                }
                catch (Exception t) { Log(t); }

            }
            return Sum;
        }
        private int SumMinusOfObjectsM(int i, AllDraw A, int Order)
        {
            int Sum = 0;
            if (!IsAtleastAWin(A, Order))
            {
                if (A == null)
                {
                    return Sum;
                }

                try
                {
                    if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null && A.MinisterOnTable[i].LoseOcuuredatChiled[0] <= 0)
                    {
                        Sum += A.MinisterOnTable[i].LoseOcuuredatChiled[0];
                    }
                    else if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null && A.MinisterOnTable[i].LoseOcuuredatChiled[0] == 5)
                    {
                        Sum = A.MinisterOnTable[i].LoseOcuuredatChiled[0];
                    }

                    if (Sum == 5)
                    {
                        if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 5, Order, i))
                        {
                            A.MinisterOnTable[i].WinOcuuredatChiled = Sum = 5;
                            return Sum;
                        }
                    }
                }
                catch (Exception t) { Log(t); }

            }
            return Sum;
        }
        private int SumMinusOfObjectsK(int i, AllDraw A, int Order)
        {
            int Sum = 0;
            if (!IsAtleastAWin(A, Order))
            {
                if (A == null)
                {
                    return Sum;
                }

                try
                {
                    if (A.KingOnTable != null && A.KingOnTable[i] != null && A.KingOnTable[i].LoseOcuuredatChiled[0] <= 0)
                    {
                        Sum += A.KingOnTable[i].LoseOcuuredatChiled[0];
                    }
                    else if (A.KingOnTable != null && A.KingOnTable[i] != null && A.KingOnTable[i].LoseOcuuredatChiled[0] == 5)
                    {
                        Sum = A.KingOnTable[i].LoseOcuuredatChiled[0];
                    }

                    if (Sum == 5)
                    {
                        if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 6, Order, i))
                        {
                            A.KingOnTable[i].WinOcuuredatChiled = Sum = 5;
                            return Sum;
                        }
                    }
                }
                catch (Exception t) { Log(t); }

            }
            return Sum;
        }
        private int SumMinusOfObjectsA(int i, AllDraw A, int Order)
        {
            int Sum = 0;
            if (!IsAtleastAWin(A, Order))
            {
                if (A == null)
                {
                    return Sum;
                }

                try
                {
                    if (A.CastlingOnTable != null && A.CastlingOnTable[i] != null && A.CastlingOnTable[i].LoseOcuuredatChiled[0] <= 0)
                    {
                        Sum += A.CastlingOnTable[i].LoseOcuuredatChiled[0];
                    }
                    else if (A.CastlingOnTable != null && A.CastlingOnTable[i] != null && A.CastlingOnTable[i].LoseOcuuredatChiled[0] == 5)
                    {
                        Sum = A.CastlingOnTable[i].LoseOcuuredatChiled[0];
                    }

                    if (Sum == 5)
                    {
                        if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 7, Order, i))
                        {
                            A.CastlingOnTable[i].WinOcuuredatChiled = Sum = 5;
                            return Sum;
                        }
                    }
                }
                catch (Exception t) { Log(t); }

            }
            return Sum;
        }

        //Semaphore determination about Thinking operational completed.
        private bool ReturnFullGameThinkingTreeSemaphore(int ik, int kind)
        {
            //soldier
            if (kind == 1)
            {
                if (SolderesOnTable[ik].SoldierThinkingQuantum[0].ThinkingBegin && (!SolderesOnTable[ik].SoldierThinkingQuantum[0].ThinkingFinished))
                {
                    return true;
                }
            }
            else//elephant
                if (kind == 2)
            {
                if (ElephantOnTable[ik].ElefantThinkingQuantum[0].ThinkingBegin && (!ElephantOnTable[ik].ElefantThinkingQuantum[0].ThinkingFinished))
                {
                    return true;
                }
            }
            else if (kind == 3)//hourse
            {
                if (HoursesOnTable[ik].HourseThinkingQuantum[0].ThinkingBegin && (!HoursesOnTable[ik].HourseThinkingQuantum[0].ThinkingFinished))
                {
                    return true;
                }
            }
            else if (kind == 4)//Castle
            {
                if (CastlesOnTable[ik].CastleThinkingQuantum[0].ThinkingBegin && (!CastlesOnTable[ik].CastleThinkingQuantum[0].ThinkingFinished))
                {
                    return true;
                }
            }
            else
                if (kind == 5)//minister
            {
                if (MinisterOnTable[ik].MinisterThinkingQuantum[0].ThinkingBegin && (!MinisterOnTable[ik].MinisterThinkingQuantum[0].ThinkingFinished))
                {
                    return true;
                }
            }
            else if (kind == 6)//king
            {
                if (KingOnTable[ik].KingThinkingQuantum[0].ThinkingBegin && (!KingOnTable[ik].KingThinkingQuantum[0].ThinkingFinished))
                {
                    return true;
                }
            }
            else if (kind == 7 || kind == -7)//king
            {
                if (CastlingOnTable[ik].CastlingThinking[0].ThinkingBegin && (!CastlingOnTable[ik].CastlingThinking[0].ThinkingFinished))
                {
                    return true;
                }
            }

            return false;
        }

        //determination about learning autamata semaphores permit of operational computational
        private bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(int ik, int kind, bool Penalty, int j)
        {
            //when is learning autamata
            if (Penalty)
            {
                ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreePenaly(ik, kind, Penalty, j);
            }
            else//Brown
            {
                ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeNotPenalty(ik, kind, Penalty, j);
            }

            return false;
        }

        //determination about learning autamata semaphores permit of operational computational
        private bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreePenaly(int ik, int kind, bool Penalty, int j)
        {
            if (kind == 1)//soldier
            {
                ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeSolierP(ik, kind, Penalty, j);
            }
            else
                     if (kind == 2)//elephant
            {
                ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeElephantP(ik, kind, Penalty, j);
            }
            else if (kind == 3)//hourse
            {
                ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeHourseP(ik, kind, Penalty, j);
            }
            else if (kind == 4)//Castle
            {
                ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeCastleP(ik, kind, Penalty, j);
            }
            else
                if (kind == 5)//minister
            {
                ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeMinisterP(ik, kind, Penalty, j);
            }
            else if (kind == 6)//king
            {
                ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeKingP(ik, kind, Penalty, j);
            }
            else if (kind == 7 || kind == -7)//king
            {
                ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeCastlingP(ik, kind, Penalty, j);
            }
            return false;
        }

        //determination about learning autamata semaphores permit of operational computational
        private bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeNotPenalty(int ik, int kind, bool Penalty, int j)
        {
            if (kind == 1)//soldier
            {
                ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeSolier(ik, kind, Penalty, j);
            }
            else
                     if (kind == 2)//elephant
            {
                ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeElephant(ik, kind, Penalty, j);
            }
            else if (kind == 3)//hourse
            {
                ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeHourse(ik, kind, Penalty, j);
            }
            else if (kind == 4)//Castle
            {
                ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeCastle(ik, kind, Penalty, j);
            }
            else
                if (kind == 5)//minister
            {
                ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeMinister(ik, kind, Penalty, j);
            }
            else if (kind == 6)//king
            {
                ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeKing(ik, kind, Penalty, j);
            }
            else if (kind == 7 || kind == -7)//king
            {
                ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeCastling(ik, kind, Penalty, j);
            }
            return false;
        }

        //determination about learning autamata semaphores permit of operational computational
        private bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeSolierP(int ik, int kind, bool Penalty, int j)
        {
            try
            {
                if (SolderesOnTable[ik].SoldierThinkingQuantum[0].PenaltyRegardListSolder[j].IsPenaltyAction() != 0)
                {
                    return true;
                }
            }
            catch (Exception t) { Log(t); }

            return !UsePenaltyRegardMechnisamT;
        }

        //determination about learning autamata semaphores permit of operational computational
        private bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeElephantP(int ik, int kind, bool Penalty, int j)
        {
            try
            {
                if (ElephantOnTable[ik].ElefantThinkingQuantum[0].PenaltyRegardListElefant[j].IsPenaltyAction() != 0)
                {
                    return true;
                }
            }
            catch (Exception t) { Log(t); }
            return !UsePenaltyRegardMechnisamT;
        }

        //determination about learning autamata semaphores permit of operational computational
        private bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeHourseP(int ik, int kind, bool Penalty, int j)
        {
            try
            {
                if (HoursesOnTable[ik].HourseThinkingQuantum[0].PenaltyRegardListHourse[j].IsPenaltyAction() != 0)
                {
                    return true;
                }
            }
            catch (Exception t) { Log(t); }
            return !UsePenaltyRegardMechnisamT;
        }

        //determination about learning autamata semaphores permit of operational computational
        private bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeCastleP(int ik, int kind, bool Penalty, int j)
        {
            try
            {
                if (CastlesOnTable[ik].CastleThinkingQuantum[0].PenaltyRegardListCastle[j].IsPenaltyAction() != 0)
                {
                    return true;
                }
            }
            catch (Exception t) { Log(t); }
            return !UsePenaltyRegardMechnisamT;
        }

        //determination about learning autamata semaphores permit of operational computational
        private bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeMinisterP(int ik, int kind, bool Penalty, int j)
        {
            try
            {
                if (MinisterOnTable[ik].MinisterThinkingQuantum[0].PenaltyRegardListMinister[j].IsPenaltyAction() != 0)
                {
                    return true;
                }
            }
            catch (Exception t) { Log(t); }
            return !UsePenaltyRegardMechnisamT;
        }

        //determination about learning autamata semaphores permit of operational computational
        private bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeKingP(int ik, int kind, bool Penalty, int j)
        {
            try
            {
                if (KingOnTable[ik].KingThinkingQuantum[0].PenaltyRegardListKing[j].IsPenaltyAction() != 0)
                {
                    return true;
                }
            }
            catch (Exception t) { Log(t); }

            return !UsePenaltyRegardMechnisamT;
        }

        //determination about learning autamata semaphores permit of operational computational
        private bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeCastlingP(int ik, int kind, bool Penalty, int j)
        {
            //when is learning autamata

            try
            {
                if (CastlingOnTable[ik].CastlingThinking[0].PenaltyRegardListCastling[j].IsPenaltyAction() != 0)
                {
                    return true;
                }
            }
            catch (Exception t) { Log(t); }

            return !UsePenaltyRegardMechnisamT;
        }

        //determination about learning autamata semaphores permit of operational computational
        private bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeSolier(int ik, int kind, bool Penalty, int j)
        {
            try
            {
                if (SolderesOnTable[ik].SoldierThinkingQuantum[0].PenaltyRegardListSolder[j].IsRewardAction() != 1)
                {
                    return true;
                }
            }
            catch (Exception t) { Log(t); }

            return !UsePenaltyRegardMechnisamT;
        }

        //determination about learning autamata semaphores permit of operational computational
        private bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeElephant(int ik, int kind, bool Penalty, int j)
        {
            try
            {
                if (ElephantOnTable[ik].ElefantThinkingQuantum[0].PenaltyRegardListElefant[j].IsRewardAction() != 1)
                {
                    return true;
                }
            }
            catch (Exception t) { Log(t); }
            return !UsePenaltyRegardMechnisamT;
        }

        //determination about learning autamata semaphores permit of operational computational
        private bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeHourse(int ik, int kind, bool Penalty, int j)
        {
            try
            {
                if (HoursesOnTable[ik].HourseThinkingQuantum[0].PenaltyRegardListHourse[j].IsRewardAction() != 1)
                {
                    return true;
                }
            }
            catch (Exception t) { Log(t); }
            return !UsePenaltyRegardMechnisamT;
        }

        //determination about learning autamata semaphores permit of operational computational
        private bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeCastle(int ik, int kind, bool Penalty, int j)
        {
            try
            {
                if (CastlesOnTable[ik].CastleThinkingQuantum[0].PenaltyRegardListCastle[j].IsRewardAction() != 1)
                {
                    return true;
                }
            }
            catch (Exception t) { Log(t); }
            return !UsePenaltyRegardMechnisamT;
        }

        //determination about learning autamata semaphores permit of operational computational
        private bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeMinister(int ik, int kind, bool Penalty, int j)
        {
            try
            {
                if (MinisterOnTable[ik].MinisterThinkingQuantum[0].PenaltyRegardListMinister[j].IsRewardAction() != 1)
                {
                    return true;
                }
            }
            catch (Exception t) { Log(t); }
            return !UsePenaltyRegardMechnisamT;
        }

        //determination about learning autamata semaphores permit of operational computational
        private bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeKing(int ik, int kind, bool Penalty, int j)
        {
            try
            {
                if (KingOnTable[ik].KingThinkingQuantum[0].PenaltyRegardListKing[j].IsRewardAction() != 1)
                {
                    return true;
                }
            }
            catch (Exception t) { Log(t); }
            return !UsePenaltyRegardMechnisamT;
        }

        //determination about learning autamata semaphores permit of operational computational
        private bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTreeCastling(int ik, int kind, bool Penalty, int j)
        {
            //when is learning autamata
            try
            {
                if (CastlingOnTable[ik].CastlingThinking[0].PenaltyRegardListCastling[j].IsRewardAction() != 1)
                {
                    return true;
                }
            }
            catch (Exception t) { Log(t); }
            return !UsePenaltyRegardMechnisamT;
        }

        //determiniation about deeper increamental of a part
        private void BlitzNotValidFullGameThinkingTreePartOne(int ik, int Order, int kind)
        {
            //soldier
            if (kind == 1)
            {
                //when valid
                if (SolderesOnTable[ik].SoldierThinkingQuantum[0].TableListSolder.Count > SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy[SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 2)///elephant
            {
                //when valid
                if (ElephantOnTable[ik].ElefantThinkingQuantum[0].TableListElefant.Count > ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy[ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 3)//hourse
            {
                //when valid
                if (HoursesOnTable[ik].HourseThinkingQuantum[0].TableListHourse.Count > HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy[HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 4)//Castle
            {
                //when valid
                if (CastlesOnTable[ik].CastleThinkingQuantum[0].TableListCastle.Count > CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy[CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 5)//minister
            {
                //when valid
                if (MinisterOnTable[ik].MinisterThinkingQuantum[0].TableListMinister.Count > MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy[MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 6)//king
            {
                //when valid
                if (KingOnTable[ik].KingThinkingQuantum[0].TableListKing.Count > KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy[KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 7 || kind == -7)//king
            {
                //when valid
                if (CastlingOnTable[ik].CastlingThinking[0].TableListCastling.Count > CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count)
                {
                    if (CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count == 0)
                    {
                        CastlingOnTable[ik].CastlingThinking[0].AStarGreedy = new List<AllDraw>();
                    }

                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
        }

        //determiniation about deeper increamental of a part
        private void BlitzNotValidFullGameThinkingTreePartTow(int ik, int Order, int kind)
        {
            if (kind == 1)//soldier
            {
                //when valid
                if (SolderesOnTable[ik].SoldierThinkingQuantum[0].TableListSolder.Count > SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy[SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 2)//elephant
            {
                //when valid
                if (ElephantOnTable[ik].ElefantThinkingQuantum[0].TableListElefant.Count > ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy[ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 3)//hourse
            {
                //when valid
                if (HoursesOnTable[ik].HourseThinkingQuantum[0].TableListHourse.Count > HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy[HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 4)//Castle
            {
                //when valid
                if (CastlesOnTable[ik].CastleThinkingQuantum[0].TableListCastle.Count > CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy[CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 5)//minister
            {
                //when valid
                if (MinisterOnTable[ik].MinisterThinkingQuantum[0].TableListMinister.Count > MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy[MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 6)//king
            {
                //when valid
                if (KingOnTable[ik].KingThinkingQuantum[0].TableListKing.Count > KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy[KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 7 || kind == -7)//king
            {
                //when valid
                if (CastlingOnTable[ik].CastlingThinking[0].TableListCastling.Count > CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count)
                {
                    if (CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count == 0)
                    {
                        CastlingOnTable[ik].CastlingThinking[0].AStarGreedy = new List<AllDraw>();
                    }

                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
        }

        //determiniation about deeper increamental of a part
        private void BlitzNotValidFullGameThinkingTreePartThree(int ik, int Order, int kind)
        {
            //soldier
            if (kind == 1)
            {
                //when valid
                if (SolderesOnTable[ik].SoldierThinkingQuantum[0].TableListSolder.Count > SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy[SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 2)//elephant
            {
                //when valid
                if (ElephantOnTable[ik].ElefantThinkingQuantum[0].TableListElefant.Count > ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy[ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 3)//hourse
            {
                //when valid
                if (HoursesOnTable[ik].HourseThinkingQuantum[0].TableListHourse.Count > HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy[HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 4)//Castle
            {
                //when valid
                if (CastlesOnTable[ik].CastleThinkingQuantum[0].TableListCastle.Count > CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy[CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 5)//minister
            {
                //when valid
                if (MinisterOnTable[ik].MinisterThinkingQuantum[0].TableListMinister.Count > MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy[MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 6)//king
            {
                //when valid
                if (KingOnTable[ik].KingThinkingQuantum[0].TableListKing.Count > KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Count)
                {
                    if (KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Count == 0)
                    {
                        KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy = new List<AllDraw>();
                    }

                    KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy[KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 7 || kind == -7)//king
            {
                //when valid
                if (CastlingOnTable[ik].CastlingThinking[0].TableListCastling.Count > CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count)
                {
                    if (CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count == 0)
                    {
                        CastlingOnTable[ik].CastlingThinking[0].AStarGreedy = new List<AllDraw>();
                    }

                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
        }

        //main operation of full game deeper created compuational to deeper need.
        private void OpOfFullGameThinkingTree(int ik, int j, int Order, int iAStarGreedy, int ii, int jj, Color a, int kind, bool FOUND, int LeafAStarGreedy)
        {
            if (UsedRestrictedBlitzMoveAstarGreedy(kind, ik, j))
            {
                return;
            }

            NumberOfnewMove++;
            //soldier
            if (kind == 1)
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 1))

                //minitor
                OutPutAction = " " + Alphabet(SolderesOnTable[ik].SoldierThinkingQuantum[0].Row) + Number(SolderesOnTable[ik].SoldierThinkingQuantum[0].Column) + Alphabet(SolderesOnTable[ik].SoldierThinkingQuantum[0].RowColumnSoldier[j][0]) + Number(SolderesOnTable[ik].SoldierThinkingQuantum[0].RowColumnSoldier[j][1]);
                //if (Order == 1)
                //else

                //operational
                PerceptionCount++;
                int iii = SolderesOnTable[ik].SoldierThinkingQuantum[0].RowColumnSoldier[j][0];
                int jjj = SolderesOnTable[ik].SoldierThinkingQuantum[0].RowColumnSoldier[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(SolderesOnTable[ik].SoldierThinkingQuantum[0].TableListSolder[j]);
                int Ord = Order;
                SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy[SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Count - 1].CurrentMaxLevel = CurrentMaxLevel + 1;
                 StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                Task<AllDraw> array1 = Task.Factory.StartNew(() => SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy[SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(SolderesOnTable[ik].SoldierThinkingQuantum[0].TableListSolder[j]), Ord * -1, false, FOUND, LeafAStarGreedy));
                array1.Wait(); array1.Dispose();
                SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy[SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                if (SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedyMove.Count > 0)
                {
                    SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedyMove[SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Count - 1] = true;
                }
            }
            else if (kind == 2)//elephant
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 2))

                //minitor
                OutPutAction = " " + Alphabet(ElephantOnTable[ik].ElefantThinkingQuantum[0].Row) + Number(ElephantOnTable[ik].ElefantThinkingQuantum[0].Column) + Alphabet(ElephantOnTable[ik].ElefantThinkingQuantum[0].RowColumnElefant[j][0]) + Number(ElephantOnTable[ik].ElefantThinkingQuantum[0].RowColumnElefant[j][1]);
                //if (Order == 1)
                //else

                //operational
                PerceptionCount++;
                int iii = ElephantOnTable[ik].ElefantThinkingQuantum[0].RowColumnElefant[j][0];
                int jjj = ElephantOnTable[ik].ElefantThinkingQuantum[0].RowColumnElefant[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(ElephantOnTable[ik].ElefantThinkingQuantum[0].TableListElefant[j]);
                int Ord = Order;
                ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy[ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Count - 1].CurrentMaxLevel = CurrentMaxLevel + 1;
                StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                Task<AllDraw> array1 = Task.Factory.StartNew(() => ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy[ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, iii, jjj, aa, CloneATable(ElephantOnTable[ik].ElefantThinkingQuantum[0].TableListElefant[j]), Ord * -1, false, FOUND, LeafAStarGreedy));
                array1.Wait(); array1.Dispose();
                ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy[ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                if (ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedyMove.Count > 0)
                {
                    ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedyMove[ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Count - 1] = true;
                }
            }
            else if (kind == 3)//hourse
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 3))

                //minitor
                OutPutAction = " " + Alphabet(HoursesOnTable[ik].HourseThinkingQuantum[0].Row) + Number(HoursesOnTable[ik].HourseThinkingQuantum[0].Column) + Alphabet(HoursesOnTable[ik].HourseThinkingQuantum[0].RowColumnHourse[j][0]) + Number(HoursesOnTable[ik].HourseThinkingQuantum[0].RowColumnHourse[j][1]);
                //if (Order == 1)
                //else

                //operational
                PerceptionCount++;
                int iii = HoursesOnTable[ik].HourseThinkingQuantum[0].RowColumnHourse[j][0];
                int jjj = HoursesOnTable[ik].HourseThinkingQuantum[0].RowColumnHourse[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(HoursesOnTable[ik].HourseThinkingQuantum[0].TableListHourse[j]);
                int Ord = Order;
                HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy[HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Count - 1].CurrentMaxLevel = CurrentMaxLevel + 1;
                StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                Task<AllDraw> array1 = Task.Factory.StartNew(() => HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy[HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, iii, jjj, aa, CloneATable(HoursesOnTable[ik].HourseThinkingQuantum[0].TableListHourse[j]), Ord * -1, false, FOUND, LeafAStarGreedy));
                array1.Wait(); array1.Dispose();
                HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy[HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                if (HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedyMove.Count > 0)
                {
                    HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedyMove[HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Count - 1] = true;
                }
            }
            else if (kind == 4)//Castle
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 4))

                //minitor
                OutPutAction = " " + Alphabet(CastlesOnTable[ik].CastleThinkingQuantum[0].Row) + Number(CastlesOnTable[ik].CastleThinkingQuantum[0].Column) + Alphabet(CastlesOnTable[ik].CastleThinkingQuantum[0].RowColumnCastle[j][0]) + Number(CastlesOnTable[ik].CastleThinkingQuantum[0].RowColumnCastle[j][1]);
                //if (Order == 1)
                //else

                //operational
                PerceptionCount++;
                int iii = CastlesOnTable[ik].CastleThinkingQuantum[0].RowColumnCastle[j][0];
                int jjj = CastlesOnTable[ik].CastleThinkingQuantum[0].RowColumnCastle[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(CastlesOnTable[ik].CastleThinkingQuantum[0].TableListCastle[j]);
                int Ord = Order;
                CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy[CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Count - 1].CurrentMaxLevel = CurrentMaxLevel + 1;
                StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                Task<AllDraw> array1 = Task.Factory.StartNew(() => CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy[CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, iii, jjj, aa, CloneATable(CastlesOnTable[ik].CastleThinkingQuantum[0].TableListCastle[j]), Ord * -1, false, FOUND, LeafAStarGreedy));
                array1.Wait(); array1.Dispose();
                CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy[CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                if (CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedyMove.Count > 0)
                {
                    CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedyMove[CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Count - 1] = true;
                }
            }
            else if (kind == 5)//minister
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 5))

                //minitor
                OutPutAction = " " + Alphabet(MinisterOnTable[ik].MinisterThinkingQuantum[0].Row) + Number(MinisterOnTable[ik].MinisterThinkingQuantum[0].Column) + Alphabet(MinisterOnTable[ik].MinisterThinkingQuantum[0].RowColumnMinister[j][0]) + Number(MinisterOnTable[ik].MinisterThinkingQuantum[0].RowColumnMinister[j][1]);
                //if (Order == 1)
                //else

                //operational
                PerceptionCount++;
                int iii = MinisterOnTable[ik].MinisterThinkingQuantum[0].RowColumnMinister[j][0];
                int jjj = MinisterOnTable[ik].MinisterThinkingQuantum[0].RowColumnMinister[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(MinisterOnTable[ik].MinisterThinkingQuantum[0].TableListMinister[j]);
                int Ord = Order;
                MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy[MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Count - 1].CurrentMaxLevel = CurrentMaxLevel + 1;
                StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                Task<AllDraw> array1 = Task.Factory.StartNew(() => MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy[MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, iii, jjj, aa, CloneATable(MinisterOnTable[ik].MinisterThinkingQuantum[0].TableListMinister[j]), Ord * -1, false, FOUND, LeafAStarGreedy));
                array1.Wait(); array1.Dispose();
                MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy[MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                if (MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedyMove.Count > 0)
                {
                    MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedyMove[MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Count - 1] = true;
                }
            }
            else if (kind == 6)//king
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 6))

                //minitor
                OutPutAction = " " + Alphabet(KingOnTable[ik].KingThinkingQuantum[0].Row) + Number(KingOnTable[ik].KingThinkingQuantum[0].Column) + Alphabet(KingOnTable[ik].KingThinkingQuantum[0].RowColumnKing[j][0]) + Number(KingOnTable[ik].KingThinkingQuantum[0].RowColumnKing[j][1]);
                //if (Order == 1)
                //else

                //operational
                PerceptionCount++;
                int iii = KingOnTable[ik].KingThinkingQuantum[0].RowColumnKing[j][0];
                int jjj = KingOnTable[ik].KingThinkingQuantum[0].RowColumnKing[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(KingOnTable[ik].KingThinkingQuantum[0].TableListKing[j]);
                int Ord = Order;
                KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy[KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Count - 1].CurrentMaxLevel = CurrentMaxLevel + 1;
                StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                Task<AllDraw> array1 = Task.Factory.StartNew(() => KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy[KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, iii, jjj, aa, CloneATable(KingOnTable[ik].KingThinkingQuantum[0].TableListKing[j]), Ord * -1, false, FOUND, LeafAStarGreedy));

                array1.Wait(); array1.Dispose();
                KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy[KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                if (KingOnTable[ik].KingThinkingQuantum[0].AStarGreedyMove.Count > 0)
                {
                    KingOnTable[ik].KingThinkingQuantum[0].AStarGreedyMove[KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Count - 1] = true;
                }
            }
            else if (kind == 7 || kind == -7)//king
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 6))

                //minitor
                OutPutAction = " " + Alphabet(CastlingOnTable[ik].CastlingThinking[0].Row) + Number(CastlingOnTable[ik].CastlingThinking[0].Column) + Alphabet(CastlingOnTable[ik].CastlingThinking[0].RowColumnCastling[j][0]) + Number(CastlingOnTable[ik].CastlingThinking[0].RowColumnCastling[j][1]);
                //if (Order == 1)
                //else

                //operational
                PerceptionCount++;
                int iii = CastlingOnTable[ik].CastlingThinking[0].RowColumnCastling[j][0];
                int jjj = CastlingOnTable[ik].CastlingThinking[0].RowColumnCastling[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(CastlingOnTable[ik].CastlingThinking[0].TableListCastling[j]);
                int Ord = Order;
                CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count - 1].CurrentMaxLevel = CurrentMaxLevel + 1;
                StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                Task<AllDraw> array1 = Task.Factory.StartNew(() => CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, iii, jjj, aa, CloneATable(CastlingOnTable[ik].CastlingThinking[0].TableListCastling[j]), Ord * -1, false, FOUND, LeafAStarGreedy));

                array1.Wait(); array1.Dispose();
                CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                if (CastlingOnTable[ik].CastlingThinking[0].AStarGreedyMove.Count > 0)
                {
                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedyMove[CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count - 1] = true;
                }
            }
        }

        private bool ReturnFullGameThinkingTreeIligalSemaphore(int ik, int kind)
        {
            if (kind == 1)
            {
                if (SolderesOnTable[ik].SoldierThinkingQuantum[0].TableListSolder.Count == 0)
                {
                    return true;
                }
            }
            else//elephant
              if (kind == 2)
            {
                if (ElephantOnTable[ik].ElefantThinkingQuantum[0].TableListElefant.Count == 0)
                {
                    return true;
                }
            }
            else if (kind == 3)//hourse
            {
                if (HoursesOnTable[ik].HourseThinkingQuantum[0].TableListHourse.Count == 0)
                {
                    return true;
                }
            }
            else if (kind == 4)//Castle
            {
                if (CastlesOnTable[ik].CastleThinkingQuantum[0].TableListCastle.Count == 0)
                {
                    return true;
                }
            }
            else
                if (kind == 5)//minister
            {
                if (MinisterOnTable[ik].MinisterThinkingQuantum[0].TableListMinister.Count == 0)
                {
                    return true;
                }
            }
            else if (kind == 6)//king
            {
                if (KingOnTable[ik].KingThinkingQuantum[0].TableListKing.Count == 0)
                {
                    return true;
                }
            }
            else if (kind == 7 || kind == -7)//king
            {
                if (CastlingOnTable[ik].CastlingThinking[0].TableListCastling.Count == 0)
                {
                    return true;
                }
            }
            return false;
        }

        //decicion for deeper satisfied boundry condition of full game methods group
        private void ReturnFullGameThinkingTreeSemaphoreAs(int Order, int iAStarGreedy, int ik, int Kind)
        {
            object OO1 = new object();
            lock (OO1)
            {
                TaskBegin++;
                //main decistion
                while (ReturnFullGameThinkingTreeSemaphore(ik, Kind))
                {
                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                    {
                        break;
                    }
                }
            }
        }

        public int FullGameThinkingTreeWin(int Order)
        {
            if (Order == 1)
            {
                for (int ik = 0; ik < SodierMidle; ik++)
                {
                    FullGameThinkingTreeWinS(ik, Order);
                }
                for (int ik = 0; ik < ElefantMidle; ik++)
                {
                    FullGameThinkingTreeWinE(ik, Order);
                }
                for (int ik = 0; ik < HourseMidle; ik++)
                {
                    FullGameThinkingTreeWinH(ik, Order);
                }
                for (int ik = 0; ik < CastleMidle; ik++)
                {
                    FullGameThinkingTreeWinC(ik, Order);
                }
                for (int ik = 0; ik < MinisterMidle; ik++)
                {
                    FullGameThinkingTreeWinM(ik, Order);
                }
                for (int ik = 0; ik < KingMidle; ik++)
                {
                    FullGameThinkingTreeWinK(ik, Order);
                }
                for (int ik = 0; ik < 1; ik++)
                {
                    FullGameThinkingTreeWinA(ik, Order);
                }
            }
            else
            {
                for (int ik = SodierMidle; ik < SodierHigh; ik++)
                {
                    FullGameThinkingTreeWinS(ik, Order);
                }
                for (int ik = ElefantMidle; ik < ElefantMidle; ik++)
                {
                    FullGameThinkingTreeWinE(ik, Order);
                }
                for (int ik = HourseMidle; ik < HourseHight; ik++)
                {
                    FullGameThinkingTreeWinH(ik, Order);
                }

                for (int ik = CastleMidle; ik < CastleHigh; ik++)
                {
                    FullGameThinkingTreeWinC(ik, Order);
                }

                for (int ik = MinisterMidle; ik < MinisterHigh; ik++)
                {
                    FullGameThinkingTreeWinM(ik, Order);
                }
                for (int ik = KingMidle; ik < KingHigh; ik++)
                {
                    FullGameThinkingTreeWinS(ik, Order);
                }
                for (int ik = 0; ik < 1; ik++)
                {
                    FullGameThinkingTreeWinA(ik, Order);
                }
            }
            int Sum = WinOcuuredatChiledSum(Order); 
            return Sum;
        }
        public int WinOcuuredatChiledSum(int Order)
        {
            int Sum = 0;

            if (Order == 1)
            {
                for (int i = 0; i < SodierMidle; i++)
                {
                    if (SolderesOnTable != null && SolderesOnTable[i] != null)
                    {
                        Sum += SolderesOnTable[i].WinOcuuredatChiled;
                    }
                }
                for (int i = 0; i < ElefantMidle; i++)
                {
                    if (ElephantOnTable != null && ElephantOnTable[i] != null)
                    {
                        Sum += ElephantOnTable[i].WinOcuuredatChiled;
                    }
                }
                for (int i = 0; i < HourseMidle; i++)
                {
                    if (HoursesOnTable != null && HoursesOnTable[i] != null)
                    {
                        Sum += HoursesOnTable[i].WinOcuuredatChiled;
                    }
                }
                for (int i = 0; i < CastleMidle; i++)
                {
                    if (CastlesOnTable != null && CastlesOnTable[i] != null)
                    {
                        Sum += CastlesOnTable[i].WinOcuuredatChiled;
                    }
                }
                for (int i = 0; i < MinisterMidle; i++)
                {
                    if (MinisterOnTable != null && MinisterOnTable[i] != null)
                    {
                        Sum += MinisterOnTable[i].WinOcuuredatChiled;
                    }
                }
                for (int i = 0; i < KingMidle; i++)
                {
                    if (KingOnTable != null && KingOnTable[i] != null)
                    {
                        Sum += KingOnTable[i].WinOcuuredatChiled;
                    }
                }

                for (int i = 0; i < 1; i++)
                {
                    if (CastlingOnTable != null && CastlingOnTable[i] != null)
                    {
                        Sum += CastlingOnTable[i].WinOcuuredatChiled;
                    }
                }
            }
            else
            {
                for (int i = SodierMidle; i < SodierHigh; i++)
                {
                    if (SolderesOnTable != null && SolderesOnTable[i] != null)
                    {
                        Sum += SolderesOnTable[i].WinOcuuredatChiled;
                    }
                }
                for (int i = ElefantMidle; i < ElefantHigh; i++)
                {
                    if (ElephantOnTable != null && ElephantOnTable[i] != null)
                    {
                        Sum += ElephantOnTable[i].WinOcuuredatChiled;
                    }
                }
                for (int i = HourseMidle; i < HourseHight; i++)
                {
                    if (HoursesOnTable != null && HoursesOnTable[i] != null)
                    {
                        Sum += HoursesOnTable[i].WinOcuuredatChiled;
                    }
                }
                for (int i = CastleMidle; i < CastleHigh; i++)
                {
                    if (CastlesOnTable != null && CastlesOnTable[i] != null)
                    {
                        Sum += CastlesOnTable[i].WinOcuuredatChiled;
                    }
                }
                for (int i = MinisterMidle; i < MinisterHigh; i++)
                {
                    if (MinisterOnTable != null && MinisterOnTable[i] != null)
                    {
                        Sum += MinisterOnTable[i].WinOcuuredatChiled;
                    }
                }
                for (int i = KingMidle; i < KingHigh; i++)
                {
                    if (KingOnTable != null && KingOnTable[i] != null)
                    {
                        Sum += KingOnTable[i].WinOcuuredatChiled;
                    }
                }
                for (int i = 0; i < 1; i++)
                {
                    if (CastlingOnTable != null && CastlingOnTable[i] != null)
                    {
                        Sum += CastlingOnTable[i].WinOcuuredatChiled;
                    }
                }
            }

            return Sum;
        }
        public void FullGameThinkingTreeWinS(int ik, int Order)
        {

            try 
            {
                if (SolderesOnTable != null
                          )
                {
                    if (SolderesOnTable[ik] != null
                             )
                    {
                        if (SolderesOnTable[ik].SoldierThinkingQuantum != null
                                )
                        {
                            if (SolderesOnTable[ik].SoldierThinkingQuantum[0] != null
                                       )
                            {   //non learning autamata victory leafs
                                for (int h = 0; h < SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Count && SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    SolderesOnTable[ik].WinOcuuredatChiled += SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                }

                                SolderesOnTable[ik].SoldierThinkingQuantum[0].TowDistrurbProperUse(ref SolderesOnTable[ik].LoseOcuuredatChiled);
                            }
                        }
                    }
                }
            }
            catch (Exception t) { Log(t); }
        }
        public void FullGameThinkingTreeWinE(int ik, int Order)
        {

            try
            {
                if (ElephantOnTable != null
              )
                {
                    if (ElephantOnTable[ik] != null
                             )
                    {
                        if (ElephantOnTable[ik].ElefantThinkingQuantum != null
                                     )
                        {
                            if (ElephantOnTable[ik].ElefantThinkingQuantum[0] != null
                                        )
                            {      //non learning autamata victory leafs
                                for (int h = 0; h < ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Count && ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    ElephantOnTable[ik].WinOcuuredatChiled += ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                }

                                ElephantOnTable[ik].ElefantThinkingQuantum[0].TowDistrurbProperUse(ref ElephantOnTable[ik].LoseOcuuredatChiled);
                            }
                        }
                    }
                }

            }
            catch (Exception t) { Log(t);
            }
        }
        public void FullGameThinkingTreeWinH(int ik, int Order)
        {
            try
            {
                if (HoursesOnTable != null)
                {
                    if (HoursesOnTable[ik] != null
                   )
                    {
                        if (HoursesOnTable[ik].HourseThinkingQuantum != null
                    )
                        {
                            if (HoursesOnTable[ik].HourseThinkingQuantum[0] != null
                         )
                            {     //non learning autamata victory leafs
                                for (int h = 0; h < HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Count && HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    HoursesOnTable[ik].WinOcuuredatChiled += HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                }

                                HoursesOnTable[ik].HourseThinkingQuantum[0].TowDistrurbProperUse(ref HoursesOnTable[ik].LoseOcuuredatChiled);
                            }
                        }
                    }
                }

            }
            catch (Exception t) { Log(t);
            }
        }
        public void FullGameThinkingTreeWinC(int ik, int Order)
        {
            try
            {
                if (CastlesOnTable != null
   )
                {
                    if (CastlesOnTable[ik] != null
                 )
                    {
                        if (CastlesOnTable[ik].CastleThinkingQuantum != null
                     )
                        {
                            if (CastlesOnTable[ik].CastleThinkingQuantum[0] != null
                         )
                            {      //non learning autamata victory leafs
                                for (int h = 0; h < CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Count && CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    CastlesOnTable[ik].WinOcuuredatChiled += CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                }

                                CastlesOnTable[ik].CastleThinkingQuantum[0].TowDistrurbProperUse(ref CastlesOnTable[ik].LoseOcuuredatChiled);
                            }
                        }
                    }
                }
            }
            catch (Exception t) { Log(t);
            }
        }
        public void FullGameThinkingTreeWinM(int ik, int Order)
        {
            try
            {
                if (MinisterOnTable != null
           )
                {
                    if (MinisterOnTable[ik] != null
          )
                    {
                        if (MinisterOnTable[ik].MinisterThinkingQuantum != null
   )
                        {
                            if (MinisterOnTable[ik].MinisterThinkingQuantum[0] != null
                         )
                            {      //non learning autamata victory leafs
                                for (int h = 0; h < MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Count && MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    MinisterOnTable[ik].WinOcuuredatChiled += MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                }

                                MinisterOnTable[ik].MinisterThinkingQuantum[0].TowDistrurbProperUse(ref MinisterOnTable[ik].LoseOcuuredatChiled);
                            }
                        }
                    }
                }

            }
            catch (Exception t) { Log(t);
            }
        }
        public void FullGameThinkingTreeWinK(int ik, int Order)
        {
            try
            {
                if (KingOnTable != null
)
                {
                    if (KingOnTable[ik] != null
)
                    {
                        if (KingOnTable[ik].KingThinkingQuantum != null
                 )
                        {
                            if (KingOnTable[ik].KingThinkingQuantum[0] != null
                         )
                            {    //non learning autamata victory leafs
                                for (int h = 0; h < KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Count && KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    KingOnTable[ik].WinOcuuredatChiled += KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                }

                                KingOnTable[ik].KingThinkingQuantum[0].TowDistrurbProperUse(ref KingOnTable[ik].LoseOcuuredatChiled);
                            }
                        }
                    }
                }

            }
            catch (Exception t) { Log(t);
            }
        }
        public void FullGameThinkingTreeWinA(int ik, int Order)
        {
            try
            {
                if (CastlingOnTable != null
)
                {
                    if (CastlingOnTable[ik] != null
    )
                    {
                        if (CastlingOnTable[ik].CastlingThinking != null
                 )
                        {
                            if (CastlingOnTable[ik].CastlingThinking[0] != null
                         )
                            {    //non learning autamata victory leafs
                                for (int h = 0; h < CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[ik].CastlingThinking[0].AStarGreedy != null; h++)
                                {
                                    CastlingOnTable[ik].WinOcuuredatChiled += CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                }

                                CastlingOnTable[ik].CastlingThinking[0].TowDistrurbProperUse(ref CastlingOnTable[ik].LoseOcuuredatChiled);
                            }
                        }
                    }
                }

            }
            catch (Exception t)
            {
                Log(t);
            }
        }
        public int FullGameThinkingTreeLose(int Order)
        {
            if (Order == 1)
            {
                for (int ik = 0; ik < SodierMidle; ik++)
                {
                    FullGameThinkingTreeLoseS(ik, Order);
                }
                for (int ik = 0; ik < ElefantMidle; ik++)
                {
                    FullGameThinkingTreeLoseE(ik, Order);
                }
                for (int ik = 0; ik < HourseMidle; ik++)
                {
                    FullGameThinkingTreeLoseH(ik, Order);
                }
                for (int ik = 0; ik < CastleMidle; ik++)
                {
                    FullGameThinkingTreeLoseC(ik, Order);
                }
                for (int ik = 0; ik < MinisterMidle; ik++)
                {
                    FullGameThinkingTreeLoseM(ik, Order);
                }
                for (int ik = 0; ik < KingMidle; ik++)
                {
                    FullGameThinkingTreeLoseK(ik, Order);

                }
                for (int ik = 0; ik < 1; ik++)
                {
                    FullGameThinkingTreeLoseA(ik, Order);

                }
            }
            else
            {
                for (int ik = SodierMidle; ik < SodierHigh; ik++)
                {
                    FullGameThinkingTreeLoseS(ik, Order);
                }
                for (int ik = ElefantMidle; ik < ElefantMidle; ik++)
                {
                    FullGameThinkingTreeLoseE(ik, Order);
                }
                for (int ik = HourseMidle; ik < HourseHight; ik++)
                {
                    FullGameThinkingTreeLoseH(ik, Order);
                }

                for (int ik = CastleMidle; ik < CastleHigh; ik++)
                {
                    FullGameThinkingTreeLoseC(ik, Order);
                }

                for (int ik = MinisterMidle; ik < MinisterHigh; ik++)
                {
                    FullGameThinkingTreeLoseM(ik, Order);
                }
                for (int ik = KingMidle; ik < KingHigh; ik++)
                {
                    FullGameThinkingTreeLoseK(ik, Order);

                }
                for (int ik = 0; ik < 1; ik++)
                {
                    FullGameThinkingTreeLoseA(ik, Order);

                }
            }
            int Sum = LoseOcuuredatChiledSum(Order);
            return Sum;
        }

        //deeper for soldier
        public int LoseOcuuredatChiledSum(int Order)
        {
            int Sum = 0;
            //if (this.AStarGreedyString != null)
            {
                //if (!IsAtleastAWin(this, Order))
                {
                    if (Order == 1)
                    {
                        for (int i = 0; i < SodierMidle; i++)
                        {
                            if (SolderesOnTable != null && SolderesOnTable[i] != null)
                            {
                                Sum += SolderesOnTable[i].LoseOcuuredatChiled[0];
                            }
                        }
                        for (int i = 0; i < ElefantMidle; i++)
                        {
                            if (ElephantOnTable != null && ElephantOnTable[i] != null)
                            {
                                Sum += ElephantOnTable[i].LoseOcuuredatChiled[0];
                            }
                        }
                        for (int i = 0; i < HourseMidle; i++)
                        {
                            if (HoursesOnTable != null && HoursesOnTable[i] != null)
                            {
                                Sum += HoursesOnTable[i].LoseOcuuredatChiled[0];
                            }
                        }
                        for (int i = 0; i < CastleMidle; i++)
                        {
                            if (CastlesOnTable != null && CastlesOnTable[i] != null)
                            {
                                Sum += CastlesOnTable[i].LoseOcuuredatChiled[0];
                            }
                        }
                        for (int i = 0; i < MinisterMidle; i++)
                        {
                            if (MinisterOnTable != null && MinisterOnTable[i] != null)
                            {
                                Sum += MinisterOnTable[i].LoseOcuuredatChiled[0];
                            }
                        }
                        for (int i = 0; i < KingMidle; i++)
                        {
                            if (KingOnTable != null && KingOnTable[i] != null)
                            {
                                Sum += KingOnTable[i].LoseOcuuredatChiled[0];
                            }
                        }
                        for (int i = 0; i < 1; i++)
                        {
                            if (CastlingOnTable != null && CastlingOnTable[i] != null)
                            {
                                Sum += CastlingOnTable[i].LoseOcuuredatChiled[0];
                            }
                        }
                    }
                    else
                    {
                        for (int i = SodierMidle; i < SodierHigh; i++)
                        {
                            if (SolderesOnTable != null && SolderesOnTable[i] != null)
                            {
                                Sum += SolderesOnTable[i].LoseOcuuredatChiled[0];
                            }
                        }
                        for (int i = ElefantMidle; i < ElefantHigh; i++)
                        {
                            if (ElephantOnTable != null && ElephantOnTable[i] != null)
                            {
                                Sum += ElephantOnTable[i].LoseOcuuredatChiled[0];
                            }
                        }
                        for (int i = HourseMidle; i < HourseHight; i++)
                        {
                            if (HoursesOnTable != null && HoursesOnTable[i] != null)
                            {
                                Sum += HoursesOnTable[i].LoseOcuuredatChiled[0];
                            }
                        }
                        for (int i = CastleMidle; i < CastleHigh; i++)
                        {
                            if (CastlesOnTable != null && CastlesOnTable[i] != null)
                            {
                                Sum += CastlesOnTable[i].LoseOcuuredatChiled[0];
                            }
                        }
                        for (int i = MinisterMidle; i < MinisterHigh; i++)
                        {
                            if (MinisterOnTable != null && MinisterOnTable[i] != null)
                            {
                                Sum += MinisterOnTable[i].LoseOcuuredatChiled[0];
                            }
                        }
                        for (int i = KingMidle; i < KingHigh; i++)
                        {
                            if (KingOnTable != null && KingOnTable[i] != null)
                            {
                                Sum += KingOnTable[i].LoseOcuuredatChiled[0];
                            }
                        }
                        for (int i = 0; i < 1; i++)
                        {
                            if (CastlingOnTable != null && CastlingOnTable[i] != null)
                            {
                                Sum += CastlingOnTable[i].LoseOcuuredatChiled[0];
                            }
                        }
                    }
                }
            }
            return Sum;
        }
        public void FullGameThinkingTreeLoseS(int ik,int Order)
        {
            try
            {
                if (SolderesOnTable != null
                            )
                {
                    if (SolderesOnTable[ik] != null
                             )
                    {
                        if (SolderesOnTable[ik].SoldierThinkingQuantum != null
                                )
                        {
                            if (SolderesOnTable[ik].SoldierThinkingQuantum[0] != null
                                       )
                            {   //non learning autamata victory leafs
                                for (int h = 0; h < SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Count && SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    SolderesOnTable[ik].LoseOcuuredatChiled[0] += SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception t) { Log(t); }
        }
        public void FullGameThinkingTreeLoseE(int ik, int Order)
        {
            try
            {
                if (ElephantOnTable != null
              )
                {
                    if (ElephantOnTable[ik] != null
                             )
                    {
                        if (ElephantOnTable[ik].ElefantThinkingQuantum != null
                                     )
                        {
                            if (ElephantOnTable[ik].ElefantThinkingQuantum[0] != null
                                        )
                            {      //non learning autamata victory leafs
                                for (int h = 0; h < ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Count && ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    ElephantOnTable[ik].LoseOcuuredatChiled[0] += ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }
                }

            }
            catch (Exception t) { Log(t);
            }
        }

        public void FullGameThinkingTreeLoseH(int ik, int Order)
        {

            try
            {
                if (HoursesOnTable != null)
                {
                    if (HoursesOnTable[ik] != null
                   )
                    {
                        if (HoursesOnTable[ik].HourseThinkingQuantum != null
                    )
                        {
                            if (HoursesOnTable[ik].HourseThinkingQuantum[0] != null
                         )
                            {     //non learning autamata victory leafs
                                for (int h = 0; h < HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Count && HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    HoursesOnTable[ik].LoseOcuuredatChiled[0] += HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }
                }

            }
            catch (Exception t)
            {
                Log(t);
            }
        }
        public void FullGameThinkingTreeLoseC(int ik, int Order)
        {
            try
            {
                if (CastlesOnTable != null
)
                {
                    if (CastlesOnTable[ik] != null
                 )
                    {
                        if (CastlesOnTable[ik].CastleThinkingQuantum != null
                     )
                        {
                            if (CastlesOnTable[ik].CastleThinkingQuantum[0] != null
                         )
                            {      //non learning autamata victory leafs
                                for (int h = 0; h < CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Count && CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    CastlesOnTable[ik].LoseOcuuredatChiled[0] += CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception t) { Log(t); }
        }
        public void FullGameThinkingTreeLoseM(int ik, int Order)
        {
            try
            {
                if (MinisterOnTable != null
)
                {
                    if (MinisterOnTable[ik] != null
          )
                    {
                        if (MinisterOnTable[ik].MinisterThinkingQuantum != null
    )
                        {
                            if (MinisterOnTable[ik].MinisterThinkingQuantum[0] != null
                         )
                            {      //non learning autamata victory leafs
                                for (int h = 0; h < MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Count && MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    MinisterOnTable[ik].LoseOcuuredatChiled[0] += MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception t) { Log(t); }

        }
        public void FullGameThinkingTreeLoseK(int ik, int Order)
        {
            try
            {
                if (KingOnTable != null
)
                {
                    if (KingOnTable[ik] != null
)
                    {
                        if (KingOnTable[ik].KingThinkingQuantum != null
                 )
                        {
                            if (KingOnTable[ik].KingThinkingQuantum[0] != null
                         )
                            {    //non learning autamata victory leafs
                                for (int h = 0; h < KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Count && KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy != null; h++)
                                {
                                    KingOnTable[ik].LoseOcuuredatChiled[0] += KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception t) { Log(t); }

        }
        public void FullGameThinkingTreeLoseA(int ik, int Order)
        {
            try
            {
                if (CastlingOnTable != null
)
                {
                    if (CastlingOnTable[ik] != null
    )
                    {
                        if (CastlingOnTable[ik].CastlingThinking != null
                 )
                        {
                            if (CastlingOnTable[ik].CastlingThinking[0] != null
                         )
                            {    //non learning autamata victory leafs
                                for (int h = 0; h < CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[ik].CastlingThinking[0].AStarGreedy != null; h++)
                                {
                                    CastlingOnTable[ik].LoseOcuuredatChiled[0] += CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception t) { Log(t); }

        }
        private bool FullGameThinkingTreeSoldier(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 1))
                {
                    return false;
                }
                //semaphore
                Task array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, 1));

                array.Wait(); array.Dispose();
                object OOOO = new object();
                lock (OOOO)
                {
                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                    {
                        return false;
                    }
                }
                //ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, SolderesOnTable[ik].SoldierThinkingQuantum[0].TableListSolder.Count, j =>
                //operational computation secxistence
                for (int j = 0; j < SolderesOnTable[ik].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                {
                    if (IsSupHuTrue(ik, j, 1))
                    {
                        continue;
                    }

                    object OOOOO = new object();
                    lock (OOOOO)
                    {
                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        {
                            return false;
                        }
                    }
                    object ooo = new object();
                    lock (ooo)
                    {
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(CloneATable(SolderesOnTable[ik].SoldierThinkingQuantum[0].TableListSolder[j]), Order,1))
                        {
                            continue;
                        }
                        //sereved continuce
                        if (IsSupHuTrue(ik, j, 1))
                        {
                            continue;
                        }

                        bool ac = false;
                        Task<bool> ah3 = Task.Factory.StartNew(() => ac = Lose(1, ik, j, Order));
                        ah3.Wait();
                        ah3.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        //self do
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 1, true, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[0] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[0])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 1);
                                            continue;
                                        }
                                        else//computational lists semaphore
                                        if (j != jindex[0])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 1);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 1);
                                        continue;
                                    }
                                }
                                else
                                {
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 1);
                                }

                                object O3 = new object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                }
                                //when deeper is valid
                                if (SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Count > 0)
                                {
                                    object O = new object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 1, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                        else
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 1, false, j)
                            )
                            {
                                //when do permite
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[0] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[0])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 1);
                                            continue;
                                        }
                                        else//computational lists semaphore
                                        if (j != jindex[0])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 1);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 1);
                                        continue;
                                    }
                                }
                                else
                                {
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 1);
                                }

                                object O3 = new object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                }
                                //when deeper is valid
                                if (SolderesOnTable[ik].SoldierThinkingQuantum[0].AStarGreedy.Count > 0)
                                {
                                    object O = new object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 1, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                    }
                }
                object O2 = new object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }
            return Do;
            //Elephant
        }

        //collection objects calling full game specific game
        private bool FullGameThinkingTreeSoldierGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                ThinkingAllowed[0] = true;

                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(0, SodierMidle, ik =>

 {
     if (SolderesOnTable != null && SolderesOnTable[ik] != null && SolderesOnTable[ik].SoldierThinkingQuantum != null && SolderesOnTable[ik].SoldierThinkingQuantum[0] != null
     )
     {
         object O = new object();
         lock (O)
         {
             Task<bool> array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeSoldier(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
             //TH.Add(array);
         }
     }
 });
            }

            return Do;
        }

        private bool FullGameThinkingTreeElephant(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 2))
                {
                    return false;
                }
                //semaphore
                Task array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, 2));
                array.Wait(); array.Dispose();
                object OOOO = new object();
                lock (OOOO)
                {
                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                    {
                        return false;
                    }
                }
                ////ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, ElephantOnTable[ik].ElefantThinkingQuantum[0].TableListElefant.Count, j =>
                //operational computation secxistence
                for (int j = 0; j < ElephantOnTable[ik].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                {
                    object OOOOO = new object();
                    lock (OOOOO)
                    {
                        if (IsSupHuTrue(ik, j, 2))
                        {
                            continue;
                        }
                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        {
                            return false;
                        }
                    }
                    object ooo = new object();
                    lock (ooo)
                    {
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(CloneATable(ElephantOnTable[ik].ElefantThinkingQuantum[0].TableListElefant[j]), Order,2))
                        {
                            continue;
                        }
                        //sereved continuce
                        if (IsSupHuTrue(ik, j, 2))
                        {
                            continue;
                        }

                        bool ac = false;
                        Task<bool> ah3 = Task.Factory.StartNew(() => ac = Lose(2, ik, j, Order));
                        ah3.Wait();
                        ah3.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        //self do
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 2, true, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[1] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[1])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 2);
                                            continue;
                                        }
                                        else
                                            if (j != jindex[1])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 2);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 2);
                                        continue;
                                    }
                                }
                                else
                                {
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 2);
                                }

                                object O3 = new object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions

                                    //when deeper is valid
                                    if (ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Count > 0)
                                    {
                                        object O = new object();
                                        lock (O)
                                        {
                                            //do deeper
                                            OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 2, FOUND, LeafAStarGreedy);
                                            Do = true;
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 2, false, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[1] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[1])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 2);
                                            continue;
                                        }
                                        else
                                            if (j != jindex[1])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 2);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 2);
                                        continue;
                                    }
                                }
                                else
                                {
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 2);
                                }

                                object O3 = new object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions

                                    //when deeper is valid
                                    if (ElephantOnTable[ik].ElefantThinkingQuantum[0].AStarGreedy.Count > 0)
                                    {
                                        object O = new object();
                                        lock (O)
                                        {
                                            //do deeper
                                            OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 2, FOUND, LeafAStarGreedy);
                                            Do = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                object O2 = new object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }

            return Do;
        }

        //collection objects calling full game specific game
        private bool FullGameThinkingTreeElephantGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                ThinkingAllowed[1] = true;
                //Elephant
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(0, ElefantMidle, ik =>

 {
     if (ElephantOnTable != null && ElephantOnTable[ik] != null && ElephantOnTable[ik].ElefantThinkingQuantum != null && ElephantOnTable[ik].ElefantThinkingQuantum[0] != null
     )
     {
         object O = new object();
         lock (O)
         {
             Task<bool> array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeElephant(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
             //TH.Add(array);
         }
     }
 });
            }

            return Do;
        }

        private bool FullGameThinkingTreeHourse(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 3))
                {
                    return false;
                }
                //semaphore
                Task array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, 3));
                array.Wait(); array.Dispose();

                object OOOO = new object();
                lock (OOOO)
                {
                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                    {
                        return false;
                    }
                }
                ////ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, HoursesOnTable[ik].HourseThinkingQuantum[0].TableListHourse.Count, j =>
                //operational computation secxistence
                for (int j = 0; j < HoursesOnTable[ik].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                {
                    object OOOOO = new object();
                    lock (OOOOO)
                    {
                        if (IsSupHuTrue(ik, j, 3))
                        {
                            continue;
                        }

                        bool ac = false;
                        Task<bool> ah3 = Task.Factory.StartNew(() => ac = Lose(3, ik, j, Order));
                        ah3.Wait();
                        ah3.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        {
                            return false;
                        }
                    }
                    object ooo = new object();
                    lock (ooo)
                    {
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(CloneATable(HoursesOnTable[ik].HourseThinkingQuantum[0].TableListHourse[j]), Order,3))
                        {
                            continue;
                        }
                        //sereved continuce
                        if (HoursesOnTable[ik].HourseThinkingQuantum[0].IsSupHu[j])
                        {
                            continue;
                        }

                        //self do
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 3, true, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[2] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[2])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 3);
                                            continue;
                                        }
                                        else
                                            if (j != jindex[2])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 3);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 3);
                                        continue;
                                    }
                                }
                                else
                                {
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 3);
                                }

                                object O3 = new object();
                                lock (O3)
                                {
                                }

                                if (HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Count > 0)
                                {
                                    object O = new object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 3, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                            else
                            {
                                //when certification for continued of code satisfied
                                if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 3, false, j)
                                )
                                {
                                    //when blitz game (limited game)
                                    if (AllDraw.Blitz)
                                    {
                                        //when do permite
                                        if (Index[2] != -1)
                                        {
                                            //object kind semaphore
                                            if (ik != Index[2])
                                            {
                                                //satisfied of created deeper one
                                                BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 3);
                                                continue;
                                            }
                                            else
                                                if (j != jindex[2])
                                            {
                                                //satisfied of created deeper tow
                                                BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 3);
                                                continue;
                                            }
                                        }
                                        else
                                        {
                                            //satisfied of created deeper three
                                            BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 3);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 3);
                                    }

                                    object O3 = new object();
                                    lock (O3)
                                    {
                                        //initiate for satisfied full game primary conditions
                                    }

                                    //when deeper is valid
                                    if (HoursesOnTable[ik].HourseThinkingQuantum[0].AStarGreedy.Count > 0)
                                    {
                                        object O = new object();
                                        lock (O)
                                        {
                                            //do deeper
                                            OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 3, FOUND, LeafAStarGreedy);
                                            Do = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                object O2 = new object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }

            return Do;
        }

        //collection objects calling full game specific game
        private bool FullGameThinkingTreeHourseGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                ThinkingAllowed[2] = true;
                //Hourse.
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(0, HourseMidle, ik =>

 {
     if (HoursesOnTable != null && HoursesOnTable[ik] != null && HoursesOnTable[ik].HourseThinkingQuantum != null && HoursesOnTable[ik].HourseThinkingQuantum[0] != null
     )
     {
         object O = new object();
         lock (O)
         {
             Task<bool> array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeHourse(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
             //TH.Add(array);
         }
     }
 });
            }

            return Do;
        }

        private bool FullGameThinkingTreeCastle(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 4))
                {
                    return false;
                }
                //semaphore
                Task array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, 4));
                array.Wait(); array.Dispose();
                object OOOO = new object();
                lock (OOOO)
                {
                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                    {
                        return false;
                    }
                }
                ////ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, CastlesOnTable[ik].CastleThinkingQuantum[0].TableListCastle.Count, j =>
                //operational computation secxistence
                for (int j = 0; j < CastlesOnTable[ik].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                {
                    if (IsSupHuTrue(ik, j, 4))
                    {
                        continue;
                    }

                    bool ac = false;
                    Task<bool> ah3 = Task.Factory.StartNew(() => ac = Lose(4, ik, j, Order));
                    ah3.Wait();
                    ah3.Dispose();
                    if (ac)
                    {
                        continue;
                    }

                    object OOOOO = new object();
                    lock (OOOOO)
                    {
                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        {
                            return false;
                        }
                    }
                    //when node have kings dangoures ignore and continue.
                    if (CheckeHuristci(CloneATable(CastlesOnTable[ik].CastleThinkingQuantum[0].TableListCastle[j]), Order,4))
                    {
                        continue;
                    }
                    //sereved continuce
                    if (IsSupHuTrue(ik, j, 4))
                    {
                        continue;
                    }

                    object ooo = new object();
                    lock (ooo)
                    {
                        //self do
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 4, true, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[3] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[3])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 4);
                                            continue;
                                        }
                                        else
                                            if (j != jindex[0])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 4);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 4);
                                        continue;
                                    }
                                }
                                else
                                {
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 4);
                                }

                                object O3 = new object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                }

                                //when deeper is valid
                                if (CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Count > 0)
                                {
                                    object O = new object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 4, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                        else
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 4, false, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[3] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[3])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 4);
                                            continue;
                                        }
                                        else
                                            if (j != jindex[0])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 4);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 4);
                                        continue;
                                    }
                                }
                                else
                                {
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 4);
                                }

                                object O3 = new object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                }

                                //when deeper is valid
                                if (CastlesOnTable[ik].CastleThinkingQuantum[0].AStarGreedy.Count > 0)
                                {
                                    object O = new object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 4, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                    }
                }

                object O2 = new object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }

            return Do;
        }

        //collection objects calling full game specific game
        private bool FullGameThinkingTreeCastleGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                ThinkingAllowed[3] = true;
                //Castle.
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(0, CastleMidle, ik =>

 {
     if (CastlesOnTable != null && CastlesOnTable[ik] != null && CastlesOnTable[ik].CastleThinkingQuantum != null && CastlesOnTable[ik].CastleThinkingQuantum[0] != null
     )
     {
         object O = new object();
         lock (O)
         {
             Task<bool> array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeCastle(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
             //TH.Add(array);
         }
     }
 });
            }

            return Do;
        }

        private bool FullGameThinkingTreeMinister(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 5))
                {
                    return false;
                }
                //semaphore
                Task array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, 5));
                array.Wait(); array.Dispose();

                object OOOO = new object();
                lock (OOOO)
                {
                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                    {
                        return false;
                    }
                }
                ////ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, MinisterOnTable[ik].MinisterThinkingQuantum[0].TableListMinister.Count, j =>
                //operational computation secxistence
                for (int j = 0; j < MinisterOnTable[ik].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                {
                    object OOOOO = new object();
                    lock (OOOOO)
                    {
                        if (IsSupHuTrue(ik, j, 5))
                        {
                            continue;
                        }

                        bool ac = false;
                        Task<bool> ah3 = Task.Factory.StartNew(() => ac = Lose(5, ik, j, Order));
                        ah3.Wait();
                        ah3.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        {
                            return false;
                        }
                    }
                    object ooo = new object();
                    lock (ooo)
                    {
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(CloneATable(MinisterOnTable[ik].MinisterThinkingQuantum[0].TableListMinister[j]), Order,5))
                        {
                            continue;
                        }
                        //sereved continuce
                        if (IsSupHuTrue(ik, j, 5))
                        {
                            continue;
                        }

                        //self do
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 5, true, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[4] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[4])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 5);
                                            continue;
                                        }
                                        else
                                             if (j != jindex[4])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 5);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 5);
                                        continue;
                                    }
                                }
                                else
                                {
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 5);
                                }

                                object O3 = new object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                }

                                //when deeper is valid
                                if (MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Count > 0)
                                {
                                    object O = new object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 5, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                        else
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 5, false, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[4] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[4])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 5);
                                            continue;
                                        }
                                        else
                                             if (j != jindex[4])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 5);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 5);
                                        continue;
                                    }
                                }
                                else
                                {
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 5);
                                }

                                object O3 = new object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                }

                                if (MinisterOnTable[ik].MinisterThinkingQuantum[0].AStarGreedy.Count > 0)
                                {
                                    object O = new object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 5, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                    }
                }

                object O2 = new object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }

            return Do;
        }

        //collection objects calling full game specific game
        private bool FullGameThinkingTreeMinisterGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                ThinkingAllowed[4] = true;
                //Minister.
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(0, MinisterMidle, ik =>

 {
     if (MinisterOnTable != null && MinisterOnTable[ik] != null && MinisterOnTable[ik].MinisterThinkingQuantum != null && MinisterOnTable[ik].MinisterThinkingQuantum[0] != null
     )
     {
         object O = new object();
         lock (O)
         {
             Task<bool> array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeMinister(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
             //TH.Add(array);
         }
     }
 });
            }

            return Do;
        }

        private bool FullGameThinkingTreeKing(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 6))
                {
                    return false;
                }
                //semaphore
                Task array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, 6));
                array.Wait(); array.Dispose();

                object OOOO = new object();
                lock (OOOO)
                {
                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                    {
                        return false;
                    }
                }
                if (KingOnTable[ik].KingThinkingQuantum[0].TableListKing.Count == 0)
                {
                    return Do;
                }
                // //ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, KingOnTable[ik].KingThinkingQuantum[0].TableListKing.Count, j =>
                //operational computation secxistence
                for (int j = 0; j < KingOnTable[ik].KingThinkingQuantum[0].TableListKing.Count; j++)
                {
                    object OOOOO = new object();
                    lock (OOOOO)
                    {
                        if (IsSupHuTrue(ik, j, 6))
                        {
                            continue;
                        }

                        bool ac = false;
                        Task<bool> ah3 = Task.Factory.StartNew(() => ac = Lose(6, ik, j, Order));
                        ah3.Wait();
                        ah3.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        {
                            return false;
                        }
                    }
                    object ooo = new object();
                    lock (ooo)
                    {
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(CloneATable(KingOnTable[ik].KingThinkingQuantum[0].TableListKing[j]), Order,6))
                        {
                            continue;
                        }
                        //sereved continuce
                        if (IsSupHuTrue(ik, j, 6))
                        {
                            continue;
                        }
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 6, true, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[5] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[5])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 6);
                                            continue;
                                        }
                                        else
                                             if (j != jindex[5])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 6);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 6);
                                        continue;
                                    }
                                }
                                else
                                {
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 6);
                                }

                                object O3 = new object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                }

                                //when deeper is valid
                                if (KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Count > 0)
                                {
                                    object O = new object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 6, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                        else
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 6, false, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[5] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[5])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 6);
                                            continue;
                                        }
                                        else
                                             if (j != jindex[5])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 6);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 6);
                                        continue;
                                    }
                                }
                                else
                                {
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 6);
                                }

                                object O3 = new object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                }

                                if (KingOnTable[ik].KingThinkingQuantum[0].AStarGreedy.Count > 0)
                                {
                                    object O = new object();
                                    lock (O)
                                    {
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 6, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                    }
                }

                object O2 = new object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }

            return Do;
        }

        private bool FullGameThinkingTreeCastling(int kin, int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, kin))
                {
                    return false;
                }
                //semaphore
                Task array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, kin));
                array.Wait(); array.Dispose();

                object OOOO = new object();
                lock (OOOO)
                {
                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                    {
                        return false;
                    }
                }
                if (CastlingOnTable[ik].CastlingThinking[0].TableListCastling.Count == 0)
                {
                    return Do;
                }
                // //ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, CastlingOnTable[ik].CastlingThinking[0].TableListCastling.Count, j =>
                //operational computation secxistence
                for (int j = 0; j < CastlingOnTable[ik].CastlingThinking[0].TableListCastling.Count; j++)
                {
                    object OOOOO = new object();
                    lock (OOOOO)
                    {
                        if (IsSupHuTrue(ik, j, kin))
                        {
                            continue;
                        }
                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        {
                            return false;
                        }
                    }
                    object ooo = new object();
                    lock (ooo)
                    {
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(CloneATable(CastlingOnTable[ik].CastlingThinking[0].TableListCastling[j]), Order,7))
                        {
                            continue;
                        }
                        //sereved continuce
                        if (IsSupHuTrue(ik, j, 7))
                        {
                            continue;
                        }

                        bool ac = false;
                        Task<bool> ah3 = Task.Factory.StartNew(() => ac = Lose(7, ik, j, Order));
                        ah3.Wait();
                        ah3.Dispose();
                        if (ac)
                        {
                            continue;
                        }

                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, kin, true, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[6] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[6])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, kin);
                                            continue;
                                        }
                                        else
                                             if (j != jindex[6])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, kin);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, kin);
                                        continue;
                                    }
                                }
                                else
                                {
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, kin);
                                }

                                object O3 = new object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                }

                                //when deeper is valid
                                if (CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count > 0)
                                {
                                    object O = new object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, kin, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                        else
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, kin, false, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[6] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[6])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, kin);
                                            continue;
                                        }
                                        else
                                             if (j != jindex[6])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, kin);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, kin);
                                        continue;
                                    }
                                }
                                else
                                {
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, kin);
                                }

                                object O3 = new object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions
                                }

                                if (CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count > 0)
                                {
                                    object O = new object();
                                    lock (O)
                                    {
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, kin, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                    }
                }

                object O2 = new object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }

            return Do;
        }

        //collection objects calling full game specific game
        private bool FullGameThinkingTreeKingGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                //King.
                ThinkingAllowed[5] = true;
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(0, KingMidle, ik =>

 {
     if (KingOnTable != null && KingOnTable[ik] != null && KingOnTable[ik].KingThinkingQuantum != null && KingOnTable[ik].KingThinkingQuantum[0] != null
     )
     {
         object O = new object();
         lock (O)
         {
             Task<bool> array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeKing(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
             //TH.Add(array);
         }
     }
 });
            }

            return Do;
        }

        private bool FullGameThinkingTreeCastlingGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                //Castling.
                ThinkingAllowed[6] = true;
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(0, 1, ik =>

                 {
                     if (CastlingOnTable != null && CastlingOnTable[ik] != null && CastlingOnTable[ik].CastlingThinking != null && CastlingOnTable[ik].CastlingThinking[0] != null
                         )
                     {
                         object O = new object();
                         lock (O)
                         {
                             Task<bool> array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeCastling(7, ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                             array.Wait(); array.Dispose();
                             //TH.Add(array);
                         }
                     }
                 });
            }

            return Do;
        }

        //collection objects calling full game specific game
        private bool FullGameThinkingTreeSoldierBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                ThinkingAllowed[7] = true;
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(SodierMidle, SodierHigh, ik =>

 {
     if (SolderesOnTable != null && SolderesOnTable[ik] != null && SolderesOnTable[ik].SoldierThinkingQuantum != null && SolderesOnTable[ik].SoldierThinkingQuantum[0] != null
     )
     {
         //Soldier.
         object O = new object();
         lock (O)
         {
             Task<bool> array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeSoldier(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
             //TH.Add(array);
         }
     }
 });
            }

            return Do;
        }

        //collection objects calling full game specific game
        private bool FullGameThinkingTreeElephantBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                ThinkingAllowed[8] = true;
                //Elephant
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(ElefantMidle, ElefantHigh, ik =>

 {
     if (ElephantOnTable != null && ElephantOnTable[ik] != null && ElephantOnTable[ik].ElefantThinkingQuantum != null && ElephantOnTable[ik].ElefantThinkingQuantum[0] != null
     )
     {
         object O = new object();
         lock (O)
         {
             Task<bool> array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeElephant(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
             //TH.Add(array);
         }
     }
 });
            }

            return Do;
        }

        //collection objects calling full game specific game
        private bool FullGameThinkingTreeHourseBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                ThinkingAllowed[9] = true;
                //Hourse.
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(HourseMidle, HourseHight, ik =>

 {
     if (HoursesOnTable != null && HoursesOnTable[ik] != null && HoursesOnTable[ik].HourseThinkingQuantum != null && HoursesOnTable[ik].HourseThinkingQuantum[0] != null
     )
     {
         object O = new object();
         lock (O)
         {
             Task<bool> array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeHourse(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
             //TH.Add(array);
         }
     }
 });
            }

            return Do;
        }

        //collection objects calling full game specific game
        private bool FullGameThinkingTreeCastleBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                ThinkingAllowed[10] = true;
                //Castles.
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(CastleMidle, CastleHigh, ik =>

 {
     if (CastlesOnTable != null && CastlesOnTable[ik] != null && CastlesOnTable[ik].CastleThinkingQuantum != null && CastlesOnTable[ik].CastleThinkingQuantum[0] != null
     )
     {
         object O = new object();
         lock (O)
         {
             Task<bool> array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeCastle(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
             //TH.Add(array);
         }
     }
 });
            }

            return Do;
        }

        //collection objects calling full game specific game
        private bool FullGameThinkingTreeMinisterBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                ThinkingAllowed[11] = true;
                //Minister.
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(MinisterMidle, MinisterHigh, ik =>

 {
     if (MinisterOnTable != null && MinisterOnTable[ik] != null && MinisterOnTable[ik].MinisterThinkingQuantum != null && MinisterOnTable[ik].MinisterThinkingQuantum[0] != null
     )
     {
         object O = new object();
         lock (O)
         {
             Task<bool> array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeMinister(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
             //TH.Add(array);
         }
     }
 });
            }

            return Do;
        }

        //collection objects calling full game specific game
        private bool FullGameThinkingTreeKingBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                ThinkingAllowed[12] = true;
                //King.
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(KingMidle, KingHigh, ik =>

                 {
                     if (KingOnTable != null && KingOnTable[ik] != null && KingOnTable[ik].KingThinkingQuantum != null && KingOnTable[ik].KingThinkingQuantum[0] != null
                         )
                     {
                         object O = new object();
                         lock (O)
                         {
                             Task<bool> array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeKing(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                             array.Wait(); array.Dispose();
                             //TH.Add(array);
                         }
                     }
                 });
            }

            return Do;
        }

        private bool FullGameThinkingTreeCastlingBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            object O1 = new object();
            lock (O1)
            {
                ThinkingAllowed[13] = true;
                //Castling.
                ParallelOptions po = new ParallelOptions
                {
                    MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                }; Parallel.For(0, 1, ik =>

                 {
                     if (CastlingOnTable != null && CastlingOnTable[ik] != null && CastlingOnTable[ik].CastlingThinking != null && CastlingOnTable[ik].CastlingThinking[0] != null
                         )
                     {
                         object O = new object();
                         lock (O)
                         {
                             Task<bool> array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeCastling(-7, ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                             array.Wait(); array.Dispose();
                             //TH.Add(array);
                         }
                     }
                 });
            }

            return Do;
        }

        public bool FullGameThinkingTreeGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            object OOOOO = new object();
            lock (OOOOO)
            {
                bool Do = false;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                Task output = Task.Factory.StartNew(() =>
                {
                    //if (!feedCancellationTokenSource.IsCancellationRequested)
                    {
                        ParallelOptions po = new ParallelOptions
                        {
                            MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                        }; Parallel.Invoke(() =>
 {
     object O1 = new object();
     lock (O1)
     {
         if (Order == 1)
         {
             a = Color.Gray;
         }
         else
         {
             a = Color.Brown;
         }

         int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
         int Ord1 = OrderP;
         Color a1 = a;
         int iAStarGreedy1 = iAStarGreedy;

         Task<bool> array1 = Task.Factory.StartNew(() => Do |= FullGameThinkingTreeSoldierGray(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND, LeafAStarGreedy));
         array1.Wait(); array1.Dispose();

         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     object O1 = new object();
     lock (O1)
     {
         if (Order == 1)
         {
             a = Color.Gray;
         }
         else
         {
             a = Color.Brown;
         }

         int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
         int Ord2 = Order;
         Color a2 = a;
         int iAStarGreedy2 = iAStarGreedy;

         Task<bool> array2 = Task.Factory.StartNew(() => Do |= FullGameThinkingTreeElephantGray(a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND, LeafAStarGreedy));
         array2.Wait(); array2.Dispose();

         //Initiatye Variables.
         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     object O1 = new object();
     lock (O1)
     {
         if (Order == 1)
         {
             a = Color.Gray;
         }
         else
         {
             a = Color.Brown;
         }

         int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
         int Ord3 = Order;
         Color a3 = a;
         int iAStarGreedy3 = iAStarGreedy;

         Task<bool> array3 = Task.Factory.StartNew(() => Do |= FullGameThinkingTreeHourseGray(a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND, LeafAStarGreedy));
         array3.Wait(); array3.Dispose();

         //Initiatye Variables.
         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     object O1 = new object();
     lock (O1)
     {
         if (Order == 1)
         {
             a = Color.Gray;
         }
         else
         {
             a = Color.Brown;
         }

         int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
         int Ord4 = Order;
         Color a4 = a;
         int iAStarGreedy4 = iAStarGreedy;

         Task<bool> array4 = Task.Factory.StartNew(() => Do |= FullGameThinkingTreeCastleGray(a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND, LeafAStarGreedy));
         array4.Wait(); array4.Dispose();

         //Initiatye Variables.
         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     object O1 = new object();
     lock (O1)
     {
         if (Order == 1)
         {
             a = Color.Gray;
         }
         else
         {
             a = Color.Brown;
         }

         int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
         int Ord5 = Order;
         Color a5 = a;
         int iAStarGreedy5 = iAStarGreedy;

         Task<bool> array5 = Task.Factory.StartNew(() => Do |= FullGameThinkingTreeMinisterGray(a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND, LeafAStarGreedy));
         array5.Wait(); array5.Dispose();

         //Initiatye Variables.
         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     object O1 = new object();
     lock (O1)
     {
         if (Order == 1)
         {
             a = Color.Gray;
         }
         else
         {
             a = Color.Brown;
         }

         int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
         int Ord6 = Order;
         Color a6 = a;
         int iAStarGreedy6 = iAStarGreedy;

         Task<bool> array6 = Task.Factory.StartNew(() => Do |= FullGameThinkingTreeKingGray(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy));
         array6.Wait(); array6.Dispose();

         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     object O1 = new object();
     lock (O1)
     {
         if (Order == 1)
         {
             a = Color.Gray;
         }
         else
         {
             a = Color.Brown;
         }

         int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
         int Ord6 = Order;
         Color a6 = a;
         int iAStarGreedy6 = iAStarGreedy;

         Task<bool> array7 = Task.Factory.StartNew(() => Do |= FullGameThinkingTreeCastlingGray(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy));
         array7.Wait(); array7.Dispose();

         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 });
                    }
                });
                output.Wait(); output.Dispose();
                //TH.Add(output);

                //ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.ForEach(TH, item => Task.WaitAll(item));

                TH.Clear();
                return Do;
            }
        }

        //full game main method for deeper decicion and making
        public bool FullGameThinkingTreeBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            object OOOOO = new object();
            lock (OOOOO)
            {
                bool Do = false;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                Task output = Task.Factory.StartNew(() =>
                {
                    //if (!feedCancellationTokenSource.IsCancellationRequested)
                    {
                        ParallelOptions po = new ParallelOptions
                        {
                            MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount
                        }; Parallel.Invoke(() =>
 {
     object O1 = new object();
     lock (O1)
     {
         if (Order == 1)
         {
             a = Color.Gray;
         }
         else
         {
             a = Color.Brown;
         }

         int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
         int Ord1 = OrderP;
         Color a1 = a;
         int iAStarGreedy1 = iAStarGreedy;

         Task<bool> array1 = Task.Factory.StartNew(() => Do |= FullGameThinkingTreeSoldierBrown(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND, LeafAStarGreedy));
         array1.Wait(); array1.Dispose();

         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     object O1 = new object();
     lock (O1)
     {
         if (Order == 1)
         {
             a = Color.Gray;
         }
         else
         {
             a = Color.Brown;
         }

         int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
         int Ord2 = Order;
         Color a2 = a;
         int iAStarGreedy2 = iAStarGreedy;

         Task<bool> array2 = Task.Factory.StartNew(() => Do |= FullGameThinkingTreeElephantBrown(a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND, LeafAStarGreedy));
         array2.Wait(); array2.Dispose();

         //Initiatye Variables.
         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     object O1 = new object();
     lock (O1)
     {
         if (Order == 1)
         {
             a = Color.Gray;
         }
         else
         {
             a = Color.Brown;
         }

         int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
         int Ord3 = Order;
         Color a3 = a;
         int iAStarGreedy3 = iAStarGreedy;

         Task<bool> array3 = Task.Factory.StartNew(() => Do |= FullGameThinkingTreeHourseBrown(a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND, LeafAStarGreedy));
         array3.Wait(); array3.Dispose();

         //Initiatye Variables.
         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     object O1 = new object();
     lock (O1)
     {
         if (Order == 1)
         {
             a = Color.Gray;
         }
         else
         {
             a = Color.Brown;
         }

         int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
         int Ord4 = Order;
         Color a4 = a;
         int iAStarGreedy4 = iAStarGreedy;

         Task<bool> array4 = Task.Factory.StartNew(() => Do |= FullGameThinkingTreeCastleBrown(a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND, LeafAStarGreedy));
         array4.Wait(); array4.Dispose();

         //Initiatye Variables.
         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     object O1 = new object();
     lock (O1)
     {
         if (Order == 1)
         {
             a = Color.Gray;
         }
         else
         {
             a = Color.Brown;
         }

         int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
         int Ord5 = Order;
         Color a5 = a;
         int iAStarGreedy5 = iAStarGreedy;

         Task<bool> array5 = Task.Factory.StartNew(() => Do |= FullGameThinkingTreeMinisterBrown(a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND, LeafAStarGreedy));
         array5.Wait(); array5.Dispose();

         //Initiatye Variables.
         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     object O1 = new object();
     lock (O1)
     {
         if (Order == 1)
         {
             a = Color.Gray;
         }
         else
         {
             a = Color.Brown;
         }

         int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
         int Ord6 = Order;
         Color a6 = a;
         int iAStarGreedy6 = iAStarGreedy;

         Task<bool> array6 = Task.Factory.StartNew(() => Do |= FullGameThinkingTreeKingBrown(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy));
         array6.Wait(); array6.Dispose();

         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     object O1 = new object();
     lock (O1)
     {
         if (Order == 1)
         {
             a = Color.Gray;
         }
         else
         {
             a = Color.Brown;
         }

         int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
         int Ord6 = Order;
         Color a6 = a;
         int iAStarGreedy6 = iAStarGreedy;

         Task<bool> array7 = Task.Factory.StartNew(() => Do |= FullGameThinkingTreeCastlingBrown(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy));
         array7.Wait(); array7.Dispose();

         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 });
                    }
                });
                output.Wait(); output.Dispose();
                //TH.Add(output);

                //ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.ForEach(TH, item => Task.WaitAll(item));

                TH.Clear();
                return Do;
            }
        }

        //full game main method for deeper decicion and making
        public bool FullGameThinkingTree(int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            bool Do = false;
            //Initiatye Variables.
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            Color a;
            if (Order == 1)
            {
                a = Color.Gray;
            }
            else
            {
                a = Color.Brown;
            }

            object OOOOO = new object();
            lock (OOOOO)
            {
                //when search finished stop and return
                if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                {
                    return false;
                }
            }
            object O = new object();
            lock (O)
            {
                //when blitz game (limited game)
                if (AllDraw.Blitz)
                {
                    FullGameMakimgBlitz(ref Index, ref jindex, Order, LeafAStarGreedy);
                }
            }

            if (TH == null)
            {
                TH = new List<Task>();
            }

            if (Order == 1)
            {
                //Soldeir
                //Initiatye Variables.
                Task<bool> array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeGray(a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));

                array.Wait(); array.Dispose();
            }
            //For Brown Order Blitz Game Calculate Maximum Table Inclusive AStarGreedy First Game Search.
            else
            {
                Task<bool> array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeBrown(a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));

                array.Wait(); array.Dispose();
            }

            return Do;
        }

        //clone a table
        public int[,] CloneATable(int[,] Tab)
        {
            int[,] Tabl = new int[8, 8];
            for (int i = 0; i < 8; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    Tabl[i, j] = Tab[i, j];
                }
            }

            return Tabl;
        }

        //return maximum of six type values
        private int MaxOfSixHeuristic(double _1, double _2, double _3, double _4, double _5, double _6, double _7)
        {
            double[] LessB = new double[7];
            LessB[0] = _1;
            LessB[1] = _2;
            LessB[2] = _3;
            LessB[3] = _4;
            LessB[4] = _5;
            LessB[5] = _6;
            LessB[6] = _7;
            int Value = -1;
            double Les = double.MinValue;
            for (int i = 0; i < 7; i++)
            {
                if (LessB[i] > Les)
                {
                    Les = LessB[i];
                    Value = i;
                }
            }

            return Value;
        }

        //return minimum pf six type values
        private int MinOfSixHeuristic(double _1, double _2, double _3, double _4, double _5, double _6, double _7)
        {
            double[] LessB = new double[7];
            LessB[0] = _1;
            LessB[1] = _2;
            LessB[2] = _3;
            LessB[3] = _4;
            LessB[4] = _5;
            LessB[5] = _6;
            LessB[5] = _7;
            int Value = -1;
            double Les = double.MaxValue;
            for (int i = 0; i < 7; i++)
            {
                if (LessB[i] < Les)
                {
                    Les = LessB[i];
                    Value = i;
                }
            }

            return Value;
        }

        //determiniation and detection of zeros
        public bool TableZero(int[,] Ta)
        {
            bool Zerro = true;
            for (int i = 0; i < 8; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    if (Ta[i, j] != 0)
                    {
                        Zerro = false;
                    }
                }
            }

            return Zerro;
        }

        private int UniqueCapableMoveIsTruSup(int Kind, int Order, int ii, int jj)
        {
            int No = 0;
            if (!AllowedSupTrue)
            {
                if (Order == 1)
                {
                    if (Kind == 1)
                    {
                        for (int i = 0; i < SodierMidle; i++)
                        {
                            for (int j = 0; j < SolderesOnTable[i].SoldierThinkingQuantum[0].IsSupHu.Count; j++)
                            {
                                if (!SolderesOnTable[i].SoldierThinkingQuantum[0].IsSupHu[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 2)
                    {
                        for (int i = 0; i < ElefantMidle; i++)
                        {
                            for (int j = 0; j < ElephantOnTable[i].ElefantThinkingQuantum[0].IsSupHu.Count; j++)
                            {
                                if (!ElephantOnTable[i].ElefantThinkingQuantum[0].IsSupHu[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 3)
                    {
                        for (int i = 0; i < HourseMidle; i++)
                        {
                            for (int j = 0; j < HoursesOnTable[i].HourseThinkingQuantum[0].IsSupHu.Count; j++)
                            {
                                if (!HoursesOnTable[i].HourseThinkingQuantum[0].IsSupHu[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 4)
                    {
                        for (int i = 0; i < CastleMidle; i++)
                        {
                            for (int j = 0; j < CastlesOnTable[i].CastleThinkingQuantum[0].IsSupHu.Count; j++)
                            {
                                if (!CastlesOnTable[i].CastleThinkingQuantum[0].IsSupHu[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 5)
                    {
                        for (int i = 0; i < MinisterMidle; i++)
                        {
                            for (int j = 0; j < MinisterOnTable[i].MinisterThinkingQuantum[0].IsSupHu.Count; j++)
                            {
                                if (!MinisterOnTable[i].MinisterThinkingQuantum[0].IsSupHu[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 6)
                    {
                        for (int i = 0; i < KingMidle; i++)
                        {
                            for (int j = 0; j < KingOnTable[i].KingThinkingQuantum[0].IsSupHu.Count; j++)
                            {
                                if (!KingOnTable[i].KingThinkingQuantum[0].IsSupHu[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 7 || Kind == -7)
                    {
                        for (int i = 0; i < 1; i++)
                        {
                            for (int j = 0; j < CastlingOnTable[i].CastlingThinking[0].IsSupHu.Count; j++)
                            {
                                if (!CastlingOnTable[i].CastlingThinking[0].IsSupHu[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (Kind == 1)
                    {
                        for (int i = SodierMidle; i < SodierHigh; i++)
                        {
                            for (int j = 0; j < SolderesOnTable[i].SoldierThinkingQuantum[0].IsSupHu.Count; j++)
                            {
                                if (!SolderesOnTable[i].SoldierThinkingQuantum[0].IsSupHu[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 2)
                    {
                        for (int i = ElefantMidle; i < ElefantHigh; i++)
                        {
                            for (int j = 0; j < ElephantOnTable[i].ElefantThinkingQuantum[0].IsSupHu.Count; j++)
                            {
                                if (!ElephantOnTable[i].ElefantThinkingQuantum[0].IsSupHu[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 3)
                    {
                        for (int i = HourseMidle; i < HourseHight; i++)
                        {
                            for (int j = 0; j < HoursesOnTable[i].HourseThinkingQuantum[0].IsSupHu.Count; j++)
                            {
                                if (!HoursesOnTable[i].HourseThinkingQuantum[0].IsSupHu[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 4)
                    {
                        for (int i = CastleMidle; i < CastleHigh; i++)
                        {
                            for (int j = 0; j < CastlesOnTable[i].CastleThinkingQuantum[0].IsSupHu.Count; j++)
                            {
                                if (!CastlesOnTable[i].CastleThinkingQuantum[0].IsSupHu[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 5)
                    {
                        for (int i = MinisterMidle; i < MinisterHigh; i++)
                        {
                            for (int j = 0; j < MinisterOnTable[i].MinisterThinkingQuantum[0].IsSupHu.Count; j++)
                            {
                                if (!MinisterOnTable[i].MinisterThinkingQuantum[0].IsSupHu[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 6)
                    {
                        for (int i = KingMidle; i < KingHigh; i++)
                        {
                            for (int j = 0; j < KingOnTable[i].KingThinkingQuantum[0].IsSupHu.Count; j++)
                            {
                                if (!KingOnTable[i].KingThinkingQuantum[0].IsSupHu[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 7 || Kind == -7)
                    {
                        for (int i = 0; i < 1; i++)
                        {
                            for (int j = 0; j < CastlingOnTable[i].CastlingThinking[0].IsSupHu.Count; j++)
                            {
                                if (!CastlingOnTable[i].CastlingThinking[0].IsSupHu[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                if (Order == 1)
                {
                    if (Kind == 1)
                    {
                        for (int i = 0; i < SodierMidle; i++)
                        {
                            for (int j = 0; j < SolderesOnTable[i].SoldierThinkingQuantum[0].IsSup.Count; j++)
                            {
                                if (!SolderesOnTable[i].SoldierThinkingQuantum[0].IsSup[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 2)
                    {
                        for (int i = 0; i < ElefantMidle; i++)
                        {
                            for (int j = 0; j < ElephantOnTable[i].ElefantThinkingQuantum[0].IsSup.Count; j++)
                            {
                                if (!ElephantOnTable[i].ElefantThinkingQuantum[0].IsSup[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 3)
                    {
                        for (int i = 0; i < HourseMidle; i++)
                        {
                            for (int j = 0; j < HoursesOnTable[i].HourseThinkingQuantum[0].IsSup.Count; j++)
                            {
                                if (!HoursesOnTable[i].HourseThinkingQuantum[0].IsSup[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 4)
                    {
                        for (int i = 0; i < CastleMidle; i++)
                        {
                            for (int j = 0; j < CastlesOnTable[i].CastleThinkingQuantum[0].IsSup.Count; j++)
                            {
                                if (!CastlesOnTable[i].CastleThinkingQuantum[0].IsSup[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 5)
                    {
                        for (int i = 0; i < MinisterMidle; i++)
                        {
                            for (int j = 0; j < MinisterOnTable[i].MinisterThinkingQuantum[0].IsSup.Count; j++)
                            {
                                if (!MinisterOnTable[i].MinisterThinkingQuantum[0].IsSup[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 6)
                    {
                        for (int i = 0; i < KingMidle; i++)
                        {
                            for (int j = 0; j < KingOnTable[i].KingThinkingQuantum[0].IsSup.Count; j++)
                            {
                                if (!KingOnTable[i].KingThinkingQuantum[0].IsSup[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 7 || Kind == -7)
                    {
                        for (int i = 0; i < 1; i++)
                        {
                            for (int j = 0; j < CastlingOnTable[i].CastlingThinking[0].IsSup.Count; j++)
                            {
                                if (!CastlingOnTable[i].CastlingThinking[0].IsSup[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (Kind == 1)
                    {
                        for (int i = SodierMidle; i < SodierHigh; i++)
                        {
                            for (int j = 0; j < SolderesOnTable[i].SoldierThinkingQuantum[0].IsSup.Count; j++)
                            {
                                if (!SolderesOnTable[i].SoldierThinkingQuantum[0].IsSup[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 2)
                    {
                        for (int i = ElefantMidle; i < ElefantHigh; i++)
                        {
                            for (int j = 0; j < ElephantOnTable[i].ElefantThinkingQuantum[0].IsSup.Count; j++)
                            {
                                if (!ElephantOnTable[i].ElefantThinkingQuantum[0].IsSup[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 3)
                    {
                        for (int i = HourseMidle; i < HourseHight; i++)
                        {
                            for (int j = 0; j < HoursesOnTable[i].HourseThinkingQuantum[0].IsSup.Count; j++)
                            {
                                if (!HoursesOnTable[i].HourseThinkingQuantum[0].IsSup[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 4)
                    {
                        for (int i = CastleMidle; i < CastleHigh; i++)
                        {
                            for (int j = 0; j < CastlesOnTable[i].CastleThinkingQuantum[0].IsSup.Count; j++)
                            {
                                if (!CastlesOnTable[i].CastleThinkingQuantum[0].IsSup[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 5)
                    {
                        for (int i = MinisterMidle; i < MinisterHigh; i++)
                        {
                            for (int j = 0; j < MinisterOnTable[i].MinisterThinkingQuantum[0].IsSup.Count; j++)
                            {
                                if (!MinisterOnTable[i].MinisterThinkingQuantum[0].IsSup[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 6)
                    {
                        for (int i = KingMidle; i < KingHigh; i++)
                        {
                            for (int j = 0; j < KingOnTable[i].KingThinkingQuantum[0].IsSup.Count; j++)
                            {
                                if (!KingOnTable[i].KingThinkingQuantum[0].IsSup[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                    else if (Kind == 7 || Kind == -7)
                    {
                        for (int i = 0; i < 1; i++)
                        {
                            for (int j = 0; j < CastlingOnTable[i].CastlingThinking[0].IsSup.Count; j++)
                            {
                                if (!CastlingOnTable[i].CastlingThinking[0].IsSup[j])
                                {
                                    No++;
                                }
                            }
                        }
                    }
                }
            }
            if (No == 0)
            {
                if (!IgnoreOfLoseForKingReducedAttackDisturbingDouble(Kind, Order, ii, jj))
                {
                    No = -1;
                }
            }
            return No;
        }

        private bool IgnoreOfLoseForKingReducedAttackDisturbingDouble(int Kind, int Order, int i, int j)
        {
            bool No = true;
            if (!AllDraw.AllowedSupTrue)
            {
                if (Kind == 1)
                {
                    SolderesOnTable[i].SoldierThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref SolderesOnTable[i].LoseOcuuredatChiled, CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j]));
                    if ((SolderesOnTable[i].SoldierThinkingQuantum[0].RemoveOfDisturbIndex != j) && (SolderesOnTable[i].SoldierThinkingQuantum[0].LoseChiled[j] < 0 || SolderesOnTable[i].LoseOcuuredatChiled[0] < 0))
                    {
                        No = false;
                    }
                }
                else if (Kind == 2)
                {
                    ElephantOnTable[i].ElefantThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref ElephantOnTable[i].LoseOcuuredatChiled, CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j]));
                    if ((ElephantOnTable[i].ElefantThinkingQuantum[0].RemoveOfDisturbIndex != j) && (ElephantOnTable[i].ElefantThinkingQuantum[0].LoseChiled[j] < 0 || ElephantOnTable[i].LoseOcuuredatChiled[0] < 0))
                    {
                        No = false;
                    }
                }
                else if (Kind == 3)
                {
                    HoursesOnTable[i].HourseThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref HoursesOnTable[i].LoseOcuuredatChiled, CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j]));
                    if ((HoursesOnTable[i].HourseThinkingQuantum[0].RemoveOfDisturbIndex != j) && (HoursesOnTable[i].HourseThinkingQuantum[0].LoseChiled[j] < 0 || HoursesOnTable[i].LoseOcuuredatChiled[0] < 0))
                    {
                        No = false;
                    }
                }
                else if (Kind == 4)
                {
                    CastlesOnTable[i].CastleThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref CastlesOnTable[i].LoseOcuuredatChiled, CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j]));
                    if ((CastlesOnTable[i].CastleThinkingQuantum[0].RemoveOfDisturbIndex != j) && (CastlesOnTable[i].CastleThinkingQuantum[0].LoseChiled[j] < 0 || CastlesOnTable[i].LoseOcuuredatChiled[0] < 0))
                    {
                        No = false;
                    }
                }
                else if (Kind == 5)
                {
                    MinisterOnTable[i].MinisterThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref MinisterOnTable[i].LoseOcuuredatChiled, CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j]));
                    if ((MinisterOnTable[i].MinisterThinkingQuantum[0].RemoveOfDisturbIndex != j) && (MinisterOnTable[i].MinisterThinkingQuantum[0].LoseChiled[j] < 0 || MinisterOnTable[i].LoseOcuuredatChiled[0] < 0))
                    {
                        No = false;
                    }
                }
                else if (Kind == 6)
                {
                    KingOnTable[i].KingThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref KingOnTable[i].LoseOcuuredatChiled, CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j]));
                    if ((KingOnTable[i].KingThinkingQuantum[0].RemoveOfDisturbIndex != j) && (KingOnTable[i].KingThinkingQuantum[0].LoseChiled[j] < 0 || KingOnTable[i].LoseOcuuredatChiled[0] < 0))
                    {
                        No = false;
                    }
                }
                else if (Kind == 7 || Kind == -7)
                {
                    CastlingOnTable[i].CastlingThinking[0].TowDistrurbProperUsePreferNotToClose(ref CastlingOnTable[i].LoseOcuuredatChiled, CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]));
                    if ((CastlingOnTable[i].CastlingThinking[0].RemoveOfDisturbIndex != j) && (CastlingOnTable[i].CastlingThinking[0].LoseChiled[j] < 0 || CastlingOnTable[i].LoseOcuuredatChiled[0] < 0))
                    {
                        No = false;
                    }
                    if (Kind == 1)
                    {
                        SolderesOnTable[i].SoldierThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref SolderesOnTable[i].LoseOcuuredatChiled, CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j]));
                        if ((SolderesOnTable[i].SoldierThinkingQuantum[0].RemoveOfDisturbIndex != j) && (SolderesOnTable[i].SoldierThinkingQuantum[0].LoseChiled[j] < 0 || SolderesOnTable[i].LoseOcuuredatChiled[0] < 0))
                        {
                            No = false;
                        }
                    }
                    else
                    {
                        if (Kind == 1)
                        {
                            SolderesOnTable[i].SoldierThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref SolderesOnTable[i].LoseOcuuredatChiled, CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j]));
                            if ((SolderesOnTable[i].SoldierThinkingQuantum[0].RemoveOfDisturbIndex != j) && (SolderesOnTable[i].SoldierThinkingQuantum[0].LoseChiled[j] < 0))
                            {
                                No = false;
                            }
                        }
                        else if (Kind == 2)
                        {
                            ElephantOnTable[i].ElefantThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref ElephantOnTable[i].LoseOcuuredatChiled, CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j]));
                            if ((ElephantOnTable[i].ElefantThinkingQuantum[0].RemoveOfDisturbIndex != j) && (ElephantOnTable[i].ElefantThinkingQuantum[0].LoseChiled[j] < 0))
                            {
                                No = false;
                            }
                        }
                        else if (Kind == 3)
                        {
                            HoursesOnTable[i].HourseThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref HoursesOnTable[i].LoseOcuuredatChiled, CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j]));
                            if ((HoursesOnTable[i].HourseThinkingQuantum[0].RemoveOfDisturbIndex != j) && (HoursesOnTable[i].HourseThinkingQuantum[0].LoseChiled[j] < 0))
                            {
                                No = false;
                            }
                        }
                        else if (Kind == 4)
                        {
                            CastlesOnTable[i].CastleThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref CastlesOnTable[i].LoseOcuuredatChiled, CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j]));
                            if ((CastlesOnTable[i].CastleThinkingQuantum[0].RemoveOfDisturbIndex != j) && (CastlesOnTable[i].CastleThinkingQuantum[0].LoseChiled[j] < 0))
                            {
                                No = false;
                            }
                        }
                        else if (Kind == 5)
                        {
                            MinisterOnTable[i].MinisterThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref MinisterOnTable[i].LoseOcuuredatChiled, CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j]));
                            if ((MinisterOnTable[i].MinisterThinkingQuantum[0].RemoveOfDisturbIndex != j) && (MinisterOnTable[i].MinisterThinkingQuantum[0].LoseChiled[j] < 0))
                            {
                                No = false;
                            }
                        }
                        else if (Kind == 6)
                        {
                            KingOnTable[i].KingThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref KingOnTable[i].LoseOcuuredatChiled, CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j]));
                            if ((KingOnTable[i].KingThinkingQuantum[0].RemoveOfDisturbIndex != j) && (KingOnTable[i].KingThinkingQuantum[0].LoseChiled[j] < 0))
                            {
                                No = false;
                            }
                        }
                        else if (Kind == 7 || Kind == -7)
                        {
                            CastlingOnTable[i].CastlingThinking[0].TowDistrurbProperUsePreferNotToClose(ref CastlingOnTable[i].LoseOcuuredatChiled, CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]));
                            if ((CastlingOnTable[i].CastlingThinking[0].RemoveOfDisturbIndex != j) && (CastlingOnTable[i].CastlingThinking[0].LoseChiled[j] < 0))
                            {
                                No = false;
                            }
                        }
                    }

                    ElephantOnTable[i].ElefantThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref ElephantOnTable[i].LoseOcuuredatChiled, CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j]));
                    if ((ElephantOnTable[i].ElefantThinkingQuantum[0].RemoveOfDisturbIndex != j) && (ElephantOnTable[i].ElefantThinkingQuantum[0].LoseChiled[j] < 0 || ElephantOnTable[i].LoseOcuuredatChiled[0] < 0))
                    {
                        ElephantOnTable[i].ElefantThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref ElephantOnTable[i].LoseOcuuredatChiled, CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j]));
                        if ((ElephantOnTable[i].ElefantThinkingQuantum[0].RemoveOfDisturbIndex != j) && (ElephantOnTable[i].ElefantThinkingQuantum[0].LoseChiled[j] < 0 || ElephantOnTable[i].LoseOcuuredatChiled[0] < 0))
                        {

                            No = false;
                        }
                    }
                    else if (Kind == 3)
                    {
                        HoursesOnTable[i].HourseThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref HoursesOnTable[i].LoseOcuuredatChiled, CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j]));
                        if ((HoursesOnTable[i].HourseThinkingQuantum[0].RemoveOfDisturbIndex != j) && (HoursesOnTable[i].HourseThinkingQuantum[0].LoseChiled[j] < 0 || HoursesOnTable[i].LoseOcuuredatChiled[0] < 0))
                        {
                            No = false;
                        }
                    }
                    else if (Kind == 4)
                    {
                        CastlesOnTable[i].CastleThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref CastlesOnTable[i].LoseOcuuredatChiled, CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j]));
                        if ((CastlesOnTable[i].CastleThinkingQuantum[0].RemoveOfDisturbIndex != j) && (CastlesOnTable[i].CastleThinkingQuantum[0].LoseChiled[j] < 0 || CastlesOnTable[i].LoseOcuuredatChiled[0] < 0))
                        {
                            No = false;
                        }
                    }
                    else if (Kind == 5)
                    {
                        MinisterOnTable[i].MinisterThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref MinisterOnTable[i].LoseOcuuredatChiled, CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j]));
                        if ((MinisterOnTable[i].MinisterThinkingQuantum[0].RemoveOfDisturbIndex != j) && (MinisterOnTable[i].MinisterThinkingQuantum[0].LoseChiled[j] < 0 || MinisterOnTable[i].LoseOcuuredatChiled[0] < 0))
                        {
                            No = false;
                        }
                    }
                    else if (Kind == 6)
                    {
                        KingOnTable[i].KingThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref KingOnTable[i].LoseOcuuredatChiled, CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j]));
                        if ((KingOnTable[i].KingThinkingQuantum[0].RemoveOfDisturbIndex != j) && (KingOnTable[i].KingThinkingQuantum[0].LoseChiled[j] < 0 || KingOnTable[i].LoseOcuuredatChiled[0] < 0))
                        {
                            No = false;
                        }
                    }
                    else if (Kind == 7 || Kind == -7)
                    {
                        CastlingOnTable[i].CastlingThinking[0].TowDistrurbProperUsePreferNotToClose(ref CastlingOnTable[i].LoseOcuuredatChiled, CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]));
                        if ((CastlingOnTable[i].CastlingThinking[0].RemoveOfDisturbIndex != j) && (CastlingOnTable[i].CastlingThinking[0].LoseChiled[j] < 0 || CastlingOnTable[i].LoseOcuuredatChiled[0] < 0))
                        {
                            No = false;
                        }
                    }
                }
            }
            else
            {
                if (Kind == 1)
                {
                    SolderesOnTable[i].SoldierThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref SolderesOnTable[i].LoseOcuuredatChiled, CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j]));
                    if ((SolderesOnTable[i].SoldierThinkingQuantum[0].RemoveOfDisturbIndex != j) && (SolderesOnTable[i].SoldierThinkingQuantum[0].LoseChiled[j] < 0 || SolderesOnTable[i].LoseOcuuredatChiled[0] < 0))
                    {
                        No = false;
                    }
                }
                else if (Kind == 2)
                {
                    ElephantOnTable[i].ElefantThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref ElephantOnTable[i].LoseOcuuredatChiled, CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j]));
                    if ((ElephantOnTable[i].ElefantThinkingQuantum[0].RemoveOfDisturbIndex != j) && (ElephantOnTable[i].ElefantThinkingQuantum[0].LoseChiled[j] < 0 || ElephantOnTable[i].LoseOcuuredatChiled[0] < 0))
                    {
                        No = false;
                    }
                }
                else if (Kind == 3)
                {
                    HoursesOnTable[i].HourseThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref HoursesOnTable[i].LoseOcuuredatChiled, CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j]));
                    if ((HoursesOnTable[i].HourseThinkingQuantum[0].RemoveOfDisturbIndex != j) && (HoursesOnTable[i].HourseThinkingQuantum[0].LoseChiled[j] < 0 || HoursesOnTable[i].LoseOcuuredatChiled[0] < 0))
                    {
                        No = false;
                    }
                }
                else if (Kind == 4)
                {
                    CastlesOnTable[i].CastleThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref CastlesOnTable[i].LoseOcuuredatChiled, CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j]));
                    if ((CastlesOnTable[i].CastleThinkingQuantum[0].RemoveOfDisturbIndex != j) && (CastlesOnTable[i].CastleThinkingQuantum[0].LoseChiled[j] < 0 || CastlesOnTable[i].LoseOcuuredatChiled[0] < 0))
                    {
                        No = false;
                    }
                }
                else if (Kind == 5)
                {
                    MinisterOnTable[i].MinisterThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref MinisterOnTable[i].LoseOcuuredatChiled, CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j]));
                    if ((MinisterOnTable[i].MinisterThinkingQuantum[0].RemoveOfDisturbIndex != j) && (MinisterOnTable[i].MinisterThinkingQuantum[0].LoseChiled[j] < 0 || MinisterOnTable[i].LoseOcuuredatChiled[0] < 0))
                    {
                        No = false;
                    }
                }
                else if (Kind == 6)
                {
                    KingOnTable[i].KingThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref KingOnTable[i].LoseOcuuredatChiled, CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j]));
                    if ((KingOnTable[i].KingThinkingQuantum[0].RemoveOfDisturbIndex != j) && (KingOnTable[i].KingThinkingQuantum[0].LoseChiled[j] < 0 || KingOnTable[i].LoseOcuuredatChiled[0] < 0))
                    {
                        No = false;
                    }
                }
                else if (Kind == 7 || Kind == -7)
                {
                    CastlingOnTable[i].CastlingThinking[0].TowDistrurbProperUsePreferNotToClose(ref CastlingOnTable[i].LoseOcuuredatChiled, CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]));
                    if ((CastlingOnTable[i].CastlingThinking[0].RemoveOfDisturbIndex != j) && (CastlingOnTable[i].CastlingThinking[0].LoseChiled[j] < 0 || CastlingOnTable[i].LoseOcuuredatChiled[0] < 0))
                    {
                        No = false;
                    }
                }
                else
                {

                    if (Kind == 1)
                    {
                        SolderesOnTable[i].SoldierThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref SolderesOnTable[i].LoseOcuuredatChiled, CloneATable(SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder[j]));
                        if ((SolderesOnTable[i].SoldierThinkingQuantum[0].RemoveOfDisturbIndex != j) && (SolderesOnTable[i].SoldierThinkingQuantum[0].LoseChiled[j] < 0))
                        {
                            No = false;
                        }
                    }
                    else if (Kind == 2)
                    {
                        ElephantOnTable[i].ElefantThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref ElephantOnTable[i].LoseOcuuredatChiled, CloneATable(ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant[j]));
                        if ((ElephantOnTable[i].ElefantThinkingQuantum[0].RemoveOfDisturbIndex != j) && (ElephantOnTable[i].ElefantThinkingQuantum[0].LoseChiled[j] < 0))
                        {
                            No = false;
                        }
                    }
                    else if (Kind == 3)
                    {
                        HoursesOnTable[i].HourseThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref HoursesOnTable[i].LoseOcuuredatChiled, CloneATable(HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse[j]));
                        if ((HoursesOnTable[i].HourseThinkingQuantum[0].RemoveOfDisturbIndex != j) && (HoursesOnTable[i].HourseThinkingQuantum[0].LoseChiled[j] < 0))
                        {
                            No = false;
                        }
                    }
                    else if (Kind == 4)
                    {
                        CastlesOnTable[i].CastleThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref CastlesOnTable[i].LoseOcuuredatChiled, CloneATable(CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle[j]));
                        if ((CastlesOnTable[i].CastleThinkingQuantum[0].RemoveOfDisturbIndex != j) && (CastlesOnTable[i].CastleThinkingQuantum[0].LoseChiled[j] < 0))
                        {
                            No = false;
                        }
                    }
                    else if (Kind == 5)
                    {
                        MinisterOnTable[i].MinisterThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref MinisterOnTable[i].LoseOcuuredatChiled, CloneATable(MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister[j]));
                        if ((MinisterOnTable[i].MinisterThinkingQuantum[0].RemoveOfDisturbIndex != j) && (MinisterOnTable[i].MinisterThinkingQuantum[0].LoseChiled[j] < 0))
                        {
                            No = false;
                        }
                    }
                    else if (Kind == 6)
                    {
                        KingOnTable[i].KingThinkingQuantum[0].TowDistrurbProperUsePreferNotToClose(ref KingOnTable[i].LoseOcuuredatChiled, CloneATable(KingOnTable[i].KingThinkingQuantum[0].TableListKing[j]));
                        if ((KingOnTable[i].KingThinkingQuantum[0].RemoveOfDisturbIndex != j) && (KingOnTable[i].KingThinkingQuantum[0].LoseChiled[j] < 0))
                        {
                            No = false;
                        }
                    }
                    else if (Kind == 7 || Kind == -7)
                    {
                        CastlingOnTable[i].CastlingThinking[0].TowDistrurbProperUsePreferNotToClose(ref CastlingOnTable[i].LoseOcuuredatChiled, CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]));
                        if ((CastlingOnTable[i].CastlingThinking[0].RemoveOfDisturbIndex != j) && (CastlingOnTable[i].CastlingThinking[0].LoseChiled[j] < 0))
                        {
                            No = false;
                        }
                    }
                }


            }

            return No;
        }

        //Main Initiate Thinking Method.
        public int[,] Initiate(int ii, int jj, Color a, int[,] Table, int Order, bool TB, bool FOUND, int LeafAStarGreedy, bool SetDept = false)
        {
            object o = new object();
            lock (o)
            {
                Task ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGame(CloneATable(Table), Order, PlatformHelper.ProcessorCount + AllDraw.StoreInitMaxAStarGreedy - AllDraw.MaxAStarGreedy, ii, jj, 0, 0, FOUND, LeafAStarGreedy));
                ah.Wait();
                ah.Dispose();

                object n = new object();
                lock (n)
                {
                    //due to resource leak of in leak depth
                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                    AllDraw.ChangedInTreeOccured = false;
                }
                QuantumRefrigiz.AllDraw.TimeInitiation = (DateTime.Now.Hour * 60 * 60 * 1000 + DateTime.Now.Minute * 60 * 1000 + DateTime.Now.Second * 1000);

                LeafSemaphoreIndex = false;
                if (tH != null)
                {
                    tH.Clear();
                }
                else
                {
                    tH = new List<Task>();
                }

                if (TH != null)
                {
                    TH.Clear();
                }
                else
                {
                    TH = new List<Task>();
                }

                ThinkingQuantumChess.Colleralation = int.MinValue;
                ThinkingQuantumChess.DeColleralation = int.MaxValue;
                if (FOUND && (!FirstTraversalTree))
                {
                    NumberOfLeafComputation = ThinkingQuantumChess.NumbersOfAllNode;
                }
                else
                {
                    NumberOfLeafComputation = -1;
                }

                ThinkingQuantumChess.IsAtLeastOneKillerAtDraw = false;

                //var parallelOptions = new ParallelOptions();
                //parallelOptionsMaxDegreeOfParallelism =System.Threading.PlatformHelper.ProcessorCount; //PlatformHelper.ProcessorCount;
                int[,] TableHeuristic = null;
                int Current = ChessRules.CurrentOrder;
                int DummyOrder = Order;
                object O = new object();
                lock (O)
                {
                    AllDraw.ActionStringReady = false;
                    ThinkingQuantumChess.LearningVarsCheckedMateOccured = false;
                    ThinkingQuantumChess.LearningVarsCheckedMateOccuredOneCheckedMate = false;
                    RegardOccurred = false;
                    object OO21 = new object();
                    lock (OO21)
                    {
                        TaskBegin = 0;
                        TaskEnd = 0;
                    }
                    object OO1 = new object();
                    lock (OO1)
                    {
                        lock (OO1)
                        {
                            if (AllDraw.THIScomboBoxMaxLevelText != "")
                            {
                                MaxDuringLevelThinkingCreation = System.Convert.ToInt32(AllDraw.THIScomboBoxMaxLevelText);
                            }
                        }
                    }
                    object Om1 = new object();
                    lock (Om1)
                    {
                        MinThinkingTreeDepth = 0;
                    }
                    ThinkingQuantumChess.FoundFirstMating = 0;
                    ThinkingQuantumChess.FoundFirstSelfMating = 0;
                    //Monitor Log File Appending First Line.
                    object On = new object();
                    lock (On)
                    {
                    }
                    //Initiate Local and Global Variables.
                    object ol = new object();
                    lock (ol)
                    {
                        CurrentHeuristic = int.MinValue;
                        MaxHeuristicxT = int.MinValue;
                        DrawCastleQ.MaxHeuristicxB = int.MinValue;
                        DrawElefantQ.MaxHeuristicxE = int.MinValue;
                        DrawHourseQ.MaxHeuristicxH = int.MinValue;
                        DrawKingQ.MaxHeuristicxK = int.MinValue;
                        DrawMinisterQ.MaxHeuristicxM = int.MinValue;
                        DrawSoldierQ.MaxHeuristicxS = int.MinValue;
                        MovementsAStarGreedyHeuristicFoundT = false;
                        DrawTable = false;
                        ChessRules.CheckBrownObjectDangourFirstTimesOcured = false;
                        ChessRules.CheckGrayObjectDangourFirstTimesOcured = false;
                    }
                }
                MaxHeuristicAStarGreedytBackWard.Clear();
                int[,] Tab = null;
                if (!FOUND)
                {
                    object O7 = new object();
                    lock (O7)
                    {
                        ThinkingQuantumChess.NotSolvedKingDanger = false;
                        LoopHeuristicIndex = 0;
                        Less = int.MinValue;
                    }
                }
                //THIS.Invoke((MethodInvoker)delegate()
                /*{
                    Object OOO = new Object();
                    lock (OOO)
                    {
                        if (!SetDept)
                            MaxAStarGreedy = System.Convert.ToInt32(AllDraw.MaxDuringLevelThinkingCreation);
                        AllDraw.AStarGreedyiLevelMax = MaxAStarGreedy;
                        AStarGreedyiLevelMax = System.Convert.ToInt32(AllDraw.MaxDuringLevelThinkingCreation);
                        AllDraw.MaxAStarGreedyHeuristicProgress = 6;
                        for (var i = 0; i <= MaxAStarGreedy; i++)
                            AllDraw.MaxAStarGreedyHeuristicProgress += AllDraw.MaxAStarGreedyHeuristicProgress * 6;
                        increasedProgress = (int)((int)999999999 / (int)(AllDraw.MaxAStarGreedyHeuristicProgress));
                        Object Omm1 = new Object();
                        lock (Omm1)
                        {
                            AStarGreedytMaxCount = (int)MaxAStarGreedy;
                        }
                    }
                }*/
                ChessRules.CurrentOrder = Current;
                Order = DummyOrder;
                int iiii = ii, jjjj = jj, Ord = Order;
                int MaxAStarGreedy1 = 0;
                object OOOO = new object();
                lock (OOOO)
                {
                    //if (MaxAStarGreedy == 0)
                    //MaxAStarGreedy = 0; // PlatformHelper.ProcessorCount;
                    MaxAStarGreedy1 = MaxAStarGreedy;
                    int[,] Tabl = CloneATable(Table);
                    Color aaa = a;
                    AllDraw THISA = AStarGreedyString;
                     Task<AllDraw> H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + AllDraw.StoreInitMaxAStarGreedy - AllDraw.MaxAStarGreedy, iiii, jjjj, aaa, CloneATable(Tabl), Ord, false, FOUND, LeafAStarGreedy));
                    H.Wait();
                    H.Dispose();
                    AStarGreedyString = THISA;
                }
                object Om = new object();
                lock (Om)
                {
                    MinThinkingTreeDepth = MaxAStarGreedy - MinThinkingTreeDepth;
                    //Initaite Local Varibales.
                    Tab = new int[8, 8];
                    Less = int.MinValue;
                }
                ChessRules.CurrentOrder = Current;
                Order = DummyOrder;
                object OO = new object();
                lock (OO)
                {
                }

                NumberOfLeafComputation = -1;

                TableHeuristic = HeuristicAStarGreedySearch(0, a, Order, false);
                if ((TableHeuristic == null || ((TableZero(TableHeuristic)))) && UsePenaltyRegardMechnisamT)
                {
                    object OOoOO = new object();
                    lock (OOoOO)
                    {
                        bool aa = UsePenaltyRegardMechnisamT;
                        if (UsePenaltyRegardMechnisamT)
                        {
                            UsePenaltyRegardMechnisamT = false;

                            RemovePenalltyFromFirstBranches(Order);
                            MaxAStarGreedy = 1;
                            AStarGreedyiLevelMax = 1;
                        }
                        Less = int.MinValue;

                        AllowedSupTrue = true;

                        TableHeuristic = HeuristicAStarGreedySearch(0, a, Order, false);

                        AllowedSupTrue = false;

                        UsePenaltyRegardMechnisamT = aa;
                    }
                }
                else
                if ((TableHeuristic == null || ((TableZero(TableHeuristic)))))
                {
                    //If Table Found.
                    if (TableHeuristic != null)
                    {
                        object OOoOO = new object();
                        lock (OOoOO)
                        {
                            bool aa = UsePenaltyRegardMechnisamT;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                UsePenaltyRegardMechnisamT = false;

                                RemovePenalltyFromFirstBranches(Order);
                                MaxAStarGreedy = 1;
                                AStarGreedyiLevelMax = 1;
                            }
                            Less = int.MinValue;

                            AllowedSupTrue = true;

                            TableHeuristic = HeuristicAStarGreedySearch(0, a, Order, false);

                            AllowedSupTrue = false;
                            UsePenaltyRegardMechnisamT = aa;
                        }
                    }
                    else
                    {
                        object OOoOO = new object();
                        lock (OOoOO)
                        {
                            //Clear AStarGreedy Varibales.
                            AllDraw.StoreADraw.Clear();
                            TableCurrent.Clear();
                        }
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = Current;

                        object Omm = new object();
                        lock (Omm)
                        {
                            DrawTable = true;
                            FoundATable = true;
                        }
                    }
                }
                //indexStep++;//no to axelirity speed

                return CloneATable(TableHeuristic);
            }
        }

        //Identification of Illegal AStarGreedy First and Common Hurist Movments.
        public bool IsEnemyThingsinStable(int[,] TableHeuristic, int[,] TableAction, int Order)
        {
            //Iniatiet Local Variables.
            int[,] Cromosom1 = TableHeuristic;
            int[,] Cromosom2 = TableAction;
            bool and = true;
            bool Find = false;

            int FindNumber = 0;
            //int
            //CromosomRowFirst = -1, //CromosomColumnFirst = -1,
            ////CromosomRow = -1, //CromosomColumn = -1;
            //Initiate Local Variables.
            //For All Table Home
            for (int i = 0; i < 8; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    //Gray Order.
                    if (Order == 1)
                    {
                        //Situation 11.
                        if (and)
                        {
                            //All The Brown Object Ignored.
                            if (Cromosom1[i, j] < 0 && Cromosom2[i, j] < 0)
                            {
                                continue;
                            }
                        }
                        else///Situation 2.
                        {
                            //All The Brown Ojects Ignored.
                            if (Cromosom1[i, j] < 0 || Cromosom2[i, j] < 0)
                            {
                                continue;
                            }
                        }
                    }
                    else//Brown Order.
                    {
                        //Situation 1.
                        if (and)
                        {
                            //All The Gray Objects Ignored.
                            if (Cromosom1[i, j] > 0 && Cromosom2[i, j] > 0)
                            {
                                continue;
                            }
                        }
                        else
                        {
                            //All The Gray Objects Ignored.
                            if (Cromosom1[i, j] > 0 || Cromosom2[i, j] > 0)
                            {
                                continue;
                            }
                        }
                    }
                    if (!(ArrangmentsChanged))
                    {
                        {
                            if (Order == 1 && j == 6 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j + 1] > 0) || (Cromosom2[i + 1, j + 1] > 0 && Cromosom1[i + 1, j + 1] < 0) || (Cromosom2[i - 1, j + 1] > 0 && Cromosom1[i - 1, j + 1] < 0) && Cromosom1[i, j] == 1))
                                {
                                    //CromosomRowFirst = i;
                                    //CromosomColumnFirst = j;
                                    if (Cromosom2[i, j + 1] > 0)
                                    {
                                        //CromosomRow = i;
                                        //CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i + 1, j + 1] > 0 && Cromosom1[i + 1, j + 1] < 0)
                                    {
                                        //CromosomRow = i + 1;
                                        //CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i - 1, j + 1] > 0 && Cromosom1[i - 1, j + 1] < 0)
                                    {
                                        //CromosomRow = i - 1;
                                        //CromosomColumn = j + 1;
                                    }
                                    Find = true;
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;
                                }
                            }
                            else
                                if (Order == -1 && j == 1 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j - 1] < 0) || (Cromosom2[i + 1, j - 1] < 0 && Cromosom1[i + 1, j - 1] > 0) || (Cromosom2[i - 1, j - 1] < 0 && Cromosom1[i - 1, j - 1] < 0) && Cromosom1[i, j] == -1))
                                {
                                    //CromosomRowFirst = i;
                                    //CromosomColumnFirst = j;
                                    if (Cromosom2[i, j - 1] > 0)
                                    {
                                        //CromosomRow = i;
                                        //CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i + 1, j - 1] > 0 && Cromosom1[i + 1, j - 1] < 0)
                                    {
                                        //CromosomRow = i + 1;
                                        //CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i - 1, j - 1] > 0 && Cromosom1[i - 1, j - 1] < 0)
                                    {
                                        //CromosomRow = i - 1;
                                        //CromosomColumn = j - 1;
                                    }
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;
                                }
                            }
                            //Castles King Validity Condition.
                            if (Order == 1 && j == 0)
                            {
                                //Small Gray Castles King.
                                if (i == 6 && Cromosom2[i, j] == 6 && Cromosom2[i - 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i - 1, j] != 4)
                                {
                                    //CromosomRowFirst = i - 3;
                                    //CromosomColumnFirst = j;
                                    //CromosomRow = i;
                                    //CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingCastleGray = true;
                                    CastlesKing = true;
                                }
                                else //Big Briges King Gray.
                                    if (i == 2 && Cromosom2[i, j] == 6 && Cromosom2[i + 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i + 1, j] != 4)
                                {
                                    //CromosomRowFirst = i + 3;
                                    //CromosomColumnFirst = j;
                                    //CromosomRow = i;
                                    //CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.BigKingCastleGray = true;
                                    CastlesKing = true;
                                }
                            }
                            else if (j == 7)
                            {
                                //Small Castles King Brown.
                                if (i == 6 && Cromosom2[i, j] == -6 && Cromosom2[i - 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i - 1, j] != -4)
                                {
                                    //CromosomRowFirst = i - 3;
                                    //CromosomColumnFirst = j;
                                    //CromosomRow = i;
                                    //CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingCastleBrown = true;
                                    CastlesKing = true;
                                }
                                else//Big Castles King Brown.
                                    if (i == 2 && Cromosom2[i, j] == -6 && Cromosom2[i + 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i + 1, j] != -4)
                                {
                                    //CromosomRowFirst = i + 3;
                                    //CromosomColumnFirst = j;
                                    //CromosomRow = i;
                                    //CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.BigKingCastleBrown = true;
                                    CastlesKing = true;
                                }
                            }
                        }
                    }
                    else
                    {
                        {
                            if (Order == 1 && j == 1 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j - 1] > 0) || (Cromosom2[i + 1, j - 1] > 0 && Cromosom1[i + 1, j - 1] < 0) || (Cromosom2[i - 1, j - 1] > 0 && Cromosom1[i - 1, j - 1] < 0) && Cromosom1[i, j] == 1))
                                {
                                    //CromosomRowFirst = i;
                                    //CromosomColumnFirst = j;
                                    if (Cromosom2[i, j - 1] > 0)
                                    {
                                        //CromosomRow = i;
                                        //CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i + 1, j - 1] > 0 && Cromosom1[i + 1, j - 1] < 0)
                                    {
                                        //CromosomRow = i + 1;
                                        //CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i - 1, j - 1] > 0 && Cromosom1[i - 1, j - 1] < 0)
                                    {
                                        //CromosomRow = i - 1;
                                        //CromosomColumn = j - 1;
                                    }
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;
                                }
                            }
                            else
                                if (Order == -1 && j == 6 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j + 1] < 0) || (Cromosom2[i + 1, j + 1] < 0 && Cromosom1[i + 1, j + 1] > 0) || (Cromosom2[i - 1, j + 1] < 0 && Cromosom1[i - 1, j + 1] < 0) && Cromosom1[i, j] == -1))
                                {
                                    //CromosomRowFirst = i;
                                    //CromosomColumnFirst = j;
                                    if (Cromosom2[i, j + 1] > 0)
                                    {
                                        //CromosomRow = i;
                                        //CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i + 1, j + 1] > 0 && Cromosom1[i + 1, j + 1] < 0)
                                    {
                                        //CromosomRow = i + 1;
                                        //CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i - 1, j + 1] > 0 && Cromosom1[i - 1, j + 1] < 0)
                                    {
                                        //CromosomRow = i - 1;
                                        //CromosomColumn = j + 1;
                                    }
                                    Find = true;
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;
                                }
                            }
                            //Castles King Validity Condition.
                            if (Order == 1 && j == 7)
                            {
                                //Small Gray Castles King.
                                if (i == 6 && Cromosom2[i, j] == 6 && Cromosom2[i - 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i - 1, j] != 4)
                                {
                                    //CromosomRowFirst = i - 3;
                                    //CromosomColumnFirst = j;
                                    //CromosomRow = i;
                                    //CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingCastleGray = true;
                                    CastlesKing = true;
                                }
                                else //Big Briges King Gray.
                                    if (i == 2 && Cromosom2[i, j] == 6 && Cromosom2[i + 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i + 1, j] != 4)
                                {
                                    //CromosomRowFirst = i + 3;
                                    //CromosomColumnFirst = j;
                                    //CromosomRow = i;
                                    //CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.BigKingCastleGray = true;
                                    CastlesKing = true;
                                }
                            }
                            else if (j == 0)
                            {
                                //Small Castles King Brown.
                                if (i == 6 && Cromosom2[i, j] == -6 && Cromosom2[i - 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i - 1, j] != -4)
                                {
                                    //CromosomRowFirst = i - 3;
                                    //CromosomColumnFirst = j;
                                    //CromosomRow = i;
                                    //CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingCastleBrown = true;
                                    CastlesKing = true;
                                }
                                else//Big Castles King Brown.
                                    if (i == 2 && Cromosom2[i, j] == -6 && Cromosom2[i + 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i + 1, j] != -4)
                                {
                                    //CromosomRowFirst = i + 3;
                                    //CromosomColumnFirst = j;
                                    //CromosomRow = i;
                                    //CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.BigKingCastleBrown = true;
                                    CastlesKing = true;
                                }
                            }
                        }
                    }
                    //When To Same Location Tbles are Different in Gen.
                    if (Cromosom1[i, j] != Cromosom2[i, j])
                    {
                        //When Cromosom 2 is Empty.
                        if (Cromosom2[i, j] == 0)
                        {
                            //Initiate Location of Table.
                            continue;
                        }
                        else
                        {
                            //Situation 1.0
                            if (and)
                            {
                                //When Cromosom1 Current Location is Empty.
                                if (Cromosom1[i, j] == 0)
                                {
                                    //Initiate Location of Gen.
                                    //CromosomRow = i;
                                    //CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    continue;
                                }
                            }
                        }
                        //Store Location of Gen and Calculate Gen Numbers.
                        //CromosomRow = i;
                        //CromosomColumn = j;
                        Find = true;
                        FindNumber++;
                    }
                }
            }

            //If Gen Foundation is Valid.
            if (((FindNumber == 1 || FindNumber == 2) && Find) || CastlesKing || AllDraw.SodierConversionOcuured)
            {
                return Find;
            }
            //Gen Not Found.
            return false;
        }

        //recursive base 'pre-proccessing" writing
        public void RewriteAllDrawRec(BinaryFormatter Formatters, FileStream DummyFileStream, int Order)
        {
            object o = new object();
            lock (o)
            {
                AllDraw Node = this;

                if (DummyFileStream.Position >= DummyFileStream.Length)
                {
                    return;
                }

                RewriteAllDrawRecS(Formatters, DummyFileStream, Order);
                RewriteAllDrawRecE(Formatters, DummyFileStream, Order);
                RewriteAllDrawRecH(Formatters, DummyFileStream, Order);
                RewriteAllDrawRecC(Formatters, DummyFileStream, Order);
                RewriteAllDrawRecM(Formatters, DummyFileStream, Order);
                RewriteAllDrawRecK(Formatters, DummyFileStream, Order);
                RewriteAllDrawRecA(Formatters, DummyFileStream, Order);
            }
        }

        public void RewriteAllDrawRecS(BinaryFormatter Formatters, FileStream DummyFileStream, int Order)
        {
            object o = new object();
            lock (o)
            {
                AllDraw Node = this;

                if (DummyFileStream.Position >= DummyFileStream.Length)
                {
                    return;
                }
                try
                {
                    Formatters.Serialize(DummyFileStream, Node.SodierMidle);
                    Formatters.Serialize(DummyFileStream, Node.SodierHigh);
                }
                catch (Exception t) { Log(t); }

                for (int i = 0; i < Node.SodierHigh; i++)
                {
                    try
                    {
                        if (Node.SolderesOnTable == null)
                        {
                            continue;
                        }

                        if (Node.SolderesOnTable[i] == null)
                        {
                            continue;
                        }

                        if (Node.SolderesOnTable[i].SoldierThinkingQuantum == null)
                        {
                            continue;
                        }

                        if (Node.SolderesOnTable[i].SoldierThinkingQuantum[0] == null)
                        {
                            continue;
                        }

                        if (Node.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count == 0)
                        {
                            continue;
                        }

                        Formatters.Serialize(DummyFileStream, Node.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count);
                        for (int j = 0; j < Node.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; j++)
                        {
                            Formatters.Serialize(DummyFileStream, Node.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j]);
                            Node.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                        }
                    }
                    catch (Exception t) { Log(t); }
                }
            }
        }
        public void RewriteAllDrawRecE(BinaryFormatter Formatters, FileStream DummyFileStream, int Order)
        {
            object o = new object();
            lock (o)
            {
                AllDraw Node = this;

                try
                {
                    if (DummyFileStream.Position >= DummyFileStream.Length)
                    {
                        return;
                    }

                    Formatters.Serialize(DummyFileStream, Node.ElefantMidle);
                    Formatters.Serialize(DummyFileStream, Node.ElefantHigh);
                }
                catch (Exception t) { Log(t); }

                for (int i = 0; i < Node.ElefantHigh; i++)
                {
                    try
                    {
                        if (Node.ElephantOnTable == null)
                        {
                            continue;
                        }

                        if (Node.ElephantOnTable[i] == null)
                        {
                            continue;
                        }

                        if (Node.ElephantOnTable[i].ElefantThinkingQuantum == null)
                        {
                            continue;
                        }

                        if (Node.ElephantOnTable[i].ElefantThinkingQuantum[0] == null)
                        {
                            continue;
                        }

                        if (Node.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count == 0)
                        {
                            continue;
                        }

                        Formatters.Serialize(DummyFileStream, Node.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count);
                        for (int j = 0; j < Node.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; j++)
                        {
                            Formatters.Serialize(DummyFileStream, Node.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j]);
                            Node.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                        }
                    }
                    catch (Exception t) { Log(t); }
                }

            }
        }
        public void RewriteAllDrawRecH(BinaryFormatter Formatters, FileStream DummyFileStream, int Order)
        {
            object o = new object();
            lock (o)
            {
                AllDraw Node = this;
                try
                {

                    if (DummyFileStream.Position >= DummyFileStream.Length)
                    {
                        return;
                    }

                    Formatters.Serialize(DummyFileStream, Node.HourseMidle);
                    Formatters.Serialize(DummyFileStream, Node.HourseHight);
                }
                catch (Exception t) { Log(t); }

                for (int i = 0; i < Node.HourseHight; i++)
                {
                    try
                    {
                        if (Node.HoursesOnTable == null)
                        {
                            continue;
                        }

                        if (Node.HoursesOnTable[i] == null)
                        {
                            continue;
                        }

                        if (Node.HoursesOnTable[i].HourseThinkingQuantum == null)
                        {
                            continue;
                        }

                        if (Node.HoursesOnTable[i].HourseThinkingQuantum[0] == null)
                        {
                            continue;
                        }

                        if (Node.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count == 0)
                        {
                            continue;
                        }

                        Formatters.Serialize(DummyFileStream, Node.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count);
                        for (int j = 0; j < Node.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; j++)
                        {
                            Formatters.Serialize(DummyFileStream, Node.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j]);
                            Node.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                        }
                    }
                    catch (Exception t) { Log(t); }
                }
            }
        }

        public void RewriteAllDrawRecC(BinaryFormatter Formatters, FileStream DummyFileStream, int Order)
        {
            object o = new object();
            lock (o)
            {
                AllDraw Node = this;
                try
                {

                    if (DummyFileStream.Position >= DummyFileStream.Length)
                    {
                        return;
                    }

                    Formatters.Serialize(DummyFileStream, Node.CastleMidle);
                    Formatters.Serialize(DummyFileStream, Node.CastleHigh);
                }
                catch (Exception t) { Log(t); }

                for (int i = 0; i < Node.CastleHigh; i++)
                {
                    try
                    {
                        if (Node.CastlesOnTable == null)
                        {
                            continue;
                        }

                        if (Node.CastlesOnTable[i] == null)
                        {
                            continue;
                        }

                        if (Node.CastlesOnTable[i].CastleThinkingQuantum == null)
                        {
                            continue;
                        }

                        if (Node.CastlesOnTable[i].CastleThinkingQuantum[0] == null)
                        {
                            continue;
                        }

                        if (Node.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count == 0)
                        {
                            continue;
                        }

                        Formatters.Serialize(DummyFileStream, Node.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count);
                        for (int j = 0; j < Node.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; j++)
                        {
                            Formatters.Serialize(DummyFileStream, Node.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j]);
                            Node.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                        }
                    }
                    catch (Exception t) { Log(t); }
                }
            }
        }
        public void RewriteAllDrawRecM(BinaryFormatter Formatters, FileStream DummyFileStream, int Order)
        {
            object o = new object();
            lock (o)
            {
                AllDraw Node = this;
                try
                {

                    if (DummyFileStream.Position >= DummyFileStream.Length)
                    {
                        return;
                    }

                    Formatters.Serialize(DummyFileStream, Node.MinisterMidle);
                    Formatters.Serialize(DummyFileStream, Node.MinisterHigh);
                }
                catch (Exception t) { Log(t); }

                for (int i = 0; i < Node.MinisterHigh; i++)
                {
                    try
                    {
                        if (Node.MinisterOnTable == null)
                        {
                            continue;
                        }

                        if (Node.MinisterOnTable[i] == null)
                        {
                            continue;
                        }

                        if (Node.MinisterOnTable[i].MinisterThinkingQuantum == null)
                        {
                            continue;
                        }

                        if (Node.MinisterOnTable[i].MinisterThinkingQuantum[0] == null)
                        {
                            continue;
                        }

                        if (Node.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count == 0)
                        {
                            continue;
                        }

                        Formatters.Serialize(DummyFileStream, Node.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count);
                        for (int j = 0; j < Node.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; j++)
                        {
                            Formatters.Serialize(DummyFileStream, Node.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j]);
                            Node.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                        }
                    }
                    catch (Exception t) { Log(t); }
                }
            }
        }
        public void RewriteAllDrawRecK(BinaryFormatter Formatters, FileStream DummyFileStream, int Order)
        {
            object o = new object();
            lock (o)
            {
                AllDraw Node = this;

                if (DummyFileStream.Position >= DummyFileStream.Length)
                {
                    return;
                }

                try
                {
                    Formatters.Serialize(DummyFileStream, Node.KingMidle);
                    Formatters.Serialize(DummyFileStream, Node.KingHigh);
                }
                catch (Exception t) { Log(t); }

                for (int i = 0; i < Node.KingHigh; i++)
                {
                    try
                    {
                        if (Node.KingOnTable == null)
                        {
                            continue;
                        }

                        if (Node.KingOnTable[i] == null)
                        {
                            continue;
                        }

                        if (Node.KingOnTable[i].KingThinkingQuantum == null)
                        {
                            continue;
                        }

                        if (Node.KingOnTable[i].KingThinkingQuantum[0] == null)
                        {
                            continue;
                        }

                        if (Node.KingOnTable[i].KingThinkingQuantum[0] == null)
                        {
                            continue;
                        }

                        if (Node.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count == 0)
                        {
                            continue;
                        }

                        Formatters.Serialize(DummyFileStream, Node.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count);
                        for (int j = 0; j < Node.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; j++)
                        {
                            Formatters.Serialize(DummyFileStream, Node.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j]);
                            Node.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                        }
                    }
                    catch (Exception t) { Log(t); }
                }
            }
        }
        public void RewriteAllDrawRecA(BinaryFormatter Formatters, FileStream DummyFileStream, int Order)
        {
            object o = new object();
            lock (o)
            {
                AllDraw Node = this;

                if (DummyFileStream.Position >= DummyFileStream.Length)
                {
                    return;
                }


                for (int i = 0; i < 1; i++)
                {
                    try
                    {
                        if (Node.CastlingOnTable == null)
                        {
                            continue;
                        }

                        if (Node.CastlingOnTable[i] == null)
                        {
                            continue;
                        }

                        if (Node.CastlingOnTable[i].CastlingThinking == null)
                        {
                            continue;
                        }

                        if (Node.CastlingOnTable[i].CastlingThinking[0] == null)
                        {
                            continue;
                        }

                        if (Node.CastlingOnTable[i].CastlingThinking[0] == null)
                        {
                            continue;
                        }

                        if (Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count == 0)
                        {
                            continue;
                        }

                        Formatters.Serialize(DummyFileStream, Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count);
                        for (int j = 0; j < Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; j++)
                        {
                            Formatters.Serialize(DummyFileStream, Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j]);
                            Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                        }
                    }
                    catch (Exception t) { Log(t); }
                }
            }
        }
        //loads recursive depend of orderic of writing "pre-proccessing"
        public AllDraw LoaderEC(bool Quantum, int Order, FileStream DummyFileStream, BinaryFormatter Formatters)
        {
            object o = new object();
            lock (o)
            {
                AllDraw Node = this;
                if (DummyFileStream.Position >= DummyFileStream.Length)
                {
                    return Node;
                }
                LoaderECS(Quantum, Order, DummyFileStream, Formatters);              //  if (!Act)
                LoaderECE(Quantum, Order, DummyFileStream, Formatters);
                LoaderECH(Quantum, Order, DummyFileStream, Formatters);
                LoaderECC(Quantum, Order, DummyFileStream, Formatters);
                LoaderECM(Quantum, Order, DummyFileStream, Formatters);
                LoaderECK(Quantum, Order, DummyFileStream, Formatters);
                LoaderECA(Quantum, Order, DummyFileStream, Formatters);

                return Node;
            }
        }

        //loads recursive depend of orderic of writing "pre-proccessing"
        public AllDraw LoaderECS(bool Quantum, int Order, FileStream DummyFileStream, BinaryFormatter Formatters)
        {
            object o = new object();
            lock (o)
            {

                AllDraw Node = this;
                if (DummyFileStream.Position >= DummyFileStream.Length)
                {
                    return Node;
                }
                try
                {
                    Node.SodierMidle = (int)Formatters.Deserialize(DummyFileStream);
                    Node.SodierHigh = (int)Formatters.Deserialize(DummyFileStream);
                }
                catch (Exception t) { Log(t); }
                for (int i = 0; i < Node.SodierHigh; i++)
                {
                    try
                    {
                        if (Node.SolderesOnTable == null)
                        {
                            continue;
                        }

                        if (Node.SolderesOnTable[i] == null)
                        {
                            continue;
                        }

                        if (Node.SolderesOnTable[i].SoldierThinkingQuantum == null)
                        {
                            continue;
                        }

                        if (Node.SolderesOnTable[i].SoldierThinkingQuantum[0] == null)
                        {
                            continue;
                        }

                        if (Node.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count == 0)
                        {
                            continue;
                        }

                        int count = (int)Formatters.Deserialize(DummyFileStream);
                        Node.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Clear();
                        for (int j = 0; j < count; j++)
                        {
                            if (DummyFileStream.Position < DummyFileStream.Length)
                            {
                                Node.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                                Node.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].LoaderEC(Quantum, Order * -1, DummyFileStream, Formatters);
                                Node.SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = Node;
                            }
                        }
                    }
                    catch (Exception t) { Log(t); }
                }
                //  if (!Act)

                return Node;
            }
        }
        //loads recursive depend of orderic of writing "pre-proccessing"
        public AllDraw LoaderECE(bool Quantum, int Order, FileStream DummyFileStream, BinaryFormatter Formatters)
        {
            object o = new object();
            lock (o)
            {
                AllDraw Node = this;
                if (DummyFileStream.Position >= DummyFileStream.Length)
                {
                    return Node;
                }
                try
                {
                    Node.ElefantMidle = (int)Formatters.Deserialize(DummyFileStream);
                    Node.ElefantHigh = (int)Formatters.Deserialize(DummyFileStream);
                }
                catch (Exception t) { Log(t); }
                for (int i = 0; i < Node.ElefantHigh; i++)
                {
                    try
                    {
                        if (Node.ElephantOnTable == null)
                        {
                            continue;
                        }

                        if (Node.ElephantOnTable[i] == null)
                        {
                            continue;
                        }

                        if (Node.ElephantOnTable[i].ElefantThinkingQuantum == null)
                        {
                            continue;
                        }

                        if (Node.ElephantOnTable[i].ElefantThinkingQuantum[0] == null)
                        {
                            continue;
                        }

                        if (Node.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count == 0)
                        {
                            continue;
                        }

                        int count = (int)Formatters.Deserialize(DummyFileStream);
                        Node.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Clear();
                        for (int j = 0; j < count; j++)
                        {
                            if (DummyFileStream.Position < DummyFileStream.Length)
                            {
                                Node.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                                Node.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].LoaderEC(Quantum, Order * -1, DummyFileStream, Formatters);
                                Node.ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = Node;
                            }
                        }
                    }
                    catch (Exception t) { Log(t); }
                }

                return Node;
            }
        }
        //loads recursive depend of orderic of writing "pre-proccessing"
        public AllDraw LoaderECH(bool Quantum, int Order, FileStream DummyFileStream, BinaryFormatter Formatters)
        {
            object o = new object();
            lock (o)
            {
                AllDraw Node = this;
                if (DummyFileStream.Position >= DummyFileStream.Length)
                {
                    return Node;
                }
                try
                {
                    Node.HourseMidle = (int)Formatters.Deserialize(DummyFileStream);
                    Node.HourseHight = (int)Formatters.Deserialize(DummyFileStream);
                }
                catch (Exception t) { Log(t); }
                for (int i = 0; i < Node.HourseHight; i++)
                {
                    try
                    {
                        if (Node.HoursesOnTable == null)
                        {
                            continue;
                        }

                        if (Node.HoursesOnTable[i] == null)
                        {
                            continue;
                        }

                        if (Node.HoursesOnTable[i].HourseThinkingQuantum == null)
                        {
                            continue;
                        }

                        if (Node.HoursesOnTable[i].HourseThinkingQuantum[0] == null)
                        {
                            continue;
                        }

                        if (Node.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count == 0)
                        {
                            continue;
                        }

                        int count = (int)Formatters.Deserialize(DummyFileStream);
                        Node.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Clear();
                        for (int j = 0; j < count; j++)
                        {
                            if (DummyFileStream.Position < DummyFileStream.Length)
                            {
                                Node.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                                Node.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].LoaderEC(Quantum, Order * -1, DummyFileStream, Formatters);
                                Node.HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = Node;
                            }
                        }
                    }
                    catch (Exception t) { Log(t); }
                }
                //  if (!Act)

                return Node;
            }
        }
        //loads recursive depend of orderic of writing "pre-proccessing"
        public AllDraw LoaderECC(bool Quantum, int Order, FileStream DummyFileStream, BinaryFormatter Formatters)
        {
            object o = new object();
            lock (o)
            {
                AllDraw Node = this;
                if (DummyFileStream.Position >= DummyFileStream.Length)
                {
                    return Node;
                }
                try
                {
                    Node.CastleMidle = (int)Formatters.Deserialize(DummyFileStream);
                    Node.CastleHigh = (int)Formatters.Deserialize(DummyFileStream);
                }
                catch (Exception t) { Log(t); }
                for (int i = 0; i < Node.CastleHigh; i++)
                {
                    try
                    {
                        if (Node.CastlesOnTable == null)
                        {
                            continue;
                        }

                        if (Node.CastlesOnTable[i] == null)
                        {
                            continue;
                        }

                        if (Node.CastlesOnTable[i].CastleThinkingQuantum == null)
                        {
                            continue;
                        }

                        if (Node.CastlesOnTable[i].CastleThinkingQuantum[0] == null)
                        {
                            continue;
                        }

                        if (Node.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count == 0)
                        {
                            continue;
                        }

                        int count = (int)Formatters.Deserialize(DummyFileStream);
                        Node.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Clear();
                        for (int j = 0; j < count; j++)
                        {
                            if (DummyFileStream.Position < DummyFileStream.Length)
                            {
                                Node.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                                Node.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].LoaderEC(Quantum, Order * -1, DummyFileStream, Formatters);
                                Node.CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = Node;
                            }
                        }
                    }
                    catch (Exception t) { Log(t); }

                }
                //  if (!Act)

                return Node;
            }
        }
        //loads recursive depend of orderic of writing "pre-proccessing"
        public AllDraw LoaderECM(bool Quantum, int Order, FileStream DummyFileStream, BinaryFormatter Formatters)
        {
            object o = new object();
            lock (o)
            {
                AllDraw Node = this;
                if (DummyFileStream.Position >= DummyFileStream.Length)
                {
                    return Node;
                }
                try
                {
                    Node.MinisterMidle = (int)Formatters.Deserialize(DummyFileStream);
                    Node.MinisterHigh = (int)Formatters.Deserialize(DummyFileStream);
                }
                catch (Exception t) { Log(t); }
                for (int i = 0; i < Node.MinisterHigh; i++)
                {
                    try
                    {
                        if (Node.MinisterOnTable == null)
                        {
                            continue;
                        }

                        if (Node.MinisterOnTable[i] == null)
                        {
                            continue;
                        }

                        if (Node.MinisterOnTable[i].MinisterThinkingQuantum == null)
                        {
                            continue;
                        }

                        if (Node.MinisterOnTable[i].MinisterThinkingQuantum[0] == null)
                        {
                            continue;
                        }

                        if (Node.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count == 0)
                        {
                            continue;
                        }

                        int count = (int)Formatters.Deserialize(DummyFileStream);
                        Node.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Clear();
                        for (int j = 0; j < count; j++)
                        {
                            if (DummyFileStream.Position < DummyFileStream.Length)
                            {
                                Node.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                                Node.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].LoaderEC(Quantum, Order * -1, DummyFileStream, Formatters);
                                Node.MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = Node;
                            }
                        }
                    }
                    catch (Exception t) { Log(t); }

                }
                //  if (!Act)

                return Node;
            }
        }
        //loads recursive depend of orderic of writing "pre-proccessing"
        public AllDraw LoaderECK(bool Quantum, int Order, FileStream DummyFileStream, BinaryFormatter Formatters)
        {
            object o = new object();
            lock (o)
            {
                AllDraw Node = this;
                if (DummyFileStream.Position >= DummyFileStream.Length)
                {
                    return Node;
                }
                try
                {
                    Node.KingMidle = (int)Formatters.Deserialize(DummyFileStream);
                    Node.KingHigh = (int)Formatters.Deserialize(DummyFileStream);
                }
                catch (Exception t) { Log(t); }
                for (int i = 0; i < Node.KingHigh; i++)
                {
                    try
                    {
                        if (Node.KingOnTable == null)
                        {
                            continue;
                        }

                        if (Node.KingOnTable[i] == null)
                        {
                            continue;
                        }

                        if (Node.KingOnTable[i].KingThinkingQuantum == null)
                        {
                            continue;
                        }

                        if (Node.KingOnTable[i].KingThinkingQuantum[0] == null)
                        {
                            continue;
                        }

                        if (Node.KingOnTable[i].KingThinkingQuantum[0] == null)
                        {
                            continue;
                        }

                        if (Node.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count == 0)
                        {
                            continue;
                        }

                        int count = (int)Formatters.Deserialize(DummyFileStream);
                        Node.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Clear();
                        for (int j = 0; j < count; j++)
                        {
                            if (DummyFileStream.Position < DummyFileStream.Length)
                            {
                                Node.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                                Node.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].LoaderEC(Quantum, Order * -1, DummyFileStream, Formatters);
                                Node.KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[j].AStarGreedyString = Node;
                            }
                        }
                    }
                    catch (Exception t) { Log(t); }

                }
                //  if (!Act)

                return Node;
            }
        }
        //loads recursive depend of orderic of writing "pre-proccessing"
        public AllDraw LoaderECA(bool Quantum, int Order, FileStream DummyFileStream, BinaryFormatter Formatters)
        {
            object o = new object();
            lock (o)
            {
                AllDraw Node = this;
                if (DummyFileStream.Position >= DummyFileStream.Length)
                {
                    return Node;
                }
                for (int i = 0; i < 1; i++)
                {
                    try
                    {
                        if (Node.CastlingOnTable == null)
                        {
                            continue;
                        }

                        if (Node.CastlingOnTable[i] == null)
                        {
                            continue;
                        }

                        if (Node.CastlingOnTable[i].CastlingThinking == null)
                        {
                            continue;
                        }

                        if (Node.CastlingOnTable[i].CastlingThinking[0] == null)
                        {
                            continue;
                        }

                        if (Node.CastlingOnTable[i].CastlingThinking[0] == null)
                        {
                            continue;
                        }

                        if (Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count == 0)
                        {
                            continue;
                        }

                        int count = (int)Formatters.Deserialize(DummyFileStream);
                        Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Clear();
                        for (int j = 0; j < count; j++)
                        {
                            if (DummyFileStream.Position < DummyFileStream.Length)
                            {
                                Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                                Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].LoaderEC(Quantum, Order * -1, DummyFileStream, Formatters);
                                Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].AStarGreedyString = Node;
                            }
                        }
                    }
                    catch (Exception t) { Log(t); }

                }
                //  if (!Act)

                return Node;
            }
        }

        private bool UpdateLoseAndWinDepenOfKindBoundryCondition(int kind, int i, int j)
        {
            if (kind == 1)
            {
                if (SolderesOnTable == null)
                {
                    return false;
                }

                if (SolderesOnTable[i] == null)
                {
                    return false;
                }

                if (SolderesOnTable[i].SoldierThinkingQuantum[0] == null)
                {
                    return false;
                }

                if (SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder == null)
                {
                    return false;
                }
            }
            else
            if (kind == 2)
            {
                if (ElephantOnTable == null)
                {
                    return false;
                }

                if (ElephantOnTable[i] == null)
                {
                    return false;
                }

                if (ElephantOnTable[i].ElefantThinkingQuantum[0] == null)
                {
                    return false;
                }

                if (ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant == null)
                {
                    return false;
                }
            }
            else
            if (kind == 3)
            {
                if (HoursesOnTable == null)
                {
                    return false;
                }

                if (HoursesOnTable[i] == null)
                {
                    return false;
                }

                if (HoursesOnTable[i].HourseThinkingQuantum[0] == null)
                {
                    return false;
                }

                if (HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse == null)
                {
                    return false;
                }
            }
            else
            if (kind == 4)
            {
                if (CastlesOnTable == null)
                {
                    return false;
                }

                if (CastlesOnTable[i] == null)
                {
                    return false;
                }

                if (CastlesOnTable[i].CastleThinkingQuantum[0] == null)
                {
                    return false;
                }

                if (CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle == null)
                {
                    return false;
                }
            }
            else
            if (kind == 5)
            {
                if (MinisterOnTable == null)
                {
                    return false;
                }

                if (MinisterOnTable[i] == null)
                {
                    return false;
                }

                if (MinisterOnTable[i].MinisterThinkingQuantum[0] == null)
                {
                    return false;
                }

                if (MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister == null)
                {
                    return false;
                }
            }
            else
            if (kind == 6)
            {
                if (KingOnTable == null)
                {
                    return false;
                }

                if (KingOnTable[i] == null)
                {
                    return false;
                }

                if (KingOnTable[i].KingThinkingQuantum[0] == null)
                {
                    return false;
                }

                if (KingOnTable[i].KingThinkingQuantum[0].TableListKing == null)
                {
                    return false;
                }
            }
            else
            if (kind == 7 || kind == -7)
            {
                if (CastlingOnTable == null)
                {
                    return false;
                }

                if (CastlingOnTable[i] == null)
                {
                    return false;
                }

                if (CastlingOnTable[i].CastlingThinking[0] == null)
                {
                    return false;
                }

                if (CastlingOnTable[i].CastlingThinking[0].TableListCastling == null)
                {
                    return false;
                }
            }
            return true;
        }

        public void UpdateLoseAndWinDepenOfKindSoldier(int i, int Order)
        {
            object a = new object();
            lock (a)
            {
                //when found return recursive
                for (int j = 0; UpdateLoseAndWinDepenOfKindBoundryCondition(1, i, j) && j < SolderesOnTable[i].SoldierThinkingQuantum[0].TableListSolder.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 1))
                    {
                        continue;
                    }

                    //deeper
                    for (int ii = 0; ii < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count; ii++)
                    {
                        SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[ii].UpdateLoseAndWinDepenOfKind(Order * -1);
                    }

                    if (SolderesOnTable[i].WinOcuuredatChiled == 0)
                    {    //non learning autamata victory leafs
                        for (int h = 0; h < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null; h++)
                        {
                            SolderesOnTable[i].WinOcuuredatChiled += SumOfObjects(SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[h], Order * -1);
                        }
                    }
                    if (SolderesOnTable[i].LoseOcuuredatChiled[0] == 0)
                    {   //non learning autamata victom leafs
                        for (int h = 0; h < SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy != null; h++)
                        {
                            SolderesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(SolderesOnTable[i].SoldierThinkingQuantum[0].AStarGreedy[h], Order * -1);
                        }
                    }
                }
            }
        }

        public void UpdateLoseAndWinDepenOfKindElephant(int i, int Order)
        {
            object a = new object();
            lock (a)
            {
                //when found return recursive
                for (int j = 0; UpdateLoseAndWinDepenOfKindBoundryCondition(2, i, j) && j < ElephantOnTable[i].ElefantThinkingQuantum[0].TableListElefant.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 2))
                    {
                        continue;
                    }
                    //deeper
                    for (int ii = 0; ii < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count; ii++)
                    {
                        ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[ii].UpdateLoseAndWinDepenOfKind(Order * -1);
                    }

                    if (ElephantOnTable[i].WinOcuuredatChiled == 0)
                    {    //non learning autamata victory leafs
                        for (int h = 0; h < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null; h++)
                        {
                            ElephantOnTable[i].WinOcuuredatChiled += SumOfObjects(ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[h], Order * -1);
                        }
                    }
                    if (ElephantOnTable[i].LoseOcuuredatChiled[0] == 0)
                    {   //non learning autamata victom leafs
                        for (int h = 0; h < ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy != null; h++)
                        {
                            ElephantOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(ElephantOnTable[i].ElefantThinkingQuantum[0].AStarGreedy[h], Order * -1);
                        }
                    }
                }
            }
        }

        public void UpdateLoseAndWinDepenOfKindHourse(int i, int Order)
        {
            object a = new object();
            lock (a)
            {
                //when found return recursive
                for (int j = 0; UpdateLoseAndWinDepenOfKindBoundryCondition(3, i, j) && j < HoursesOnTable[i].HourseThinkingQuantum[0].TableListHourse.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 3))
                    {
                        continue;
                    }
                    //deeper
                    for (int ii = 0; ii < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count; ii++)
                    {
                        HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[ii].UpdateLoseAndWinDepenOfKind(Order * -1);
                    }

                    if (HoursesOnTable[i].WinOcuuredatChiled == 0)
                    {   //non learning autamata victory leafs
                        for (int h = 0; h < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null; h++)
                        {
                            HoursesOnTable[i].WinOcuuredatChiled += SumOfObjects(HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[h], Order * -1);
                        }
                    }
                    if (HoursesOnTable[i].LoseOcuuredatChiled[0] == 0)
                    {   //non learning autamata victom leafs
                        for (int h = 0; h < HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy != null; h++)
                        {
                            HoursesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(HoursesOnTable[i].HourseThinkingQuantum[0].AStarGreedy[h], Order * -1);
                        }
                    }
                }
            }
        }

        public void UpdateLoseAndWinDepenOfKindCastle(int i, int Order)
        {
            object a = new object();
            lock (a)
            {
                //when found return recursive
                for (int j = 0; UpdateLoseAndWinDepenOfKindBoundryCondition(4, i, j) && j < CastlesOnTable[i].CastleThinkingQuantum[0].TableListCastle.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 4))
                    {
                        continue;
                    }

                    //deeper
                    for (int ii = 0; ii < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count; ii++)
                    {
                        CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[ii].UpdateLoseAndWinDepenOfKind(Order * -1);
                    }

                    if (CastlesOnTable[i].WinOcuuredatChiled == 0)
                    { //non learning autamata victory leafs
                        for (int h = 0; h < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null; h++)
                        {
                            CastlesOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[h], Order * -1);
                        }
                    }
                    if (CastlesOnTable[i].LoseOcuuredatChiled[0] == 0)
                    {
                        for (int h = 0; h < CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy != null; h++)
                        {
                            CastlesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(CastlesOnTable[i].CastleThinkingQuantum[0].AStarGreedy[h], Order * -1);
                        }
                    }
                }
            }
        }

        public void UpdateLoseAndWinDepenOfKindMinister(int i, int Order)
        {
            object a = new object();
            lock (a)
            {
                //when found return recursive
                for (int j = 0; UpdateLoseAndWinDepenOfKindBoundryCondition(5, i, j) && j < MinisterOnTable[i].MinisterThinkingQuantum[0].TableListMinister.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 5))
                    {
                        continue;
                    }
                    //deeper
                    for (int ii = 0; ii < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count; ii++)
                    {
                        MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[ii].UpdateLoseAndWinDepenOfKind(Order * -1);
                    }

                    if (MinisterOnTable[i].WinOcuuredatChiled == 0)
                    {  //non learning autamata victory leafs
                        for (int h = 0; h < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null; h++)
                        {
                            MinisterOnTable[i].WinOcuuredatChiled += SumOfObjects(MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[h], Order * -1);
                        }
                    }
                    if (MinisterOnTable[i].LoseOcuuredatChiled[0] == 0)
                    {   //non learning autamata victom leafs
                        for (int h = 0; h < MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy != null; h++)
                        {
                            MinisterOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(MinisterOnTable[i].MinisterThinkingQuantum[0].AStarGreedy[h], Order * -1);
                        }
                    }
                }
            }
        }

        public void UpdateLoseAndWinDepenOfKindKing(int i, int Order)
        {
            object a = new object();
            lock (a)
            {
                //when found return recursive
                for (int j = 0; UpdateLoseAndWinDepenOfKindBoundryCondition(6, i, j) && j < KingOnTable[i].KingThinkingQuantum[0].TableListKing.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 6))
                    {
                        continue;
                    }
                    //deeper
                    for (int ii = 0; ii < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count; ii++)
                    {
                        KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[ii].UpdateLoseAndWinDepenOfKind(Order * -1);
                    }

                    if (KingOnTable[i].WinOcuuredatChiled == 0)
                    {
                        //non learning autamata victory leafs
                        for (int h = 0; h < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null; h++)
                        {
                            KingOnTable[i].WinOcuuredatChiled += SumOfObjects(KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[h], Order * -1);
                        }
                    }
                    if (KingOnTable[i].LoseOcuuredatChiled[0] == 0)
                    {   //non learning autamata victom leafs
                        for (int h = 0; h < KingOnTable[i].KingThinkingQuantum[0].AStarGreedy.Count && KingOnTable[i].KingThinkingQuantum[0].AStarGreedy != null; h++)
                        {
                            KingOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(KingOnTable[i].KingThinkingQuantum[0].AStarGreedy[h], Order * -1);
                        }
                    }
                }
            }
        }

        public void UpdateLoseAndWinDepenOfKindCastling(int i, int Order)
        {
            object a = new object();
            lock (a)
            {
                //when found return recursive
                for (int j = 0; UpdateLoseAndWinDepenOfKindBoundryCondition(7, i, j) && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 7))
                    {
                        continue;
                    }
                    //deeper
                    for (int ii = 0; ii < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                    {
                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii].UpdateLoseAndWinDepenOfKind(Order * -1);
                    }

                    if (CastlingOnTable[i].WinOcuuredatChiled == 0)
                    {
                        //non learning autamata victory leafs
                        for (int h = 0; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null; h++)
                        {
                            CastlingOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h], Order * -1);
                        }
                    }
                    if (CastlingOnTable[i].LoseOcuuredatChiled[0] == 0)
                    {   //non learning autamata victom leafs
                        for (int h = 0; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null; h++)
                        {
                            CastlingOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h], Order * -1);
                        }
                    }
                }
            }
        }

        //found of leadfs of created Tree depend of orderic
        public void UpdateLoseAndWinDepenOfKind(int Order)
        {
            object a = new object();
            lock (a)
            {
                //when found return recursive
                //Gray
                if (Order == 1)
                {
                    for (int i = 0; i < SodierMidle; i++)
                    {
                        UpdateLoseAndWinDepenOfKindSoldier(i, Order);
                    }
                    for (int i = 0; i < ElefantMidle; i++)
                    {
                        UpdateLoseAndWinDepenOfKindElephant(i, Order);
                    }
                    for (int i = 0; i < HourseMidle; i++)
                    {
                        UpdateLoseAndWinDepenOfKindHourse(i, Order);
                    }
                    for (int i = 0; i < CastleMidle; i++)
                    {
                        UpdateLoseAndWinDepenOfKindCastle(i, Order);
                    }
                    for (int i = 0; i < MinisterMidle; i++)
                    {
                        UpdateLoseAndWinDepenOfKindMinister(i, Order);
                    }
                    for (int i = 0; i < KingMidle; i++)
                    {
                        UpdateLoseAndWinDepenOfKindKing(i, Order);
                    }
                    for (int i = 0; i < 1; i++)
                    {
                        UpdateLoseAndWinDepenOfKindCastling(i, Order);
                    }
                }
                else
                {
                    for (int i = SodierMidle; i < SodierHigh; i++)
                    {
                        UpdateLoseAndWinDepenOfKindSoldier(i, Order);
                    }
                    for (int i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        UpdateLoseAndWinDepenOfKindElephant(i, Order);
                    }
                    for (int i = HourseMidle; i < HourseHight; i++)
                    {
                        UpdateLoseAndWinDepenOfKindHourse(i, Order);
                    }
                    for (int i = CastleMidle; i < CastleHigh; i++)
                    {
                        UpdateLoseAndWinDepenOfKindCastle(i, Order);
                    }
                    for (int i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        UpdateLoseAndWinDepenOfKindMinister(i, Order);
                    }
                    for (int i = KingMidle; i < KingHigh; i++)
                    {
                        UpdateLoseAndWinDepenOfKindKing(i, Order);
                    }
                    for (int i = 0; i < 1; i++)
                    {
                        UpdateLoseAndWinDepenOfKindCastling(i, Order);
                    }
                }
            }
        }

        private bool IsMovableLoseOcuuredatChiled(int[,] Tab, int Kind, int Order, int i)
        {
            bool Is = false;
            if (Kind == 1)
            {
                if (ServeBoundryConditionsSoldier(i, Kind, Order))
                {
                    return false;
                }

                if (SolderesOnTable[i].LoseOcuuredatChiled[0] == 5)
                {
                    Order = 1;
                    if (Tab[SolderesOnTable[i].LoseOcuuredatChiled[1], SolderesOnTable[i].LoseOcuuredatChiled[2]] < 0)
                    {
                        Order = -1;
                    }

                    for (int Row = 0; Row < 8; Row++)
                    {
                        for (int Col = 0; Col < 8; Col++)
                        {
                            if (Movable(CloneATable(Tab), SolderesOnTable[i].LoseOcuuredatChiled[1], SolderesOnTable[i].LoseOcuuredatChiled[2], Row, Col, OrderColor(Order), Order))
                            {
                                return true;
                            }
                        }
                    }
                }
            }
            else
            if (Kind == 2)
            {
                if (ServeBoundryConditionsElephant(i, Kind, Order))
                {
                    return false;
                }

                if (ElephantOnTable[i].LoseOcuuredatChiled[0] == 5)
                {
                    Order = 1;
                    if (Tab[ElephantOnTable[i].LoseOcuuredatChiled[1], ElephantOnTable[i].LoseOcuuredatChiled[2]] < 0)
                    {
                        Order = -1;
                    }

                    for (int Row = 0; Row < 8; Row++)
                    {
                        for (int Col = 0; Col < 8; Col++)
                        {
                            if (Movable(CloneATable(Tab), ElephantOnTable[i].LoseOcuuredatChiled[1], ElephantOnTable[i].LoseOcuuredatChiled[2], Row, Col, OrderColor(Order), Order))
                            {
                                return true;
                            }
                        }
                    }
                }
            }
            else
            if (Kind == 3)
            {
                if (ServeBoundryConditionsHourse(i, Kind, Order))
                {
                    return false;
                }

                if (HoursesOnTable[i].LoseOcuuredatChiled[0] == 5)
                {
                    Order = 1;
                    if (Tab[HoursesOnTable[i].LoseOcuuredatChiled[1], HoursesOnTable[i].LoseOcuuredatChiled[2]] < 0)
                    {
                        Order = -1;
                    }

                    for (int Row = 0; Row < 8; Row++)
                    {
                        for (int Col = 0; Col < 8; Col++)
                        {
                            if (Movable(CloneATable(Tab), HoursesOnTable[i].LoseOcuuredatChiled[1], HoursesOnTable[i].LoseOcuuredatChiled[2], Row, Col, OrderColor(Order), Order))
                            {
                                return true;
                            }
                        }
                    }
                }
            }
            else
            if (Kind == 4)
            {
                if (ServeBoundryConditionsCastle(i, Kind, Order))
                {
                    return false;
                }

                if (CastlesOnTable[i].LoseOcuuredatChiled[0] == 5)
                {
                    Order = 1;
                    if (Tab[CastlesOnTable[i].LoseOcuuredatChiled[1], CastlesOnTable[i].LoseOcuuredatChiled[2]] < 0)
                    {
                        Order = -1;
                    }

                    for (int Row = 0; Row < 8; Row++)
                    {
                        for (int Col = 0; Col < 8; Col++)
                        {
                            if (Movable(CloneATable(Tab), CastlesOnTable[i].LoseOcuuredatChiled[1], CastlesOnTable[i].LoseOcuuredatChiled[2], Row, Col, OrderColor(Order), Order))
                            {
                                return true;
                            }
                        }
                    }
                }
            }
            else
            if (Kind == 5)
            {
                if (ServeBoundryConditionsMinister(i, Kind, Order))
                {
                    return false;
                }

                if (MinisterOnTable[i].LoseOcuuredatChiled[0] == 5)
                {
                    Order = 1;
                    if (Tab[MinisterOnTable[i].LoseOcuuredatChiled[1], MinisterOnTable[i].LoseOcuuredatChiled[2]] < 0)
                    {
                        Order = -1;
                    }

                    for (int Row = 0; Row < 8; Row++)
                    {
                        for (int Col = 0; Col < 8; Col++)
                        {
                            if (Movable(CloneATable(Tab), MinisterOnTable[i].LoseOcuuredatChiled[1], MinisterOnTable[i].LoseOcuuredatChiled[2], Row, Col, OrderColor(Order), Order))
                            {
                                return true;
                            }
                        }
                    }
                }
            }
            else
            if (Kind == 6)
            {
                if (ServeBoundryConditionsKing(i, Kind, Order))
                {
                    return false;
                }

                if (KingOnTable[i].LoseOcuuredatChiled[0] == 5)
                {
                    Order = 1;
                    if (Tab[KingOnTable[i].LoseOcuuredatChiled[1], KingOnTable[i].LoseOcuuredatChiled[2]] < 0)
                    {
                        Order = -1;
                    }

                    for (int Row = 0; Row < 8; Row++)
                    {
                        for (int Col = 0; Col < 8; Col++)
                        {
                            if (Movable(CloneATable(Tab), KingOnTable[i].LoseOcuuredatChiled[1], KingOnTable[i].LoseOcuuredatChiled[2], Row, Col, OrderColor(Order), Order))
                            {
                                return true;
                            }
                        }
                    }
                }
            }
            else
            if (Kind == 7 || Kind == -7)
            {
                if (ServeBoundryConditionsCasttling(i, Kind, Order))
                {
                    return false;
                }

                if (CastlingOnTable[i].LoseOcuuredatChiled[0] == 5)
                {
                    Order = 1;
                    if (Tab[CastlingOnTable[i].LoseOcuuredatChiled[1], CastlingOnTable[i].LoseOcuuredatChiled[2]] < 0)
                    {
                        Order = -1;
                    }

                    for (int Row = 0; Row < 8; Row++)
                    {
                        for (int Col = 0; Col < 8; Col++)
                        {
                            if (Movable(CloneATable(Tab), CastlingOnTable[i].LoseOcuuredatChiled[1], CastlingOnTable[i].LoseOcuuredatChiled[2], Row, Col, OrderColor(Order), Order))
                            {
                                return true;
                            }
                        }
                    }
                }
            }
            return Is;
        }

        //return color depend of order
        private Color OrderColor(int Ord)
        {
            object O = new object();
            lock (O)
            {
                Color a = Color.Gray;
                if (Ord == -1)
                {
                    a = Color.Brown;
                }

                return a;
            }
        }

        ///Move Determination.
        public bool Movable(int[,] Tab, int i, int j, int ii, int jj, Color a, int Order)
        {
            object O = new object();
            lock (O)
            {
                if (Tab[i, j] == 0)
                {
                    return false;
                }

                if (Order == 1 && Tab[i, j] < 0)
                {
                    return false;
                }

                if (Order == -1 && Tab[i, j] > 0)
                {
                    return false;
                }

                int[,] Table = new int[8, 8];
                for (int p = 0; p < 8; p++)
                {
                    for (int k = 0; k < 8; k++)
                    {
                        Table[p, k] = Tab[p, k];
                    }
                }
                //Initiate Local Variables.
                int Store = Table[ii, jj];
                ChessRules A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Table[i, j], CloneATable(Table), Order);
                //Menen Parameter is Moveble to Second Parameters Location returm Movable.
                if (Order == 1 && Table[ii, jj] < 0)
                {
                    if (A.Rules(i, j, ii, jj, Order))
                    {
                        return true;
                    }
                }
                else
                 if (Order == -1 && Table[ii, jj] > 0)
                {
                    if (A.Rules(i, j, ii, jj, Order))
                    {
                        return true;
                    }
                }
                if (Order == 1 && Table[ii, jj] == 0)
                {
                    if (A.Rules(i, j, ii, jj, Order))
                    {
                        return true;
                    }
                }
                else
                if (Order == -1 && Table[ii, jj] == 0)
                {
                    if (A.Rules(i, j, ii, jj, Order))
                    {
                        return true;
                    }
                }

                return false;
            }
        }

        public virtual bool UpdateJungleTree(QuantumRefrigiz.AllDraw jungle, int i, int j, int kindA)
        {
            return true;
        }
    }
}

//End of Documentation.